/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.14.4.0 (NJsonSchema v10.5.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export class ActivitiesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAll(): Promise<string[]> {
        let url_ = this.baseUrl + "/api/Activities";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    post(body: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Activities";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    get(id: number): Promise<string> {
        let url_ = this.baseUrl + "/api/Activities/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    put(id: number, body: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Activities/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPut(_response);
        });
    }

    protected processPut(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/Activities/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class AskForLeaveClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param skip (optional) 
     * @param take (optional) 
     * @param userDepartment (optional) 
     * @param userDisplayName (optional) 
     * @return Success
     */
    get(skip: number | undefined, take: number | undefined, userDepartment: string | undefined, userDisplayName: string | undefined): Promise<AskForLeaveFormTCollectionWithPagination> {
        let url_ = this.baseUrl + "/api/AskForLeave?";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&";
        if (userDepartment === null)
            throw new Error("The parameter 'userDepartment' cannot be null.");
        else if (userDepartment !== undefined)
            url_ += "userDepartment=" + encodeURIComponent("" + userDepartment) + "&";
        if (userDisplayName === null)
            throw new Error("The parameter 'userDisplayName' cannot be null.");
        else if (userDisplayName !== undefined)
            url_ += "userDisplayName=" + encodeURIComponent("" + userDisplayName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<AskForLeaveFormTCollectionWithPagination> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AskForLeaveFormTCollectionWithPagination.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AskForLeaveFormTCollectionWithPagination>(<any>null);
    }

    /**
     * @return Success
     */
    exportWord(): Promise<void> {
        let url_ = this.baseUrl + "/api/AskForLeave/export";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExportWord(_response);
        });
    }

    protected processExportWord(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class AttachmentsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 旧的OA能否编辑附件
     * @param taskId (optional) 
     * @return Success
     */
    oldOACanEditFile(taskId: string | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Attachments/OldOACanEditFile?";
        if (taskId === null)
            throw new Error("The parameter 'taskId' cannot be null.");
        else if (taskId !== undefined)
            url_ += "taskId=" + encodeURIComponent("" + taskId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOldOACanEditFile(_response);
        });
    }

    protected processOldOACanEditFile(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * 获取附件列表
     * @param businessKey (optional) 
     * @param taskId (optional) 
     * @param isOldOAArchMonitor (optional) 
     * @param onlyShowNullTagAttachments (optional) 只显示空标记附件
     * @return Success
     */
    getFormAttachments(businessKey: string | undefined, taskId: string | undefined, isOldOAArchMonitor: boolean | undefined, onlyShowNullTagAttachments: boolean | undefined): Promise<FormAttachmentDto[]> {
        let url_ = this.baseUrl + "/api/Attachments?";
        if (businessKey === null)
            throw new Error("The parameter 'businessKey' cannot be null.");
        else if (businessKey !== undefined)
            url_ += "businessKey=" + encodeURIComponent("" + businessKey) + "&";
        if (taskId === null)
            throw new Error("The parameter 'taskId' cannot be null.");
        else if (taskId !== undefined)
            url_ += "taskId=" + encodeURIComponent("" + taskId) + "&";
        if (isOldOAArchMonitor === null)
            throw new Error("The parameter 'isOldOAArchMonitor' cannot be null.");
        else if (isOldOAArchMonitor !== undefined)
            url_ += "isOldOAArchMonitor=" + encodeURIComponent("" + isOldOAArchMonitor) + "&";
        if (onlyShowNullTagAttachments === null)
            throw new Error("The parameter 'onlyShowNullTagAttachments' cannot be null.");
        else if (onlyShowNullTagAttachments !== undefined)
            url_ += "onlyShowNullTagAttachments=" + encodeURIComponent("" + onlyShowNullTagAttachments) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFormAttachments(_response);
        });
    }

    protected processGetFormAttachments(response: Response): Promise<FormAttachmentDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FormAttachmentDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FormAttachmentDto[]>(<any>null);
    }

    /**
     * 上传附件
     * @param businessKey (optional) 
     * @param tag (optional) 自定义标记
     * @return Success
     */
    addArchAttachment(businessKey: string | undefined, tag: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Attachments?";
        if (businessKey === null)
            throw new Error("The parameter 'businessKey' cannot be null.");
        else if (businessKey !== undefined)
            url_ += "businessKey=" + encodeURIComponent("" + businessKey) + "&";
        if (tag === null)
            throw new Error("The parameter 'tag' cannot be null.");
        else if (tag !== undefined)
            url_ += "tag=" + encodeURIComponent("" + tag) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddArchAttachment(_response);
        });
    }

    protected processAddArchAttachment(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * 获取附件上传下载地址
     * @param downloadUrl (optional) 
     * @return Success
     */
    getAttachmentNewestUploadAndDownloadUrl(downloadUrl: string | undefined): Promise<NewestUploadAndDownloadUrlViewModel> {
        let url_ = this.baseUrl + "/api/Attachments/downloadUrl?";
        if (downloadUrl === null)
            throw new Error("The parameter 'downloadUrl' cannot be null.");
        else if (downloadUrl !== undefined)
            url_ += "downloadUrl=" + encodeURIComponent("" + downloadUrl) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAttachmentNewestUploadAndDownloadUrl(_response);
        });
    }

    protected processGetAttachmentNewestUploadAndDownloadUrl(response: Response): Promise<NewestUploadAndDownloadUrlViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NewestUploadAndDownloadUrlViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NewestUploadAndDownloadUrlViewModel>(<any>null);
    }

    /**
     * 获取附件根据Id
     * @param id (optional) 
     * @return Success
     */
    getFormAttachmentById(id: string | undefined): Promise<FormAttachmentDto> {
        let url_ = this.baseUrl + "/api/Attachments/id?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFormAttachmentById(_response);
        });
    }

    protected processGetFormAttachmentById(response: Response): Promise<FormAttachmentDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FormAttachmentDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FormAttachmentDto>(<any>null);
    }

    /**
     * WPS修改附件后上传(新)
     * @param id (optional) 
     * @return Success
     */
    updateAttachmentByWps(id: string | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Attachments/wpsex?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateAttachmentByWps(_response);
        });
    }

    protected processUpdateAttachmentByWps(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * WPS修改附件后上传
     * @param id (optional) 
     * @param rowVersion (optional) 
     * @param userName (optional) 
     * @param taskId (optional) 
     * @return Success
     */
    updateAttachment(id: string | undefined, rowVersion: string | undefined, userName: string | undefined, taskId: string | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Attachments/wps?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (rowVersion === null)
            throw new Error("The parameter 'rowVersion' cannot be null.");
        else if (rowVersion !== undefined)
            url_ += "rowVersion=" + encodeURIComponent("" + rowVersion) + "&";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&";
        if (taskId === null)
            throw new Error("The parameter 'taskId' cannot be null.");
        else if (taskId !== undefined)
            url_ += "taskId=" + encodeURIComponent("" + taskId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateAttachment(_response);
        });
    }

    protected processUpdateAttachment(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key] ? ModelStateEntry.fromJS(resultData400[key]) : new ModelStateEntry();
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * 删除附件
     * @return Success
     */
    deleteArchAttachment(attachmentId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Attachments/{attachmentId}";
        if (attachmentId === undefined || attachmentId === null)
            throw new Error("The parameter 'attachmentId' must be defined.");
        url_ = url_.replace("{attachmentId}", encodeURIComponent("" + attachmentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteArchAttachment(_response);
        });
    }

    protected processDeleteArchAttachment(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * 下载附件
     * @param showRevision (optional) 
     * @return Success
     */
    download(id: string, showRevision: boolean | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Attachments/Download/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (showRevision === null)
            throw new Error("The parameter 'showRevision' cannot be null.");
        else if (showRevision !== undefined)
            url_ += "showRevision=" + encodeURIComponent("" + showRevision) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDownload(_response);
        });
    }

    protected processDownload(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param userName (optional) 
     * @param proDefKey (optional) 
     * @param businessKey (optional) 
     * @param onlyShowNullTagAttachments (optional) 
     * @return Success
     */
    downloadAllAttachments(userName: string | undefined, proDefKey: string | undefined, businessKey: string | undefined, onlyShowNullTagAttachments: boolean | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Attachments/DownloadAllAttachments?";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&";
        if (proDefKey === null)
            throw new Error("The parameter 'proDefKey' cannot be null.");
        else if (proDefKey !== undefined)
            url_ += "proDefKey=" + encodeURIComponent("" + proDefKey) + "&";
        if (businessKey === null)
            throw new Error("The parameter 'businessKey' cannot be null.");
        else if (businessKey !== undefined)
            url_ += "businessKey=" + encodeURIComponent("" + businessKey) + "&";
        if (onlyShowNullTagAttachments === null)
            throw new Error("The parameter 'onlyShowNullTagAttachments' cannot be null.");
        else if (onlyShowNullTagAttachments !== undefined)
            url_ += "onlyShowNullTagAttachments=" + encodeURIComponent("" + onlyShowNullTagAttachments) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDownloadAllAttachments(_response);
        });
    }

    protected processDownloadAllAttachments(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * 套红头
     * @param body (optional) 
     * @return Success
     */
    takeRedHeat(body: TaskRedHatViewModel | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Attachments/TakeRedHeat";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTakeRedHeat(_response);
        });
    }

    protected processTakeRedHeat(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * 更新附件顺序
     * @param order (optional) 
     * @return Success
     */
    updateAttachmentOrder(id: string, order: number | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Attachments/order/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (order === null)
            throw new Error("The parameter 'order' cannot be null.");
        else if (order !== undefined)
            url_ += "order=" + encodeURIComponent("" + order) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateAttachmentOrder(_response);
        });
    }

    protected processUpdateAttachmentOrder(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class AttachmentsManagerClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param businessKey (optional) 
     * @param fileNameStartWith (optional) 
     * @param fileNameEndWith (optional) 
     * @param fileNameContains (optional) 
     * @param offset (optional) 
     * @param take (optional) 
     * @param body (optional) 
     * @return Success
     */
    queryFormAttachments(businessKey: string | undefined, fileNameStartWith: string | undefined, fileNameEndWith: string | undefined, fileNameContains: string | undefined, offset: number | undefined, take: number | undefined, body: string[] | undefined): Promise<AttachmentManagerItemTCollectionWithPagination> {
        let url_ = this.baseUrl + "/api/AttachmentsManager/query?";
        if (businessKey === null)
            throw new Error("The parameter 'businessKey' cannot be null.");
        else if (businessKey !== undefined)
            url_ += "businessKey=" + encodeURIComponent("" + businessKey) + "&";
        if (fileNameStartWith === null)
            throw new Error("The parameter 'fileNameStartWith' cannot be null.");
        else if (fileNameStartWith !== undefined)
            url_ += "fileNameStartWith=" + encodeURIComponent("" + fileNameStartWith) + "&";
        if (fileNameEndWith === null)
            throw new Error("The parameter 'fileNameEndWith' cannot be null.");
        else if (fileNameEndWith !== undefined)
            url_ += "fileNameEndWith=" + encodeURIComponent("" + fileNameEndWith) + "&";
        if (fileNameContains === null)
            throw new Error("The parameter 'fileNameContains' cannot be null.");
        else if (fileNameContains !== undefined)
            url_ += "fileNameContains=" + encodeURIComponent("" + fileNameContains) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processQueryFormAttachments(_response);
        });
    }

    protected processQueryFormAttachments(response: Response): Promise<AttachmentManagerItemTCollectionWithPagination> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AttachmentManagerItemTCollectionWithPagination.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AttachmentManagerItemTCollectionWithPagination>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getFormAttachmentById(id: string | undefined): Promise<FormAttachmentDto> {
        let url_ = this.baseUrl + "/api/AttachmentsManager/id?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFormAttachmentById(_response);
        });
    }

    protected processGetFormAttachmentById(response: Response): Promise<FormAttachmentDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FormAttachmentDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FormAttachmentDto>(<any>null);
    }

    /**
     * @param businessKey (optional) 
     * @param tag (optional) 
     * @return Success
     */
    addArchAttachment(businessKey: string | undefined, tag: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/AttachmentsManager?";
        if (businessKey === null)
            throw new Error("The parameter 'businessKey' cannot be null.");
        else if (businessKey !== undefined)
            url_ += "businessKey=" + encodeURIComponent("" + businessKey) + "&";
        if (tag === null)
            throw new Error("The parameter 'tag' cannot be null.");
        else if (tag !== undefined)
            url_ += "tag=" + encodeURIComponent("" + tag) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddArchAttachment(_response);
        });
    }

    protected processAddArchAttachment(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param rowVersion (optional) 
     * @param userName (optional) 
     * @param taskId (optional) 
     * @return Success
     */
    updateAttachment(id: string | undefined, rowVersion: string | undefined, userName: string | undefined, taskId: string | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/AttachmentsManager/wps?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (rowVersion === null)
            throw new Error("The parameter 'rowVersion' cannot be null.");
        else if (rowVersion !== undefined)
            url_ += "rowVersion=" + encodeURIComponent("" + rowVersion) + "&";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&";
        if (taskId === null)
            throw new Error("The parameter 'taskId' cannot be null.");
        else if (taskId !== undefined)
            url_ += "taskId=" + encodeURIComponent("" + taskId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateAttachment(_response);
        });
    }

    protected processUpdateAttachment(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key] ? ModelStateEntry.fromJS(resultData400[key]) : new ModelStateEntry();
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @return Success
     */
    deleteArchAttachment(attachmentId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/AttachmentsManager/{attachmentId}";
        if (attachmentId === undefined || attachmentId === null)
            throw new Error("The parameter 'attachmentId' must be defined.");
        url_ = url_.replace("{attachmentId}", encodeURIComponent("" + attachmentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteArchAttachment(_response);
        });
    }

    protected processDeleteArchAttachment(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param userName (optional) 
     * @param proDefKey (optional) 
     * @param businessKey (optional) 
     * @param onlyShowNullTagAttachments (optional) 
     * @return Success
     */
    downloadAllAttachments(userName: string | undefined, proDefKey: string | undefined, businessKey: string | undefined, onlyShowNullTagAttachments: boolean | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/AttachmentsManager/DownloadAllAttachments?";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&";
        if (proDefKey === null)
            throw new Error("The parameter 'proDefKey' cannot be null.");
        else if (proDefKey !== undefined)
            url_ += "proDefKey=" + encodeURIComponent("" + proDefKey) + "&";
        if (businessKey === null)
            throw new Error("The parameter 'businessKey' cannot be null.");
        else if (businessKey !== undefined)
            url_ += "businessKey=" + encodeURIComponent("" + businessKey) + "&";
        if (onlyShowNullTagAttachments === null)
            throw new Error("The parameter 'onlyShowNullTagAttachments' cannot be null.");
        else if (onlyShowNullTagAttachments !== undefined)
            url_ += "onlyShowNullTagAttachments=" + encodeURIComponent("" + onlyShowNullTagAttachments) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDownloadAllAttachments(_response);
        });
    }

    protected processDownloadAllAttachments(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    takeRedHeat(body: TaskRedHatViewModel | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/AttachmentsManager/TakeRedHeat";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTakeRedHeat(_response);
        });
    }

    protected processTakeRedHeat(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param order (optional) 
     * @return Success
     */
    updateAttachmentOrder(id: string, order: number | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/AttachmentsManager/order/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (order === null)
            throw new Error("The parameter 'order' cannot be null.");
        else if (order !== undefined)
            url_ += "order=" + encodeURIComponent("" + order) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateAttachmentOrder(_response);
        });
    }

    protected processUpdateAttachmentOrder(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class AttachmentsNewClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 获取附件列表
     * @param businessKey (optional) 
     * @param oldOATaskId (optional) 
     * @return Success
     */
    getFormAttachments(businessKey: string | undefined, oldOATaskId: string | undefined): Promise<FormAttachmentDto[]> {
        let url_ = this.baseUrl + "/api/AttachmentsNew?";
        if (businessKey === null)
            throw new Error("The parameter 'businessKey' cannot be null.");
        else if (businessKey !== undefined)
            url_ += "businessKey=" + encodeURIComponent("" + businessKey) + "&";
        if (oldOATaskId === null)
            throw new Error("The parameter 'oldOATaskId' cannot be null.");
        else if (oldOATaskId !== undefined)
            url_ += "oldOATaskId=" + encodeURIComponent("" + oldOATaskId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFormAttachments(_response);
        });
    }

    protected processGetFormAttachments(response: Response): Promise<FormAttachmentDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FormAttachmentDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FormAttachmentDto[]>(<any>null);
    }

    /**
     * 获取附件根据Id
     * @param id (optional) 
     * @return Success
     */
    getFormAttachmentById(id: string | undefined): Promise<FormAttachmentDto> {
        let url_ = this.baseUrl + "/api/AttachmentsNew/id?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFormAttachmentById(_response);
        });
    }

    protected processGetFormAttachmentById(response: Response): Promise<FormAttachmentDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FormAttachmentDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FormAttachmentDto>(<any>null);
    }

    /**
     * WPS修改附件后上传
     * @return Success
     */
    updateAttachment(id: string): Promise<string> {
        let url_ = this.baseUrl + "/api/AttachmentsNew/wps/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateAttachment(_response);
        });
    }

    protected processUpdateAttachment(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key] ? ModelStateEntry.fromJS(resultData400[key]) : new ModelStateEntry();
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * 下载附件
     * @return Success
     */
    download(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/AttachmentsNew/Download/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDownload(_response);
        });
    }

    protected processDownload(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * 上传或修改附件
     * @param businessKey (optional) 
     * @param taskId (optional) 
     * @param formFile (optional) 
     * @return Success
     */
    uploadOrUpdateAttachment(businessKey: string | undefined, taskId: string | undefined, formFile: FileParameter | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/AttachmentsNew/UploadOrUpdate?";
        if (businessKey === null)
            throw new Error("The parameter 'businessKey' cannot be null.");
        else if (businessKey !== undefined)
            url_ += "businessKey=" + encodeURIComponent("" + businessKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (taskId === null || taskId === undefined)
            throw new Error("The parameter 'taskId' cannot be null.");
        else
            content_.append("taskId", taskId.toString());
        if (formFile === null || formFile === undefined)
            throw new Error("The parameter 'formFile' cannot be null.");
        else
            content_.append("formFile", formFile.data, formFile.fileName ? formFile.fileName : "formFile");

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUploadOrUpdateAttachment(_response);
        });
    }

    protected processUploadOrUpdateAttachment(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class CopySendTasksClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param skip (optional) 
     * @param take (optional) 
     * @param title (optional) 
     * @return Success
     */
    getAll(skip: number | undefined, take: number | undefined, title: string | undefined): Promise<string[]> {
        let url_ = this.baseUrl + "/api/CopySendTasks?";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&";
        if (title === null)
            throw new Error("The parameter 'title' cannot be null.");
        else if (title !== undefined)
            url_ += "title=" + encodeURIComponent("" + title) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    post(body: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/CopySendTasks";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    get(id: number): Promise<string> {
        let url_ = this.baseUrl + "/api/CopySendTasks/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    put(id: number, body: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/CopySendTasks/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPut(_response);
        });
    }

    protected processPut(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/CopySendTasks/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class DataStorageClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param skip (optional) 
     * @param take (optional) 
     * @return Success
     */
    getTableItems(tableName: string, skip: number | undefined, take: number | undefined): Promise<any[]> {
        let url_ = this.baseUrl + "/api/DataStorage/{tableName}?";
        if (tableName === undefined || tableName === null)
            throw new Error("The parameter 'tableName' must be defined.");
        url_ = url_.replace("{tableName}", encodeURIComponent("" + tableName));
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTableItems(_response);
        });
    }

    protected processGetTableItems(response: Response): Promise<any[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insertItem(tableName: string, body: StorageItemModel | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/DataStorage/{tableName}";
        if (tableName === undefined || tableName === null)
            throw new Error("The parameter 'tableName' must be defined.");
        url_ = url_.replace("{tableName}", encodeURIComponent("" + tableName));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInsertItem(_response);
        });
    }

    protected processInsertItem(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class DepartmentsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getOrganizations(): Promise<Organization[]> {
        let url_ = this.baseUrl + "/api/Departments/organizations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetOrganizations(_response);
        });
    }

    protected processGetOrganizations(response: Response): Promise<Organization[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Organization.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Organization[]>(<any>null);
    }

    /**
     * 获取部门数组
     * @param organizationId (optional) 
     * @return Success
     */
    getDepartmentArray(organizationId: number | undefined): Promise<DepartmentTreeNode[]> {
        let url_ = this.baseUrl + "/api/Departments/array?";
        if (organizationId === null)
            throw new Error("The parameter 'organizationId' cannot be null.");
        else if (organizationId !== undefined)
            url_ += "OrganizationId=" + encodeURIComponent("" + organizationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDepartmentArray(_response);
        });
    }

    protected processGetDepartmentArray(response: Response): Promise<DepartmentTreeNode[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DepartmentTreeNode.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DepartmentTreeNode[]>(<any>null);
    }

    /**
     * 获取部门树
     * @param organizationId (optional) 
     * @return Success
     */
    getDepartmentTree(organizationId: number | undefined): Promise<DepartmentTreeNode[]> {
        let url_ = this.baseUrl + "/api/Departments?";
        if (organizationId === null)
            throw new Error("The parameter 'organizationId' cannot be null.");
        else if (organizationId !== undefined)
            url_ += "OrganizationId=" + encodeURIComponent("" + organizationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDepartmentTree(_response);
        });
    }

    protected processGetDepartmentTree(response: Response): Promise<DepartmentTreeNode[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DepartmentTreeNode.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DepartmentTreeNode[]>(<any>null);
    }

    /**
     * 创建部门
     * @param body (optional) 
     * @return Success
     */
    createDepartment(body: CreateDepartmentDto | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Departments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateDepartment(_response);
        });
    }

    protected processCreateDepartment(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * 根据部门Id获取部门
     * @return Success
     */
    getDepartmentById(id: string): Promise<DepartmentViewModel> {
        let url_ = this.baseUrl + "/api/Departments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDepartmentById(_response);
        });
    }

    protected processGetDepartmentById(response: Response): Promise<DepartmentViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DepartmentViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DepartmentViewModel>(<any>null);
    }

    /**
     * 更新部门
     * @param body (optional) 
     * @return Success
     */
    updateDepartment(id: string, body: Department | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Departments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateDepartment(_response);
        });
    }

    protected processUpdateDepartment(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key] ? ModelStateEntry.fromJS(resultData400[key]) : new ModelStateEntry();
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * 删除部门
     * @return Success
     */
    deleteDepartment(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Departments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteDepartment(_response);
        });
    }

    protected processDeleteDepartment(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * 部门下的用户
     * @return Success
     */
    getUsersOfDepartmentId(id: string): Promise<UsersOfDepartmentDto[]> {
        let url_ = this.baseUrl + "/api/Departments/{id}/users";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUsersOfDepartmentId(_response);
        });
    }

    protected processGetUsersOfDepartmentId(response: Response): Promise<UsersOfDepartmentDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UsersOfDepartmentDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UsersOfDepartmentDto[]>(<any>null);
    }

    /**
     * 添加用户到部门
     * @param body (optional) 
     * @return Success
     */
    addUsersToDepartment(id: string, body: AddUserToDepartmentViewModel | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Departments/{id}/users";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddUsersToDepartment(_response);
        });
    }

    protected processAddUsersToDepartment(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key] ? ModelStateEntry.fromJS(resultData400[key]) : new ModelStateEntry();
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * 部门下的用户
     * @param name (optional) 
     * @return Success
     */
    getDepartmentUsersByDepartmentName(name: string | undefined): Promise<UsersOfDepartmentDto[]> {
        let url_ = this.baseUrl + "/api/Departments/ByName/users?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDepartmentUsersByDepartmentName(_response);
        });
    }

    protected processGetDepartmentUsersByDepartmentName(response: Response): Promise<UsersOfDepartmentDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UsersOfDepartmentDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UsersOfDepartmentDto[]>(<any>null);
    }

    /**
     * 从部门中移除用户
     * @return Success
     */
    removeUserFromDepartment(id: string, userId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Departments/{id}/users/{userId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveUserFromDepartment(_response);
        });
    }

    protected processRemoveUserFromDepartment(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key] ? ModelStateEntry.fromJS(resultData400[key]) : new ModelStateEntry();
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * 查询用户(带部门和职位信息)
     * @param skip (optional) 
     * @param take (optional) 
     * @param departmentName (optional) 
     * @param userName (optional) 
     * @param name (optional) 
     * @param job (optional) 
     * @param isLeader (optional) 
     * @return Success
     */
    queryUsersDepartments(skip: number | undefined, take: number | undefined, departmentName: string | undefined, userName: string | undefined, name: string | undefined, job: string | undefined, isLeader: boolean | undefined): Promise<QueryUsersDepartmentsItem[]> {
        let url_ = this.baseUrl + "/api/Departments/QueryUsersDepartments?";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&";
        if (departmentName === null)
            throw new Error("The parameter 'departmentName' cannot be null.");
        else if (departmentName !== undefined)
            url_ += "departmentName=" + encodeURIComponent("" + departmentName) + "&";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (job === null)
            throw new Error("The parameter 'job' cannot be null.");
        else if (job !== undefined)
            url_ += "job=" + encodeURIComponent("" + job) + "&";
        if (isLeader === null)
            throw new Error("The parameter 'isLeader' cannot be null.");
        else if (isLeader !== undefined)
            url_ += "isLeader=" + encodeURIComponent("" + isLeader) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processQueryUsersDepartments(_response);
        });
    }

    protected processQueryUsersDepartments(response: Response): Promise<QueryUsersDepartmentsItem[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(QueryUsersDepartmentsItem.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<QueryUsersDepartmentsItem[]>(<any>null);
    }

    /**
     * 更新用户在部门内的信息
     * @param body (optional) 
     * @return Success
     */
    updateUserInDepartment(departmentId: string, idInUserDepartments: number, body: UpdateUserOrderInDepartmentViewModel | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Departments/{departmentId}/users/{idInUserDepartments}";
        if (departmentId === undefined || departmentId === null)
            throw new Error("The parameter 'departmentId' must be defined.");
        url_ = url_.replace("{departmentId}", encodeURIComponent("" + departmentId));
        if (idInUserDepartments === undefined || idInUserDepartments === null)
            throw new Error("The parameter 'idInUserDepartments' must be defined.");
        url_ = url_.replace("{idInUserDepartments}", encodeURIComponent("" + idInUserDepartments));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateUserInDepartment(_response);
        });
    }

    protected processUpdateUserInDepartment(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class DeploymentClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param maxResults (optional) 
     * @return Success
     */
    get(maxResults: number | undefined): Promise<void> {
        let url_ = this.baseUrl + "/engine-rest/Deployment?";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    post(): Promise<void> {
        let url_ = this.baseUrl + "/engine-rest/Deployment/create";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * engine-rest/version
     * @return Success
     */
    getEngineVersion(): Promise<void> {
        let url_ = this.baseUrl + "/engine-rest/version";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEngineVersion(_response);
        });
    }

    protected processGetEngineVersion(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    put(id: number, body: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/engine-rest/Deployment/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPut(_response);
        });
    }

    protected processPut(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: number): Promise<void> {
        let url_ = this.baseUrl + "/engine-rest/Deployment/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class DiyUsersClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getDepartments(): Promise<string[]> {
        let url_ = this.baseUrl + "/api/DiyUsers/Departments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDepartments(_response);
        });
    }

    protected processGetDepartments(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(<any>null);
    }

    /**
     * @return Success
     */
    getUsersOfDepartment(departmentName: string): Promise<DiyUser[]> {
        let url_ = this.baseUrl + "/api/DiyUsers/Departments/{departmentName}";
        if (departmentName === undefined || departmentName === null)
            throw new Error("The parameter 'departmentName' must be defined.");
        url_ = url_.replace("{departmentName}", encodeURIComponent("" + departmentName));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUsersOfDepartment(_response);
        });
    }

    protected processGetUsersOfDepartment(response: Response): Promise<DiyUser[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DiyUser.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DiyUser[]>(<any>null);
    }

    /**
     * @return Success
     */
    getDepartmentGroups(): Promise<DepartmentGroup[]> {
        let url_ = this.baseUrl + "/api/DiyUsers/DepartmentGroups";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDepartmentGroups(_response);
        });
    }

    protected processGetDepartmentGroups(response: Response): Promise<DepartmentGroup[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DepartmentGroup.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DepartmentGroup[]>(<any>null);
    }
}

export class EmailsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    queryUnReadCount(body: UnReadCountViewModel | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/Emails/UnReadCount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processQueryUnReadCount(_response);
        });
    }

    protected processQueryUnReadCount(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    /**
     * 获取信箱列表
     * @param skip (optional) 
     * @param take (optional) 
     * @param isRead (optional) 
     * @return Success
     */
    getInbox(name: FolderName, skip: number | undefined, take: number | undefined, isRead: boolean | undefined): Promise<InboxListViewModel> {
        let url_ = this.baseUrl + "/api/Emails/folder/{name}?";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&";
        if (isRead === null)
            throw new Error("The parameter 'isRead' cannot be null.");
        else if (isRead !== undefined)
            url_ += "isRead=" + encodeURIComponent("" + isRead) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetInbox(_response);
        });
    }

    protected processGetInbox(response: Response): Promise<InboxListViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InboxListViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InboxListViewModel>(<any>null);
    }

    /**
     * 获取邮件详情
     * @return Success
     */
    getDetail(id: string): Promise<ListItemWithBody> {
        let url_ = this.baseUrl + "/api/Emails/inbox/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDetail(_response);
        });
    }

    protected processGetDetail(response: Response): Promise<ListItemWithBody> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListItemWithBody.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ListItemWithBody>(<any>null);
    }

    /**
     * 下载附件
     * @return Success
     */
    downloadAttachement(emailId: string, attarchmentId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Emails/download/{emailId}/{attarchmentId}";
        if (emailId === undefined || emailId === null)
            throw new Error("The parameter 'emailId' must be defined.");
        url_ = url_.replace("{emailId}", encodeURIComponent("" + emailId));
        if (attarchmentId === undefined || attarchmentId === null)
            throw new Error("The parameter 'attarchmentId' must be defined.");
        url_ = url_.replace("{attarchmentId}", encodeURIComponent("" + attarchmentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDownloadAttachement(_response);
        });
    }

    protected processDownloadAttachement(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class FlowActivityAuthorizationsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 获取流程
     * @param userName (optional) 
     * @return Success
     */
    getFlowActivityAuthorizations(userName: string | undefined): Promise<TaskDelegate[]> {
        let url_ = this.baseUrl + "/api/FlowActivityAuthorizations?";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFlowActivityAuthorizations(_response);
        });
    }

    protected processGetFlowActivityAuthorizations(response: Response): Promise<TaskDelegate[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TaskDelegate.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TaskDelegate[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createFlowActivityAuthorization(body: TaskDelegate | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/FlowActivityAuthorizations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateFlowActivityAuthorization(_response);
        });
    }

    protected processCreateFlowActivityAuthorization(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param userName (optional) 
     * @return Success
     */
    deleteFlowActivityAuthorizations(userName: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/FlowActivityAuthorizations?";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteFlowActivityAuthorizations(_response);
        });
    }

    protected processDeleteFlowActivityAuthorizations(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class FlowProcessInstancesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 通过业务编号获取待办任务
     * @param businessKey (optional) 
     * @return Success
     */
    getTodoTasksByBusinessKey(businessKey: string | undefined): Promise<TodoTaskByBusinessKey[]> {
        let url_ = this.baseUrl + "/api/FlowProcessInstances/TodoTasks?";
        if (businessKey === null)
            throw new Error("The parameter 'businessKey' cannot be null.");
        else if (businessKey !== undefined)
            url_ += "businessKey=" + encodeURIComponent("" + businessKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTodoTasksByBusinessKey(_response);
        });
    }

    protected processGetTodoTasksByBusinessKey(response: Response): Promise<TodoTaskByBusinessKey[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TodoTaskByBusinessKey.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TodoTaskByBusinessKey[]>(<any>null);
    }

    /**
     * 监控历史示例
     * @param year (optional) 
     * @param skip (optional) 
     * @param pageSize (optional) 
     * @param processDefKey (optional) 
     * @param titleKeyWord (optional) 
     * @param startDateTime (optional) 
     * @param endDateTime (optional) 
     * @param onlyShowFinishedFlows (optional) 只显示已经结束的流程
     * @param drafterUserName (optional) 创建者用户名
     * @param drafterName (optional) 
     * @return Success
     */
    getHistoryProcesseInstancesForOldOA(year: number | undefined, skip: number | undefined, pageSize: number | undefined, processDefKey: string | undefined, titleKeyWord: string | undefined, startDateTime: Date | undefined, endDateTime: Date | undefined, onlyShowFinishedFlows: boolean | undefined, drafterUserName: string | undefined, drafterName: string | undefined): Promise<HistoryProcesseInstancePaginationResult> {
        let url_ = this.baseUrl + "/api/FlowProcessInstances/history/old?";
        if (year === null)
            throw new Error("The parameter 'year' cannot be null.");
        else if (year !== undefined)
            url_ += "year=" + encodeURIComponent("" + year) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (processDefKey === null)
            throw new Error("The parameter 'processDefKey' cannot be null.");
        else if (processDefKey !== undefined)
            url_ += "processDefKey=" + encodeURIComponent("" + processDefKey) + "&";
        if (titleKeyWord === null)
            throw new Error("The parameter 'titleKeyWord' cannot be null.");
        else if (titleKeyWord !== undefined)
            url_ += "titleKeyWord=" + encodeURIComponent("" + titleKeyWord) + "&";
        if (startDateTime === null)
            throw new Error("The parameter 'startDateTime' cannot be null.");
        else if (startDateTime !== undefined)
            url_ += "startDateTime=" + encodeURIComponent(startDateTime ? "" + startDateTime.toISOString() : "") + "&";
        if (endDateTime === null)
            throw new Error("The parameter 'endDateTime' cannot be null.");
        else if (endDateTime !== undefined)
            url_ += "endDateTime=" + encodeURIComponent(endDateTime ? "" + endDateTime.toISOString() : "") + "&";
        if (onlyShowFinishedFlows === null)
            throw new Error("The parameter 'onlyShowFinishedFlows' cannot be null.");
        else if (onlyShowFinishedFlows !== undefined)
            url_ += "onlyShowFinishedFlows=" + encodeURIComponent("" + onlyShowFinishedFlows) + "&";
        if (drafterUserName === null)
            throw new Error("The parameter 'drafterUserName' cannot be null.");
        else if (drafterUserName !== undefined)
            url_ += "drafterUserName=" + encodeURIComponent("" + drafterUserName) + "&";
        if (drafterName === null)
            throw new Error("The parameter 'drafterName' cannot be null.");
        else if (drafterName !== undefined)
            url_ += "drafterName=" + encodeURIComponent("" + drafterName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetHistoryProcesseInstancesForOldOA(_response);
        });
    }

    protected processGetHistoryProcesseInstancesForOldOA(response: Response): Promise<HistoryProcesseInstancePaginationResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HistoryProcesseInstancePaginationResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<HistoryProcesseInstancePaginationResult>(<any>null);
    }

    /**
     * @param skip (optional) 
     * @param pageSize (optional) 
     * @param titleKeyWord (optional) 
     * @param startDateTime (optional) 
     * @param endDateTime (optional) 
     * @param onlyShowFinishedFlows (optional) 
     * @param drafterUserName (optional) 
     * @param drafterName (optional) 
     * @param archNoLike (optional) 
     * @param body (optional) 
     * @return Success
     */
    getHistoryProcesseInstances(skip: number | undefined, pageSize: number | undefined, titleKeyWord: string | undefined, startDateTime: Date | undefined, endDateTime: Date | undefined, onlyShowFinishedFlows: boolean | undefined, drafterUserName: string | undefined, drafterName: string | undefined, archNoLike: string | undefined, body: string[] | undefined): Promise<HistoryProcesseInstancePaginationResult> {
        let url_ = this.baseUrl + "/api/FlowProcessInstances/history?";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (titleKeyWord === null)
            throw new Error("The parameter 'titleKeyWord' cannot be null.");
        else if (titleKeyWord !== undefined)
            url_ += "titleKeyWord=" + encodeURIComponent("" + titleKeyWord) + "&";
        if (startDateTime === null)
            throw new Error("The parameter 'startDateTime' cannot be null.");
        else if (startDateTime !== undefined)
            url_ += "startDateTime=" + encodeURIComponent(startDateTime ? "" + startDateTime.toISOString() : "") + "&";
        if (endDateTime === null)
            throw new Error("The parameter 'endDateTime' cannot be null.");
        else if (endDateTime !== undefined)
            url_ += "endDateTime=" + encodeURIComponent(endDateTime ? "" + endDateTime.toISOString() : "") + "&";
        if (onlyShowFinishedFlows === null)
            throw new Error("The parameter 'onlyShowFinishedFlows' cannot be null.");
        else if (onlyShowFinishedFlows !== undefined)
            url_ += "onlyShowFinishedFlows=" + encodeURIComponent("" + onlyShowFinishedFlows) + "&";
        if (drafterUserName === null)
            throw new Error("The parameter 'drafterUserName' cannot be null.");
        else if (drafterUserName !== undefined)
            url_ += "drafterUserName=" + encodeURIComponent("" + drafterUserName) + "&";
        if (drafterName === null)
            throw new Error("The parameter 'drafterName' cannot be null.");
        else if (drafterName !== undefined)
            url_ += "drafterName=" + encodeURIComponent("" + drafterName) + "&";
        if (archNoLike === null)
            throw new Error("The parameter 'archNoLike' cannot be null.");
        else if (archNoLike !== undefined)
            url_ += "archNoLike=" + encodeURIComponent("" + archNoLike) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetHistoryProcesseInstances(_response);
        });
    }

    protected processGetHistoryProcesseInstances(response: Response): Promise<HistoryProcesseInstancePaginationResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HistoryProcesseInstancePaginationResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<HistoryProcesseInstancePaginationResult>(<any>null);
    }

    /**
     * 启动处理实例
     * @param body (optional) 
     * @return Success
     */
    startProcessDefinition(body: StartProcessDefinitionViewModel | undefined): Promise<StartProcessDefinitionResViewModel> {
        let url_ = this.baseUrl + "/api/FlowProcessInstances/start-process";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStartProcessDefinition(_response);
        });
    }

    protected processStartProcessDefinition(response: Response): Promise<StartProcessDefinitionResViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StartProcessDefinitionResViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StartProcessDefinitionResViewModel>(<any>null);
    }

    /**
     * 完成任务
     * @param body (optional) 
     * @return Success
     */
    completeTask(body: CompleteTaskViewModel | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/FlowProcessInstances/CompleteTask";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCompleteTask(_response);
        });
    }

    protected processCompleteTask(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * 完成任务
     * @param body (optional) 
     * @return Success
     */
    completeTaskForReadOnlyForm(body: CompleteTaskForReadOnlyForm | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/FlowProcessInstances/CompleteTaskForReadOnlyForm";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCompleteTaskForReadOnlyForm(_response);
        });
    }

    protected processCompleteTaskForReadOnlyForm(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * 删除处理实例
     * @return Success
     */
    deleteProcessInstancce(processInstanceId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/FlowProcessInstances/{ProcessInstanceId}";
        if (processInstanceId === undefined || processInstanceId === null)
            throw new Error("The parameter 'processInstanceId' must be defined.");
        url_ = url_.replace("{ProcessInstanceId}", encodeURIComponent("" + processInstanceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteProcessInstancce(_response);
        });
    }

    protected processDeleteProcessInstancce(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param userName (optional) 
     * @param businessKey (optional) 
     * @return Success
     */
    toGWJHFW(userName: string | undefined, businessKey: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/FlowProcessInstances/ToGWJHFW?";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&";
        if (businessKey === null)
            throw new Error("The parameter 'businessKey' cannot be null.");
        else if (businessKey !== undefined)
            url_ += "businessKey=" + encodeURIComponent("" + businessKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processToGWJHFW(_response);
        });
    }

    protected processToGWJHFW(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    reStartProcess(body: ReStartProcessViewModel | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/FlowProcessInstances";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReStartProcess(_response);
        });
    }

    protected processReStartProcess(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * 监控历史示例
     * @param skip (optional) 
     * @param pageSize (optional) 
     * @param titleKeyWord (optional) 
     * @param startDateTime (optional) 
     * @param endDateTime (optional) 
     * @param onlyShowFinishedFlows (optional) 只显示已经结束的流程
     * @param drafterUserName (optional) 创建者用户名
     * @param drafterName (optional) 
     * @param body (optional) 
     * @return Success
     */
    getHistoryProcesseInstancesWithStar(skip: number | undefined, pageSize: number | undefined, titleKeyWord: string | undefined, startDateTime: Date | undefined, endDateTime: Date | undefined, onlyShowFinishedFlows: boolean | undefined, drafterUserName: string | undefined, drafterName: string | undefined, body: string[] | undefined): Promise<HistoryProcesseInstancePaginationResult> {
        let url_ = this.baseUrl + "/api/FlowProcessInstances/history/star?";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (titleKeyWord === null)
            throw new Error("The parameter 'titleKeyWord' cannot be null.");
        else if (titleKeyWord !== undefined)
            url_ += "titleKeyWord=" + encodeURIComponent("" + titleKeyWord) + "&";
        if (startDateTime === null)
            throw new Error("The parameter 'startDateTime' cannot be null.");
        else if (startDateTime !== undefined)
            url_ += "startDateTime=" + encodeURIComponent(startDateTime ? "" + startDateTime.toISOString() : "") + "&";
        if (endDateTime === null)
            throw new Error("The parameter 'endDateTime' cannot be null.");
        else if (endDateTime !== undefined)
            url_ += "endDateTime=" + encodeURIComponent(endDateTime ? "" + endDateTime.toISOString() : "") + "&";
        if (onlyShowFinishedFlows === null)
            throw new Error("The parameter 'onlyShowFinishedFlows' cannot be null.");
        else if (onlyShowFinishedFlows !== undefined)
            url_ += "onlyShowFinishedFlows=" + encodeURIComponent("" + onlyShowFinishedFlows) + "&";
        if (drafterUserName === null)
            throw new Error("The parameter 'drafterUserName' cannot be null.");
        else if (drafterUserName !== undefined)
            url_ += "drafterUserName=" + encodeURIComponent("" + drafterUserName) + "&";
        if (drafterName === null)
            throw new Error("The parameter 'drafterName' cannot be null.");
        else if (drafterName !== undefined)
            url_ += "drafterName=" + encodeURIComponent("" + drafterName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetHistoryProcesseInstancesWithStar(_response);
        });
    }

    protected processGetHistoryProcesseInstancesWithStar(response: Response): Promise<HistoryProcesseInstancePaginationResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HistoryProcesseInstancePaginationResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<HistoryProcesseInstancePaginationResult>(<any>null);
    }
}

export class FormAttachmentsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 旧的OA能否编辑附件
     * @param taskId (optional) 
     * @return Success
     */
    oldOACanEditFile(taskId: string | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/FormAttachments/OldOACanEditFile?";
        if (taskId === null)
            throw new Error("The parameter 'taskId' cannot be null.");
        else if (taskId !== undefined)
            url_ += "taskId=" + encodeURIComponent("" + taskId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOldOACanEditFile(_response);
        });
    }

    protected processOldOACanEditFile(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * 获取附件列表
     * @param businessKey (optional) 
     * @param taskId (optional) 
     * @param isOldOAArchMonitor (optional) 
     * @param onlyShowNullTagAttachments (optional) 只显示空标记附件
     * @return Success
     */
    getFormAttachments(businessKey: string | undefined, taskId: string | undefined, isOldOAArchMonitor: boolean | undefined, onlyShowNullTagAttachments: boolean | undefined): Promise<FormAttachmentDto[]> {
        let url_ = this.baseUrl + "/api/FormAttachments?";
        if (businessKey === null)
            throw new Error("The parameter 'businessKey' cannot be null.");
        else if (businessKey !== undefined)
            url_ += "businessKey=" + encodeURIComponent("" + businessKey) + "&";
        if (taskId === null)
            throw new Error("The parameter 'taskId' cannot be null.");
        else if (taskId !== undefined)
            url_ += "taskId=" + encodeURIComponent("" + taskId) + "&";
        if (isOldOAArchMonitor === null)
            throw new Error("The parameter 'isOldOAArchMonitor' cannot be null.");
        else if (isOldOAArchMonitor !== undefined)
            url_ += "isOldOAArchMonitor=" + encodeURIComponent("" + isOldOAArchMonitor) + "&";
        if (onlyShowNullTagAttachments === null)
            throw new Error("The parameter 'onlyShowNullTagAttachments' cannot be null.");
        else if (onlyShowNullTagAttachments !== undefined)
            url_ += "onlyShowNullTagAttachments=" + encodeURIComponent("" + onlyShowNullTagAttachments) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFormAttachments(_response);
        });
    }

    protected processGetFormAttachments(response: Response): Promise<FormAttachmentDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FormAttachmentDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FormAttachmentDto[]>(<any>null);
    }

    /**
     * 上传附件
     * @param businessKey (optional) 
     * @param tag (optional) 自定义标记
     * @return Success
     */
    addArchAttachment(businessKey: string | undefined, tag: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/FormAttachments?";
        if (businessKey === null)
            throw new Error("The parameter 'businessKey' cannot be null.");
        else if (businessKey !== undefined)
            url_ += "businessKey=" + encodeURIComponent("" + businessKey) + "&";
        if (tag === null)
            throw new Error("The parameter 'tag' cannot be null.");
        else if (tag !== undefined)
            url_ += "tag=" + encodeURIComponent("" + tag) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddArchAttachment(_response);
        });
    }

    protected processAddArchAttachment(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * 获取附件上传下载地址
     * @param downloadUrl (optional) 
     * @return Success
     */
    getAttachmentNewestUploadAndDownloadUrl(downloadUrl: string | undefined): Promise<NewestUploadAndDownloadUrlViewModel> {
        let url_ = this.baseUrl + "/api/FormAttachments/downloadUrl?";
        if (downloadUrl === null)
            throw new Error("The parameter 'downloadUrl' cannot be null.");
        else if (downloadUrl !== undefined)
            url_ += "downloadUrl=" + encodeURIComponent("" + downloadUrl) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAttachmentNewestUploadAndDownloadUrl(_response);
        });
    }

    protected processGetAttachmentNewestUploadAndDownloadUrl(response: Response): Promise<NewestUploadAndDownloadUrlViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NewestUploadAndDownloadUrlViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NewestUploadAndDownloadUrlViewModel>(<any>null);
    }

    /**
     * 获取附件根据Id
     * @param id (optional) 
     * @return Success
     */
    getFormAttachmentById(id: string | undefined): Promise<FormAttachmentDto> {
        let url_ = this.baseUrl + "/api/FormAttachments/id?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFormAttachmentById(_response);
        });
    }

    protected processGetFormAttachmentById(response: Response): Promise<FormAttachmentDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FormAttachmentDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FormAttachmentDto>(<any>null);
    }

    /**
     * WPS修改附件后上传(新)
     * @param id (optional) 
     * @return Success
     */
    updateAttachmentByWps(id: string | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/FormAttachments/wpsex?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateAttachmentByWps(_response);
        });
    }

    protected processUpdateAttachmentByWps(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * WPS修改附件后上传
     * @param id (optional) 
     * @param rowVersion (optional) 
     * @param userName (optional) 
     * @param taskId (optional) 
     * @return Success
     */
    updateAttachment(id: string | undefined, rowVersion: string | undefined, userName: string | undefined, taskId: string | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/FormAttachments/wps?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (rowVersion === null)
            throw new Error("The parameter 'rowVersion' cannot be null.");
        else if (rowVersion !== undefined)
            url_ += "rowVersion=" + encodeURIComponent("" + rowVersion) + "&";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&";
        if (taskId === null)
            throw new Error("The parameter 'taskId' cannot be null.");
        else if (taskId !== undefined)
            url_ += "taskId=" + encodeURIComponent("" + taskId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateAttachment(_response);
        });
    }

    protected processUpdateAttachment(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key] ? ModelStateEntry.fromJS(resultData400[key]) : new ModelStateEntry();
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * 删除附件
     * @return Success
     */
    deleteArchAttachment(attachmentId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/FormAttachments/{attachmentId}";
        if (attachmentId === undefined || attachmentId === null)
            throw new Error("The parameter 'attachmentId' must be defined.");
        url_ = url_.replace("{attachmentId}", encodeURIComponent("" + attachmentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteArchAttachment(_response);
        });
    }

    protected processDeleteArchAttachment(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * 下载附件
     * @param showRevision (optional) 
     * @return Success
     */
    download(id: string, showRevision: boolean | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/FormAttachments/Download/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (showRevision === null)
            throw new Error("The parameter 'showRevision' cannot be null.");
        else if (showRevision !== undefined)
            url_ += "showRevision=" + encodeURIComponent("" + showRevision) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDownload(_response);
        });
    }

    protected processDownload(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param userName (optional) 
     * @param proDefKey (optional) 
     * @param businessKey (optional) 
     * @param onlyShowNullTagAttachments (optional) 
     * @return Success
     */
    downloadAllAttachments(userName: string | undefined, proDefKey: string | undefined, businessKey: string | undefined, onlyShowNullTagAttachments: boolean | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/FormAttachments/DownloadAllAttachments?";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&";
        if (proDefKey === null)
            throw new Error("The parameter 'proDefKey' cannot be null.");
        else if (proDefKey !== undefined)
            url_ += "proDefKey=" + encodeURIComponent("" + proDefKey) + "&";
        if (businessKey === null)
            throw new Error("The parameter 'businessKey' cannot be null.");
        else if (businessKey !== undefined)
            url_ += "businessKey=" + encodeURIComponent("" + businessKey) + "&";
        if (onlyShowNullTagAttachments === null)
            throw new Error("The parameter 'onlyShowNullTagAttachments' cannot be null.");
        else if (onlyShowNullTagAttachments !== undefined)
            url_ += "onlyShowNullTagAttachments=" + encodeURIComponent("" + onlyShowNullTagAttachments) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDownloadAllAttachments(_response);
        });
    }

    protected processDownloadAllAttachments(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * 套红头
     * @param body (optional) 
     * @return Success
     */
    takeRedHeat(body: TaskRedHatViewModel | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/FormAttachments/TakeRedHeat";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTakeRedHeat(_response);
        });
    }

    protected processTakeRedHeat(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * 更新附件顺序
     * @param order (optional) 
     * @return Success
     */
    updateAttachmentOrder(id: string, order: number | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/FormAttachments/order/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (order === null)
            throw new Error("The parameter 'order' cannot be null.");
        else if (order !== undefined)
            url_ += "order=" + encodeURIComponent("" + order) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateAttachmentOrder(_response);
        });
    }

    protected processUpdateAttachmentOrder(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class FormsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param businessKey (optional) 
     * @return Success
     */
    get(businessKey: string | undefined): Promise<OpinionGroup[]> {
        let url_ = this.baseUrl + "/api/Forms/opinions?";
        if (businessKey === null)
            throw new Error("The parameter 'businessKey' cannot be null.");
        else if (businessKey !== undefined)
            url_ += "businessKey=" + encodeURIComponent("" + businessKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<OpinionGroup[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OpinionGroup.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OpinionGroup[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param body (optional) 
     * @return Success
     */
    updateOpinion(id: string | undefined, body: UpdateFormOpinionViewModel | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Forms/opinions?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateOpinion(_response);
        });
    }

    protected processUpdateOpinion(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param body (optional) 
     * @return Success
     */
    deleteOpinion(id: string | undefined, body: UpdateFormOpinionViewModel | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Forms/opinions?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteOpinion(_response);
        });
    }

    protected processDeleteOpinion(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class HistoryFlowsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param skip (optional) 
     * @param take (optional) 
     * @param businessKey (optional) 
     * @return Success
     */
    getList(skip: number | undefined, take: number | undefined, businessKey: string | undefined): Promise<HistoryFlowViewModelTCollectionWithPagination> {
        let url_ = this.baseUrl + "/api/HistoryFlows?";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&";
        if (businessKey === null)
            throw new Error("The parameter 'businessKey' cannot be null.");
        else if (businessKey !== undefined)
            url_ += "businessKey=" + encodeURIComponent("" + businessKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: Response): Promise<HistoryFlowViewModelTCollectionWithPagination> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HistoryFlowViewModelTCollectionWithPagination.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<HistoryFlowViewModelTCollectionWithPagination>(<any>null);
    }

    /**
     * 更新状态
     * @param id (optional) 
     * @param state (optional) 
     * @return Success
     */
    updateState(id: string | undefined, state: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/HistoryFlows/updateState?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (state === null)
            throw new Error("The parameter 'state' cannot be null.");
        else if (state !== undefined)
            url_ += "state=" + encodeURIComponent("" + state) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateState(_response);
        });
    }

    protected processUpdateState(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class KeyValueStorageClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(key: string): Promise<KeyValueViewModel> {
        let url_ = this.baseUrl + "/api/KeyValueStorage/{key}";
        if (key === undefined || key === null)
            throw new Error("The parameter 'key' must be defined.");
        url_ = url_.replace("{key}", encodeURIComponent("" + key));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<KeyValueViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = KeyValueViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<KeyValueViewModel>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    set(key: string, body: any | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/KeyValueStorage/{key}";
        if (key === undefined || key === null)
            throw new Error("The parameter 'key' must be defined.");
        url_ = url_.replace("{key}", encodeURIComponent("" + key));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSet(_response);
        });
    }

    protected processSet(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    delete(key: string): Promise<void> {
        let url_ = this.baseUrl + "/api/KeyValueStorage/{key}";
        if (key === undefined || key === null)
            throw new Error("The parameter 'key' must be defined.");
        url_ = url_.replace("{key}", encodeURIComponent("" + key));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class LeaderActivitiesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param startDateTime (optional) 
     * @param endDateTime (optional) 
     * @param userDisplayNameLike (optional) 
     * @return Success
     */
    getList(startDateTime: Date | undefined, endDateTime: Date | undefined, userDisplayNameLike: string | undefined): Promise<DateGroupTCollection> {
        let url_ = this.baseUrl + "/api/LeaderActivities?";
        if (startDateTime === null)
            throw new Error("The parameter 'startDateTime' cannot be null.");
        else if (startDateTime !== undefined)
            url_ += "startDateTime=" + encodeURIComponent(startDateTime ? "" + startDateTime.toISOString() : "") + "&";
        if (endDateTime === null)
            throw new Error("The parameter 'endDateTime' cannot be null.");
        else if (endDateTime !== undefined)
            url_ += "endDateTime=" + encodeURIComponent(endDateTime ? "" + endDateTime.toISOString() : "") + "&";
        if (userDisplayNameLike === null)
            throw new Error("The parameter 'userDisplayNameLike' cannot be null.");
        else if (userDisplayNameLike !== undefined)
            url_ += "userDisplayNameLike=" + encodeURIComponent("" + userDisplayNameLike) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: Response): Promise<DateGroupTCollection> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DateGroupTCollection.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DateGroupTCollection>(<any>null);
    }
}

export class LogsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAll(): Promise<string[]> {
        let url_ = this.baseUrl + "/api/Logs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(<any>null);
    }

    /**
     * @return Success
     */
    get(id: number): Promise<string> {
        let url_ = this.baseUrl + "/api/Logs/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    put(id: number, body: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Logs/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPut(_response);
        });
    }

    protected processPut(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/Logs/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    post(body: MobileLoginInfoViewModel | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Logs/MobileLoginInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class MessagesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 发送短信
     * @param body (optional) 
     * @return Success
     */
    sendShortMessage(body: SendShortMessageViewModel | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Messages/SendShortMessage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSendShortMessage(_response);
        });
    }

    protected processSendShortMessage(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 202) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class OpinionTypesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 获取意见类型
     * @param prodefKey (optional) 
     * @return Success
     */
    getOpinionTypes(prodefKey: string | undefined): Promise<OpinionTypeViewModel[]> {
        let url_ = this.baseUrl + "/api/OpinionTypes?";
        if (prodefKey === null)
            throw new Error("The parameter 'prodefKey' cannot be null.");
        else if (prodefKey !== undefined)
            url_ += "prodefKey=" + encodeURIComponent("" + prodefKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetOpinionTypes(_response);
        });
    }

    protected processGetOpinionTypes(response: Response): Promise<OpinionTypeViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OpinionTypeViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OpinionTypeViewModel[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOpinionType(body: OpinionTypeViewModel | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/OpinionTypes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateOpinionType(_response);
        });
    }

    protected processCreateOpinionType(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key] ? ModelStateEntry.fromJS(resultData400[key]) : new ModelStateEntry();
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @return Success
     */
    getOpinionTypeById(id: number): Promise<OpinionTypeViewModel> {
        let url_ = this.baseUrl + "/api/OpinionTypes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetOpinionTypeById(_response);
        });
    }

    protected processGetOpinionTypeById(response: Response): Promise<OpinionTypeViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OpinionTypeViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OpinionTypeViewModel>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateOpnionType(id: number, body: OpinionTypeViewModel | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/OpinionTypes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateOpnionType(_response);
        });
    }

    protected processUpdateOpnionType(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key] ? ModelStateEntry.fromJS(resultData400[key]) : new ModelStateEntry();
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @return Success
     */
    delete(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/OpinionTypes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key] ? ModelStateEntry.fromJS(resultData400[key]) : new ModelStateEntry();
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);
            });
        }
    }
}

export class OrganizationsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(): Promise<Organization[]> {
        let url_ = this.baseUrl + "/api/Organizations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<Organization[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Organization.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Organization[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    post(body: Organization | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Organizations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * 根据id获取组织
     * @return Success
     */
    getById(id: number): Promise<Organization> {
        let url_ = this.baseUrl + "/api/Organizations/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: Response): Promise<Organization> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Organization.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Organization>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    put(id: number, body: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Organizations/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPut(_response);
        });
    }

    protected processPut(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/Organizations/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class OtpauthClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getotpauthImageForBase64(): Promise<string> {
        let url_ = this.baseUrl + "/api/Otpauth/otpauth-image";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetotpauthImageForBase64(_response);
        });
    }

    protected processGetotpauthImageForBase64(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * @return Success
     */
    get(id: number): Promise<string> {
        let url_ = this.baseUrl + "/api/Otpauth/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    put(id: number, body: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Otpauth/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPut(_response);
        });
    }

    protected processPut(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/Otpauth/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    post(body: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Otpauth";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class PermissonsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 获取所有权限
     * @param skip (optional) 
     * @param take (optional) 
     * @param search (optional) 
     * @return Success
     */
    getPermissons(skip: number | undefined, take: number | undefined, search: string | undefined): Promise<PermissonPaginationResult> {
        let url_ = this.baseUrl + "/api/Permissons?";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPermissons(_response);
        });
    }

    protected processGetPermissons(response: Response): Promise<PermissonPaginationResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissonPaginationResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PermissonPaginationResult>(<any>null);
    }

    /**
     * 创建或者更新权限
     * @param body (optional) 
     * @return Success
     */
    createOrUpdatePermisson(body: Permisson | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Permissons";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateOrUpdatePermisson(_response);
        });
    }

    protected processCreateOrUpdatePermisson(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key] ? ModelStateEntry.fromJS(resultData400[key]) : new ModelStateEntry();
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * 根据id获取权限
     * @return Success
     */
    getPermissonById(id: string): Promise<Permisson> {
        let url_ = this.baseUrl + "/api/Permissons/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPermissonById(_response);
        });
    }

    protected processGetPermissonById(response: Response): Promise<Permisson> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Permisson.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Permisson>(<any>null);
    }

    /**
     * 删除权限
     * @return Success
     */
    deletePermisson(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Permissons/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeletePermisson(_response);
        });
    }

    protected processDeletePermisson(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key] ? ModelStateEntry.fromJS(resultData400[key]) : new ModelStateEntry();
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);
            });
        }
    }
}

export class ProcessDefsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 获取处理定义列表
     * @param includeParseUserTasks (optional) 
     * @return Success
     */
    getProcessDefs(includeParseUserTasks: boolean | undefined): Promise<ProcessDefViewModel[]> {
        let url_ = this.baseUrl + "/api/ProcessDefs?";
        if (includeParseUserTasks === null)
            throw new Error("The parameter 'includeParseUserTasks' cannot be null.");
        else if (includeParseUserTasks !== undefined)
            url_ += "includeParseUserTasks=" + encodeURIComponent("" + includeParseUserTasks) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProcessDefs(_response);
        });
    }

    protected processGetProcessDefs(response: Response): Promise<ProcessDefViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProcessDefViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProcessDefViewModel[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    post(body: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/ProcessDefs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * 获取处理定义xml列表
     * @return Success
     */
    getProcessDefsWithXml(): Promise<string[]> {
        let url_ = this.baseUrl + "/api/ProcessDefs/xml";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProcessDefsWithXml(_response);
        });
    }

    protected processGetProcessDefsWithXml(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(<any>null);
    }

    /**
     * 通过key获取处理定义
     * @return Success
     */
    getProcessDefByKey(key: string): Promise<ProcessDefViewModel> {
        let url_ = this.baseUrl + "/api/ProcessDefs/{key}";
        if (key === undefined || key === null)
            throw new Error("The parameter 'key' must be defined.");
        url_ = url_.replace("{key}", encodeURIComponent("" + key));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProcessDefByKey(_response);
        });
    }

    protected processGetProcessDefByKey(response: Response): Promise<ProcessDefViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProcessDefViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProcessDefViewModel>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    put(id: number, body: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/ProcessDefs/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPut(_response);
        });
    }

    protected processPut(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/ProcessDefs/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    getActivityOutgoingUsersConfigs(): Promise<OutgoingConfigItem[]> {
        let url_ = this.baseUrl + "/api/ProcessDefs/ActivityOutgoingUsersConfigs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetActivityOutgoingUsersConfigs(_response);
        });
    }

    protected processGetActivityOutgoingUsersConfigs(response: Response): Promise<OutgoingConfigItem[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OutgoingConfigItem.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OutgoingConfigItem[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createAssgineeUserGroup(body: AssigneeUserGroup | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/ProcessDefs/AssgineeUserGroup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateAssgineeUserGroup(_response);
        });
    }

    protected processCreateAssgineeUserGroup(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteAssgineeUserGroup(id: number | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/ProcessDefs/AssgineeUserGroup?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteAssgineeUserGroup(_response);
        });
    }

    protected processDeleteAssgineeUserGroup(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    getUserTasks(): Promise<UserTaskItem[]> {
        let url_ = this.baseUrl + "/api/ProcessDefs/userTasks";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserTasks(_response);
        });
    }

    protected processGetUserTasks(response: Response): Promise<UserTaskItem[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserTaskItem.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserTaskItem[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUserTask(body: UpdateUserTaskViewModel | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/ProcessDefs/updateUserTask";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateUserTask(_response);
        });
    }

    protected processUpdateUserTask(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class ProcessDefsExClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getProcessDefConfig(): Promise<ProcessDefConfig> {
        let url_ = this.baseUrl + "/api/ProcessDefsEx/ProcessDefConfig";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProcessDefConfig(_response);
        });
    }

    protected processGetProcessDefConfig(response: Response): Promise<ProcessDefConfig> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProcessDefConfig.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProcessDefConfig>(<any>null);
    }
}

export class ProcessInstancesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 通过业务编号获取待办任务
     * @param businessKey (optional) 
     * @return Success
     */
    getTodoTasksByBusinessKey(businessKey: string | undefined): Promise<TodoTaskByBusinessKey[]> {
        let url_ = this.baseUrl + "/api/ProcessInstances/TodoTasks?";
        if (businessKey === null)
            throw new Error("The parameter 'businessKey' cannot be null.");
        else if (businessKey !== undefined)
            url_ += "businessKey=" + encodeURIComponent("" + businessKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTodoTasksByBusinessKey(_response);
        });
    }

    protected processGetTodoTasksByBusinessKey(response: Response): Promise<TodoTaskByBusinessKey[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TodoTaskByBusinessKey.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TodoTaskByBusinessKey[]>(<any>null);
    }

    /**
     * 监控历史示例
     * @param year (optional) 
     * @param skip (optional) 
     * @param pageSize (optional) 
     * @param processDefKey (optional) 
     * @param titleKeyWord (optional) 
     * @param startDateTime (optional) 
     * @param endDateTime (optional) 
     * @param onlyShowFinishedFlows (optional) 只显示已经结束的流程
     * @param drafterUserName (optional) 创建者用户名
     * @param drafterName (optional) 
     * @return Success
     */
    getHistoryProcesseInstancesForOldOA(year: number | undefined, skip: number | undefined, pageSize: number | undefined, processDefKey: string | undefined, titleKeyWord: string | undefined, startDateTime: Date | undefined, endDateTime: Date | undefined, onlyShowFinishedFlows: boolean | undefined, drafterUserName: string | undefined, drafterName: string | undefined): Promise<HistoryProcesseInstancePaginationResult> {
        let url_ = this.baseUrl + "/api/ProcessInstances/history/old?";
        if (year === null)
            throw new Error("The parameter 'year' cannot be null.");
        else if (year !== undefined)
            url_ += "year=" + encodeURIComponent("" + year) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (processDefKey === null)
            throw new Error("The parameter 'processDefKey' cannot be null.");
        else if (processDefKey !== undefined)
            url_ += "processDefKey=" + encodeURIComponent("" + processDefKey) + "&";
        if (titleKeyWord === null)
            throw new Error("The parameter 'titleKeyWord' cannot be null.");
        else if (titleKeyWord !== undefined)
            url_ += "titleKeyWord=" + encodeURIComponent("" + titleKeyWord) + "&";
        if (startDateTime === null)
            throw new Error("The parameter 'startDateTime' cannot be null.");
        else if (startDateTime !== undefined)
            url_ += "startDateTime=" + encodeURIComponent(startDateTime ? "" + startDateTime.toISOString() : "") + "&";
        if (endDateTime === null)
            throw new Error("The parameter 'endDateTime' cannot be null.");
        else if (endDateTime !== undefined)
            url_ += "endDateTime=" + encodeURIComponent(endDateTime ? "" + endDateTime.toISOString() : "") + "&";
        if (onlyShowFinishedFlows === null)
            throw new Error("The parameter 'onlyShowFinishedFlows' cannot be null.");
        else if (onlyShowFinishedFlows !== undefined)
            url_ += "onlyShowFinishedFlows=" + encodeURIComponent("" + onlyShowFinishedFlows) + "&";
        if (drafterUserName === null)
            throw new Error("The parameter 'drafterUserName' cannot be null.");
        else if (drafterUserName !== undefined)
            url_ += "drafterUserName=" + encodeURIComponent("" + drafterUserName) + "&";
        if (drafterName === null)
            throw new Error("The parameter 'drafterName' cannot be null.");
        else if (drafterName !== undefined)
            url_ += "drafterName=" + encodeURIComponent("" + drafterName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetHistoryProcesseInstancesForOldOA(_response);
        });
    }

    protected processGetHistoryProcesseInstancesForOldOA(response: Response): Promise<HistoryProcesseInstancePaginationResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HistoryProcesseInstancePaginationResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<HistoryProcesseInstancePaginationResult>(<any>null);
    }

    /**
     * 监控历史示例
     * @param skip (optional) 
     * @param pageSize (optional) 
     * @param titleKeyWord (optional) 
     * @param startDateTime (optional) 
     * @param endDateTime (optional) 
     * @param onlyShowFinishedFlows (optional) 只显示已经结束的流程
     * @param drafterUserName (optional) 创建者用户名
     * @param drafterName (optional) 
     * @param body (optional) 
     * @return Success
     */
    getHistoryProcesseInstances(skip: number | undefined, pageSize: number | undefined, titleKeyWord: string | undefined, startDateTime: Date | undefined, endDateTime: Date | undefined, onlyShowFinishedFlows: boolean | undefined, drafterUserName: string | undefined, drafterName: string | undefined, body: string[] | undefined): Promise<HistoryProcesseInstancePaginationResult> {
        let url_ = this.baseUrl + "/api/ProcessInstances/history?";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (titleKeyWord === null)
            throw new Error("The parameter 'titleKeyWord' cannot be null.");
        else if (titleKeyWord !== undefined)
            url_ += "titleKeyWord=" + encodeURIComponent("" + titleKeyWord) + "&";
        if (startDateTime === null)
            throw new Error("The parameter 'startDateTime' cannot be null.");
        else if (startDateTime !== undefined)
            url_ += "startDateTime=" + encodeURIComponent(startDateTime ? "" + startDateTime.toISOString() : "") + "&";
        if (endDateTime === null)
            throw new Error("The parameter 'endDateTime' cannot be null.");
        else if (endDateTime !== undefined)
            url_ += "endDateTime=" + encodeURIComponent(endDateTime ? "" + endDateTime.toISOString() : "") + "&";
        if (onlyShowFinishedFlows === null)
            throw new Error("The parameter 'onlyShowFinishedFlows' cannot be null.");
        else if (onlyShowFinishedFlows !== undefined)
            url_ += "onlyShowFinishedFlows=" + encodeURIComponent("" + onlyShowFinishedFlows) + "&";
        if (drafterUserName === null)
            throw new Error("The parameter 'drafterUserName' cannot be null.");
        else if (drafterUserName !== undefined)
            url_ += "drafterUserName=" + encodeURIComponent("" + drafterUserName) + "&";
        if (drafterName === null)
            throw new Error("The parameter 'drafterName' cannot be null.");
        else if (drafterName !== undefined)
            url_ += "drafterName=" + encodeURIComponent("" + drafterName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetHistoryProcesseInstances(_response);
        });
    }

    protected processGetHistoryProcesseInstances(response: Response): Promise<HistoryProcesseInstancePaginationResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HistoryProcesseInstancePaginationResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<HistoryProcesseInstancePaginationResult>(<any>null);
    }

    /**
     * 启动处理实例
     * @param body (optional) 
     * @return Success
     */
    startProcessDefinition(body: StartProcessDefinitionViewModel | undefined): Promise<StartProcessDefinitionResViewModel> {
        let url_ = this.baseUrl + "/api/ProcessInstances";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStartProcessDefinition(_response);
        });
    }

    protected processStartProcessDefinition(response: Response): Promise<StartProcessDefinitionResViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StartProcessDefinitionResViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StartProcessDefinitionResViewModel>(<any>null);
    }

    /**
     * 完成任务
     * @param body (optional) 
     * @return Success
     */
    completeTask(body: CompleteTaskViewModel | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/ProcessInstances/CompleteTask";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCompleteTask(_response);
        });
    }

    protected processCompleteTask(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * 完成任务
     * @param body (optional) 
     * @return Success
     */
    completeTaskForReadOnlyForm(body: CompleteTaskForReadOnlyForm | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/ProcessInstances/CompleteTaskForReadOnlyForm";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCompleteTaskForReadOnlyForm(_response);
        });
    }

    protected processCompleteTaskForReadOnlyForm(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * 删除处理实例
     * @return Success
     */
    deleteProcessInstancce(processInstanceId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/ProcessInstances/{ProcessInstanceId}";
        if (processInstanceId === undefined || processInstanceId === null)
            throw new Error("The parameter 'processInstanceId' must be defined.");
        url_ = url_.replace("{ProcessInstanceId}", encodeURIComponent("" + processInstanceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteProcessInstancce(_response);
        });
    }

    protected processDeleteProcessInstancce(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param userName (optional) 
     * @param businessKey (optional) 
     * @return Success
     */
    toGWJHFW(userName: string | undefined, businessKey: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/ProcessInstances/ToGWJHFW?";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&";
        if (businessKey === null)
            throw new Error("The parameter 'businessKey' cannot be null.");
        else if (businessKey !== undefined)
            url_ += "businessKey=" + encodeURIComponent("" + businessKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processToGWJHFW(_response);
        });
    }

    protected processToGWJHFW(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class QueryTasksClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 待办列表
     * @param skip (optional) 
     * @param pageSize (optional) 
     * @param isJustCreated (optional) 
     * @param proDefKey (optional) 
     * @param titleKeyWord (optional) 
     * @return Success
     */
    getTodoTasks(skip: number | undefined, pageSize: number | undefined, isJustCreated: boolean | undefined, proDefKey: string | undefined, titleKeyWord: string | undefined): Promise<TodoTaskViewModelPaginationResult> {
        let url_ = this.baseUrl + "/api/QueryTasks/todo?";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (isJustCreated === null)
            throw new Error("The parameter 'isJustCreated' cannot be null.");
        else if (isJustCreated !== undefined)
            url_ += "isJustCreated=" + encodeURIComponent("" + isJustCreated) + "&";
        if (proDefKey === null)
            throw new Error("The parameter 'proDefKey' cannot be null.");
        else if (proDefKey !== undefined)
            url_ += "proDefKey=" + encodeURIComponent("" + proDefKey) + "&";
        if (titleKeyWord === null)
            throw new Error("The parameter 'titleKeyWord' cannot be null.");
        else if (titleKeyWord !== undefined)
            url_ += "titleKeyWord=" + encodeURIComponent("" + titleKeyWord) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTodoTasks(_response);
        });
    }

    protected processGetTodoTasks(response: Response): Promise<TodoTaskViewModelPaginationResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TodoTaskViewModelPaginationResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TodoTaskViewModelPaginationResult>(<any>null);
    }

    /**
     * 获取未办数量
     * @param isJustCreated (optional) 
     * @param body (optional) 
     * @return Success
     */
    getTodoCount(isJustCreated: boolean | undefined, body: string[] | undefined): Promise<number[]> {
        let url_ = this.baseUrl + "/api/QueryTasks/todo/count?";
        if (isJustCreated === null)
            throw new Error("The parameter 'isJustCreated' cannot be null.");
        else if (isJustCreated !== undefined)
            url_ += "isJustCreated=" + encodeURIComponent("" + isJustCreated) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTodoCount(_response);
        });
    }

    protected processGetTodoCount(response: Response): Promise<number[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number[]>(<any>null);
    }

    /**
     * 获取已办
     * @param skip (optional) 
     * @param take (optional) 
     * @param flow (optional) 
     * @return Success
     */
    getDoneTasks(skip: number | undefined, take: number | undefined, flow: string | undefined): Promise<TodoTaskViewModelPaginationResult> {
        let url_ = this.baseUrl + "/api/QueryTasks/done?";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&";
        if (flow === null)
            throw new Error("The parameter 'flow' cannot be null.");
        else if (flow !== undefined)
            url_ += "flow=" + encodeURIComponent("" + flow) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDoneTasks(_response);
        });
    }

    protected processGetDoneTasks(response: Response): Promise<TodoTaskViewModelPaginationResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TodoTaskViewModelPaginationResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TodoTaskViewModelPaginationResult>(<any>null);
    }

    /**
     * 获取意见
     * @param processDefKey (optional) 
     * @return Success
     */
    getFormOpinionsByBusinessKey(processDefKey: string | undefined, businessKey: string): Promise<OpinionViewModel[]> {
        let url_ = this.baseUrl + "/api/QueryTasks/opinions/{businessKey}?";
        if (businessKey === undefined || businessKey === null)
            throw new Error("The parameter 'businessKey' must be defined.");
        url_ = url_.replace("{businessKey}", encodeURIComponent("" + businessKey));
        if (processDefKey === null)
            throw new Error("The parameter 'processDefKey' cannot be null.");
        else if (processDefKey !== undefined)
            url_ += "processDefKey=" + encodeURIComponent("" + processDefKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFormOpinionsByBusinessKey(_response);
        });
    }

    protected processGetFormOpinionsByBusinessKey(response: Response): Promise<OpinionViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OpinionViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OpinionViewModel[]>(<any>null);
    }

    /**
     * 撤回
     * @return Success
     */
    cancelAllForActivity(taskId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/QueryTasks/cancel/{taskId}";
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCancelAllForActivity(_response);
        });
    }

    protected processCancelAllForActivity(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    getDisposes(taskId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/QueryTasks/{taskId}/disposes";
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDisposes(_response);
        });
    }

    protected processGetDisposes(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * 获取表单
     * @param mode (optional) 
     * @param taskId (optional) 
     * @param businessKey (optional) 
     * @return Success
     */
    getTaskDetail(mode: GetFormDetailMode | undefined, taskId: string | undefined, businessKey: string | undefined): Promise<FormDetailViewModel> {
        let url_ = this.baseUrl + "/api/QueryTasks/detail?";
        if (mode === null)
            throw new Error("The parameter 'mode' cannot be null.");
        else if (mode !== undefined)
            url_ += "mode=" + encodeURIComponent("" + mode) + "&";
        if (taskId === null)
            throw new Error("The parameter 'taskId' cannot be null.");
        else if (taskId !== undefined)
            url_ += "taskId=" + encodeURIComponent("" + taskId) + "&";
        if (businessKey === null)
            throw new Error("The parameter 'businessKey' cannot be null.");
        else if (businessKey !== undefined)
            url_ += "businessKey=" + encodeURIComponent("" + businessKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTaskDetail(_response);
        });
    }

    protected processGetTaskDetail(response: Response): Promise<FormDetailViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FormDetailViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FormDetailViewModel>(<any>null);
    }

    /**
     * 获取办文过程
     * @return Success
     */
    getDealProcesses(businessKey: string): Promise<DealProcesseViewModel[]> {
        let url_ = this.baseUrl + "/api/QueryTasks/DealProcesses/{businessKey}";
        if (businessKey === undefined || businessKey === null)
            throw new Error("The parameter 'businessKey' must be defined.");
        url_ = url_.replace("{businessKey}", encodeURIComponent("" + businessKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDealProcesses(_response);
        });
    }

    protected processGetDealProcesses(response: Response): Promise<DealProcesseViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DealProcesseViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DealProcesseViewModel[]>(<any>null);
    }

    /**
     * 获取待办办列表数量
     * @param userName (optional) 
     * @param isJustCreated (optional) 
     * @param title (optional) 
     * @param archType (optional) 公文类型 办件、阅件
     * @param body (optional) 
     * @return Success
     */
    queryTodoTaskListCount(userName: string | undefined, isJustCreated: boolean | undefined, title: string | undefined, archType: string | undefined, body: string[] | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/QueryTasks/TodoList/count?";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&";
        if (isJustCreated === null)
            throw new Error("The parameter 'isJustCreated' cannot be null.");
        else if (isJustCreated !== undefined)
            url_ += "isJustCreated=" + encodeURIComponent("" + isJustCreated) + "&";
        if (title === null)
            throw new Error("The parameter 'title' cannot be null.");
        else if (title !== undefined)
            url_ += "title=" + encodeURIComponent("" + title) + "&";
        if (archType === null)
            throw new Error("The parameter 'archType' cannot be null.");
        else if (archType !== undefined)
            url_ += "archType=" + encodeURIComponent("" + archType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processQueryTodoTaskListCount(_response);
        });
    }

    protected processQueryTodoTaskListCount(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    /**
     * 获取待办列表
     * @param userName (optional) 
     * @param skip (optional) 
     * @param take (optional) 
     * @param isJustCreated (optional) 
     * @param title (optional) 
     * @param archType (optional) 公文类型 办件、阅件
     * @param body (optional) 
     * @return Success
     */
    queryTodoTaskList(userName: string | undefined, skip: number | undefined, take: number | undefined, isJustCreated: boolean | undefined, title: string | undefined, archType: string | undefined, body: string[] | undefined): Promise<MobileTaskListPaginationResult> {
        let url_ = this.baseUrl + "/api/QueryTasks/TodoList?";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&";
        if (isJustCreated === null)
            throw new Error("The parameter 'isJustCreated' cannot be null.");
        else if (isJustCreated !== undefined)
            url_ += "isJustCreated=" + encodeURIComponent("" + isJustCreated) + "&";
        if (title === null)
            throw new Error("The parameter 'title' cannot be null.");
        else if (title !== undefined)
            url_ += "title=" + encodeURIComponent("" + title) + "&";
        if (archType === null)
            throw new Error("The parameter 'archType' cannot be null.");
        else if (archType !== undefined)
            url_ += "archType=" + encodeURIComponent("" + archType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processQueryTodoTaskList(_response);
        });
    }

    protected processQueryTodoTaskList(response: Response): Promise<MobileTaskListPaginationResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MobileTaskListPaginationResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MobileTaskListPaginationResult>(<any>null);
    }

    /**
     * 获取已办列表
     * @param userName (optional) 
     * @param skip (optional) 
     * @param take (optional) 
     * @param search (optional) 
     * @param body (optional) 
     * @return Success
     */
    queryDoneTaskList(userName: string | undefined, skip: number | undefined, take: number | undefined, search: string | undefined, body: string[] | undefined): Promise<MobileTaskListPaginationResult> {
        let url_ = this.baseUrl + "/api/QueryTasks/DoneList?";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processQueryDoneTaskList(_response);
        });
    }

    protected processQueryDoneTaskList(response: Response): Promise<MobileTaskListPaginationResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MobileTaskListPaginationResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MobileTaskListPaginationResult>(<any>null);
    }

    /**
     * 暂存
     * @param body (optional) 
     * @return Success
     */
    tempSaveTask(taskId: string, body: TempSaveTaskViewModel | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/QueryTasks/{TaskId}/TempSave";
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{TaskId}", encodeURIComponent("" + taskId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTempSaveTask(_response);
        });
    }

    protected processTempSaveTask(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param taskId (optional) 
     * @return Success
     */
    getOutgoings(taskId: string | undefined): Promise<OutGoingItem[]> {
        let url_ = this.baseUrl + "/api/QueryTasks/outgoings?";
        if (taskId === null)
            throw new Error("The parameter 'taskId' cannot be null.");
        else if (taskId !== undefined)
            url_ += "taskId=" + encodeURIComponent("" + taskId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetOutgoings(_response);
        });
    }

    protected processGetOutgoings(response: Response): Promise<OutGoingItem[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OutGoingItem.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OutGoingItem[]>(<any>null);
    }

    /**
     * @return Success
     */
    getDisposesMobile(taskId: string): Promise<OutgoingItem1[]> {
        let url_ = this.baseUrl + "/api/QueryTasks/{taskId}/DisposesMobile";
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDisposesMobile(_response);
        });
    }

    protected processGetDisposesMobile(response: Response): Promise<OutgoingItem1[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OutgoingItem1.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OutgoingItem1[]>(<any>null);
    }

    /**
     * 根据流程步骤获取用户列表
     * @param taskId (optional) 
     * @param targetActvityId (optional) 
     * @param dispose (optional) 
     * @return Success
     */
    getUsersByDispose(taskId: string | undefined, targetActvityId: string | undefined, dispose: string | undefined): Promise<UserReply[]> {
        let url_ = this.baseUrl + "/api/QueryTasks/UsersByDispose?";
        if (taskId === null)
            throw new Error("The parameter 'taskId' cannot be null.");
        else if (taskId !== undefined)
            url_ += "taskId=" + encodeURIComponent("" + taskId) + "&";
        if (targetActvityId === null)
            throw new Error("The parameter 'targetActvityId' cannot be null.");
        else if (targetActvityId !== undefined)
            url_ += "targetActvityId=" + encodeURIComponent("" + targetActvityId) + "&";
        if (dispose === null)
            throw new Error("The parameter 'dispose' cannot be null.");
        else if (dispose !== undefined)
            url_ += "dispose=" + encodeURIComponent("" + dispose) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUsersByDispose(_response);
        });
    }

    protected processGetUsersByDispose(response: Response): Promise<UserReply[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserReply.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserReply[]>(<any>null);
    }

    /**
     * 最新的已办任务
     * @param skip (optional) 
     * @param take (optional) 
     * @param userName (optional) 
     * @param title (optional) 
     * @param processDefKey (optional) 
     * @param creatorUserName (optional) 
     * @param creatorUserDisplayNameLike (optional) 
     * @param drafterDepartment (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param archNoLike (optional) 
     * @return Success
     */
    getNewestHistoryTasks(skip: number | undefined, take: number | undefined, userName: string | undefined, title: string | undefined, processDefKey: string | undefined, creatorUserName: string | undefined, creatorUserDisplayNameLike: string | undefined, drafterDepartment: string | undefined, startDate: Date | undefined, endDate: Date | undefined, archNoLike: string | undefined): Promise<NewestHistoryTaskTCollectionWithPagination> {
        let url_ = this.baseUrl + "/api/QueryTasks/newestHistoryTasks?";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&";
        if (title === null)
            throw new Error("The parameter 'title' cannot be null.");
        else if (title !== undefined)
            url_ += "title=" + encodeURIComponent("" + title) + "&";
        if (processDefKey === null)
            throw new Error("The parameter 'processDefKey' cannot be null.");
        else if (processDefKey !== undefined)
            url_ += "processDefKey=" + encodeURIComponent("" + processDefKey) + "&";
        if (creatorUserName === null)
            throw new Error("The parameter 'creatorUserName' cannot be null.");
        else if (creatorUserName !== undefined)
            url_ += "creatorUserName=" + encodeURIComponent("" + creatorUserName) + "&";
        if (creatorUserDisplayNameLike === null)
            throw new Error("The parameter 'creatorUserDisplayNameLike' cannot be null.");
        else if (creatorUserDisplayNameLike !== undefined)
            url_ += "creatorUserDisplayNameLike=" + encodeURIComponent("" + creatorUserDisplayNameLike) + "&";
        if (drafterDepartment === null)
            throw new Error("The parameter 'drafterDepartment' cannot be null.");
        else if (drafterDepartment !== undefined)
            url_ += "drafterDepartment=" + encodeURIComponent("" + drafterDepartment) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (archNoLike === null)
            throw new Error("The parameter 'archNoLike' cannot be null.");
        else if (archNoLike !== undefined)
            url_ += "archNoLike=" + encodeURIComponent("" + archNoLike) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetNewestHistoryTasks(_response);
        });
    }

    protected processGetNewestHistoryTasks(response: Response): Promise<NewestHistoryTaskTCollectionWithPagination> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NewestHistoryTaskTCollectionWithPagination.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NewestHistoryTaskTCollectionWithPagination>(<any>null);
    }

    /**
     * 最新的已办任务
     * @param skip (optional) 
     * @param take (optional) 
     * @param userName (optional) 
     * @param title (optional) 
     * @param creatorUserName (optional) 
     * @param creatorUserDisplayNameLike (optional) 
     * @param drafterDepartment (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param archNoLike (optional) 
     * @param body (optional) 
     * @return Success
     */
    queryNewestHistoryTasks(skip: number | undefined, take: number | undefined, userName: string | undefined, title: string | undefined, creatorUserName: string | undefined, creatorUserDisplayNameLike: string | undefined, drafterDepartment: string | undefined, startDate: Date | undefined, endDate: Date | undefined, archNoLike: string | undefined, body: string[] | undefined): Promise<NewestHistoryTaskTCollectionWithPagination> {
        let url_ = this.baseUrl + "/api/QueryTasks/QueryNewestHistoryTasks?";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&";
        if (title === null)
            throw new Error("The parameter 'title' cannot be null.");
        else if (title !== undefined)
            url_ += "title=" + encodeURIComponent("" + title) + "&";
        if (creatorUserName === null)
            throw new Error("The parameter 'creatorUserName' cannot be null.");
        else if (creatorUserName !== undefined)
            url_ += "creatorUserName=" + encodeURIComponent("" + creatorUserName) + "&";
        if (creatorUserDisplayNameLike === null)
            throw new Error("The parameter 'creatorUserDisplayNameLike' cannot be null.");
        else if (creatorUserDisplayNameLike !== undefined)
            url_ += "creatorUserDisplayNameLike=" + encodeURIComponent("" + creatorUserDisplayNameLike) + "&";
        if (drafterDepartment === null)
            throw new Error("The parameter 'drafterDepartment' cannot be null.");
        else if (drafterDepartment !== undefined)
            url_ += "drafterDepartment=" + encodeURIComponent("" + drafterDepartment) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (archNoLike === null)
            throw new Error("The parameter 'archNoLike' cannot be null.");
        else if (archNoLike !== undefined)
            url_ += "archNoLike=" + encodeURIComponent("" + archNoLike) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processQueryNewestHistoryTasks(_response);
        });
    }

    protected processQueryNewestHistoryTasks(response: Response): Promise<NewestHistoryTaskTCollectionWithPagination> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NewestHistoryTaskTCollectionWithPagination.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NewestHistoryTaskTCollectionWithPagination>(<any>null);
    }
}

export class ReportsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getUserTodoReport(userName: string): Promise<PersonalReportVM> {
        let url_ = this.baseUrl + "/api/Reports/user/{userName}/todo";
        if (userName === undefined || userName === null)
            throw new Error("The parameter 'userName' must be defined.");
        url_ = url_.replace("{userName}", encodeURIComponent("" + userName));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserTodoReport(_response);
        });
    }

    protected processGetUserTodoReport(response: Response): Promise<PersonalReportVM> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PersonalReportVM.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PersonalReportVM>(<any>null);
    }

    /**
     * @return Success
     */
    getMydepartmenOthors(userName: string): Promise<PersonalReportVM[]> {
        let url_ = this.baseUrl + "/api/Reports/MydepartmenOthors/{userName}/todo";
        if (userName === undefined || userName === null)
            throw new Error("The parameter 'userName' must be defined.");
        url_ = url_.replace("{userName}", encodeURIComponent("" + userName));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMydepartmenOthors(_response);
        });
    }

    protected processGetMydepartmenOthors(response: Response): Promise<PersonalReportVM[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PersonalReportVM.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PersonalReportVM[]>(<any>null);
    }

    /**
     * @param startDateTime (optional) 
     * @param endDateTime (optional) 
     * @return Success
     */
    getUserDoneReport(userName: string, startDateTime: Date | undefined, endDateTime: Date | undefined): Promise<PersonalReportVM> {
        let url_ = this.baseUrl + "/api/Reports/user/{userName}/done?";
        if (userName === undefined || userName === null)
            throw new Error("The parameter 'userName' must be defined.");
        url_ = url_.replace("{userName}", encodeURIComponent("" + userName));
        if (startDateTime === null)
            throw new Error("The parameter 'startDateTime' cannot be null.");
        else if (startDateTime !== undefined)
            url_ += "startDateTime=" + encodeURIComponent(startDateTime ? "" + startDateTime.toISOString() : "") + "&";
        if (endDateTime === null)
            throw new Error("The parameter 'endDateTime' cannot be null.");
        else if (endDateTime !== undefined)
            url_ += "endDateTime=" + encodeURIComponent(endDateTime ? "" + endDateTime.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserDoneReport(_response);
        });
    }

    protected processGetUserDoneReport(response: Response): Promise<PersonalReportVM> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PersonalReportVM.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PersonalReportVM>(<any>null);
    }

    /**
     * @return Success
     */
    getDepartmentsTodoWithEndTime(): Promise<void> {
        let url_ = this.baseUrl + "/api/Reports/departments/todo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDepartmentsTodoWithEndTime(_response);
        });
    }

    protected processGetDepartmentsTodoWithEndTime(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param startDateTime (optional) 
     * @param endDateTime (optional) 
     * @return Success
     */
    getCCSPReport(startDateTime: Date | undefined, endDateTime: Date | undefined): Promise<CCSPReportViewModel> {
        let url_ = this.baseUrl + "/api/Reports/ccsp/report?";
        if (startDateTime === null)
            throw new Error("The parameter 'startDateTime' cannot be null.");
        else if (startDateTime !== undefined)
            url_ += "startDateTime=" + encodeURIComponent(startDateTime ? "" + startDateTime.toISOString() : "") + "&";
        if (endDateTime === null)
            throw new Error("The parameter 'endDateTime' cannot be null.");
        else if (endDateTime !== undefined)
            url_ += "endDateTime=" + encodeURIComponent(endDateTime ? "" + endDateTime.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCCSPReport(_response);
        });
    }

    protected processGetCCSPReport(response: Response): Promise<CCSPReportViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CCSPReportViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CCSPReportViewModel>(<any>null);
    }
}

export class RolesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 查询角色列表
     * @param skip (optional) 
     * @param take (optional) 
     * @param search (optional) 
     * @return Success
     */
    getRoles(skip: number | undefined, take: number | undefined, search: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Roles?";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRoles(_response);
        });
    }

    protected processGetRoles(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * 创建角色
     * @param body (optional) 
     * @return Success
     */
    createRole(body: CreateRoleDto | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Roles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateRole(_response);
        });
    }

    protected processCreateRole(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * 查询角色列表
     * @param skip (optional) 
     * @param take (optional) 
     * @param search (optional) 
     * @return Success
     */
    getRolesForV1(skip: number | undefined, take: number | undefined, search: string | undefined): Promise<ApplicationRoleTCollection> {
        let url_ = this.baseUrl + "/api/Roles/v1?";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRolesForV1(_response);
        });
    }

    protected processGetRolesForV1(response: Response): Promise<ApplicationRoleTCollection> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationRoleTCollection.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApplicationRoleTCollection>(<any>null);
    }

    /**
     * 通过id获取角色
     * @return Success
     */
    getRoleById(id: string): Promise<ApplicationRole> {
        let url_ = this.baseUrl + "/api/Roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRoleById(_response);
        });
    }

    protected processGetRoleById(response: Response): Promise<ApplicationRole> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationRole.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApplicationRole>(<any>null);
    }

    /**
     * 删除角色
     * @return Success
     */
    deleteRoleById(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteRoleById(_response);
        });
    }

    protected processDeleteRoleById(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * 更新角色
     * @param body (optional) 
     * @return Success
     */
    updateRole(roleId: string, body: ApplicationRole | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Roles/{roleId}";
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateRole(_response);
        });
    }

    protected processUpdateRole(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * 获取角色拥有的权限
     * @return Success
     */
    getRolePermissons(roleId: string): Promise<Permisson[]> {
        let url_ = this.baseUrl + "/api/Roles/{roleId}/permissons";
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRolePermissons(_response);
        });
    }

    protected processGetRolePermissons(response: Response): Promise<Permisson[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Permisson.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Permisson[]>(<any>null);
    }

    /**
     * 重新分配权限到角色
     * @param body (optional) 
     * @return Success
     */
    reAddPermissonsToRole(roleId: string, body: ReAddPermissonsToRoleDto | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Roles/{roleId}/permissons";
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReAddPermissonsToRole(_response);
        });
    }

    protected processReAddPermissonsToRole(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class RuntimeFlowsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param skip (optional) 
     * @param take (optional) 
     * @param businessKey (optional) 
     * @return Success
     */
    getList(skip: number | undefined, take: number | undefined, businessKey: string | undefined): Promise<RuntimeFlowViewModelTCollectionWithPagination> {
        let url_ = this.baseUrl + "/api/RuntimeFlows?";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&";
        if (businessKey === null)
            throw new Error("The parameter 'businessKey' cannot be null.");
        else if (businessKey !== undefined)
            url_ += "businessKey=" + encodeURIComponent("" + businessKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: Response): Promise<RuntimeFlowViewModelTCollectionWithPagination> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RuntimeFlowViewModelTCollectionWithPagination.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RuntimeFlowViewModelTCollectionWithPagination>(<any>null);
    }

    /**
     * 删除处理实例
     * @param body (optional) 
     * @return Success
     */
    deleteProcessInstancce(processInstanceId: string, body: DeleteProcessInstancceViewModel | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/RuntimeFlows/{ProcessInstanceId}";
        if (processInstanceId === undefined || processInstanceId === null)
            throw new Error("The parameter 'processInstanceId' must be defined.");
        url_ = url_.replace("{ProcessInstanceId}", encodeURIComponent("" + processInstanceId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteProcessInstancce(_response);
        });
    }

    protected processDeleteProcessInstancce(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class TasksClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 待办列表
     * @param skip (optional) 
     * @param pageSize (optional) 
     * @param isJustCreated (optional) 
     * @param proDefKey (optional) 
     * @param titleKeyWord (optional) 
     * @return Success
     */
    getTodoTasks(skip: number | undefined, pageSize: number | undefined, isJustCreated: boolean | undefined, proDefKey: string | undefined, titleKeyWord: string | undefined): Promise<TodoTaskViewModelPaginationResult> {
        let url_ = this.baseUrl + "/api/Tasks/todo?";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (isJustCreated === null)
            throw new Error("The parameter 'isJustCreated' cannot be null.");
        else if (isJustCreated !== undefined)
            url_ += "isJustCreated=" + encodeURIComponent("" + isJustCreated) + "&";
        if (proDefKey === null)
            throw new Error("The parameter 'proDefKey' cannot be null.");
        else if (proDefKey !== undefined)
            url_ += "proDefKey=" + encodeURIComponent("" + proDefKey) + "&";
        if (titleKeyWord === null)
            throw new Error("The parameter 'titleKeyWord' cannot be null.");
        else if (titleKeyWord !== undefined)
            url_ += "titleKeyWord=" + encodeURIComponent("" + titleKeyWord) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTodoTasks(_response);
        });
    }

    protected processGetTodoTasks(response: Response): Promise<TodoTaskViewModelPaginationResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TodoTaskViewModelPaginationResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TodoTaskViewModelPaginationResult>(<any>null);
    }

    /**
     * 获取未办数量
     * @param isJustCreated (optional) 
     * @param body (optional) 
     * @return Success
     */
    getTodoCount(isJustCreated: boolean | undefined, body: string[] | undefined): Promise<number[]> {
        let url_ = this.baseUrl + "/api/Tasks/todo/count?";
        if (isJustCreated === null)
            throw new Error("The parameter 'isJustCreated' cannot be null.");
        else if (isJustCreated !== undefined)
            url_ += "isJustCreated=" + encodeURIComponent("" + isJustCreated) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTodoCount(_response);
        });
    }

    protected processGetTodoCount(response: Response): Promise<number[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number[]>(<any>null);
    }

    /**
     * 获取已办
     * @param skip (optional) 
     * @param take (optional) 
     * @param flow (optional) 
     * @return Success
     */
    getDoneTasks(skip: number | undefined, take: number | undefined, flow: string | undefined): Promise<TodoTaskViewModelPaginationResult> {
        let url_ = this.baseUrl + "/api/Tasks/done?";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&";
        if (flow === null)
            throw new Error("The parameter 'flow' cannot be null.");
        else if (flow !== undefined)
            url_ += "flow=" + encodeURIComponent("" + flow) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDoneTasks(_response);
        });
    }

    protected processGetDoneTasks(response: Response): Promise<TodoTaskViewModelPaginationResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TodoTaskViewModelPaginationResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TodoTaskViewModelPaginationResult>(<any>null);
    }

    /**
     * 获取意见
     * @param processDefKey (optional) 
     * @return Success
     */
    getFormOpinionsByBusinessKey(processDefKey: string | undefined, businessKey: string): Promise<OpinionViewModel[]> {
        let url_ = this.baseUrl + "/api/Tasks/opinions/{businessKey}?";
        if (businessKey === undefined || businessKey === null)
            throw new Error("The parameter 'businessKey' must be defined.");
        url_ = url_.replace("{businessKey}", encodeURIComponent("" + businessKey));
        if (processDefKey === null)
            throw new Error("The parameter 'processDefKey' cannot be null.");
        else if (processDefKey !== undefined)
            url_ += "processDefKey=" + encodeURIComponent("" + processDefKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFormOpinionsByBusinessKey(_response);
        });
    }

    protected processGetFormOpinionsByBusinessKey(response: Response): Promise<OpinionViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OpinionViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OpinionViewModel[]>(<any>null);
    }

    /**
     * 撤回
     * @return Success
     */
    cancelAllForActivity(taskId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Tasks/cancel/{taskId}";
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCancelAllForActivity(_response);
        });
    }

    protected processCancelAllForActivity(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    getDisposes(taskId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Tasks/{taskId}/disposes";
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDisposes(_response);
        });
    }

    protected processGetDisposes(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * 获取表单
     * @param mode (optional) 
     * @param taskId (optional) 
     * @param businessKey (optional) 
     * @return Success
     */
    getTaskDetail(mode: GetFormDetailMode | undefined, taskId: string | undefined, businessKey: string | undefined): Promise<FormDetailViewModel> {
        let url_ = this.baseUrl + "/api/Tasks/detail?";
        if (mode === null)
            throw new Error("The parameter 'mode' cannot be null.");
        else if (mode !== undefined)
            url_ += "mode=" + encodeURIComponent("" + mode) + "&";
        if (taskId === null)
            throw new Error("The parameter 'taskId' cannot be null.");
        else if (taskId !== undefined)
            url_ += "taskId=" + encodeURIComponent("" + taskId) + "&";
        if (businessKey === null)
            throw new Error("The parameter 'businessKey' cannot be null.");
        else if (businessKey !== undefined)
            url_ += "businessKey=" + encodeURIComponent("" + businessKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTaskDetail(_response);
        });
    }

    protected processGetTaskDetail(response: Response): Promise<FormDetailViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FormDetailViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FormDetailViewModel>(<any>null);
    }

    /**
     * 获取办文过程
     * @return Success
     */
    getDealProcesses(businessKey: string): Promise<DealProcesseViewModel[]> {
        let url_ = this.baseUrl + "/api/Tasks/DealProcesses/{businessKey}";
        if (businessKey === undefined || businessKey === null)
            throw new Error("The parameter 'businessKey' must be defined.");
        url_ = url_.replace("{businessKey}", encodeURIComponent("" + businessKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDealProcesses(_response);
        });
    }

    protected processGetDealProcesses(response: Response): Promise<DealProcesseViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DealProcesseViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DealProcesseViewModel[]>(<any>null);
    }

    /**
     * 获取待办办列表数量
     * @param userName (optional) 
     * @param isJustCreated (optional) 
     * @param title (optional) 
     * @param archType (optional) 公文类型 办件、阅件
     * @param body (optional) 
     * @return Success
     */
    queryTodoTaskListCount(userName: string | undefined, isJustCreated: boolean | undefined, title: string | undefined, archType: string | undefined, body: string[] | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/Tasks/TodoList/count?";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&";
        if (isJustCreated === null)
            throw new Error("The parameter 'isJustCreated' cannot be null.");
        else if (isJustCreated !== undefined)
            url_ += "isJustCreated=" + encodeURIComponent("" + isJustCreated) + "&";
        if (title === null)
            throw new Error("The parameter 'title' cannot be null.");
        else if (title !== undefined)
            url_ += "title=" + encodeURIComponent("" + title) + "&";
        if (archType === null)
            throw new Error("The parameter 'archType' cannot be null.");
        else if (archType !== undefined)
            url_ += "archType=" + encodeURIComponent("" + archType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processQueryTodoTaskListCount(_response);
        });
    }

    protected processQueryTodoTaskListCount(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    /**
     * 获取待办列表
     * @param userName (optional) 
     * @param skip (optional) 
     * @param take (optional) 
     * @param isJustCreated (optional) 
     * @param title (optional) 
     * @param archType (optional) 公文类型 办件、阅件
     * @param body (optional) 
     * @return Success
     */
    queryTodoTaskList(userName: string | undefined, skip: number | undefined, take: number | undefined, isJustCreated: boolean | undefined, title: string | undefined, archType: string | undefined, body: string[] | undefined): Promise<MobileTaskListPaginationResult> {
        let url_ = this.baseUrl + "/api/Tasks/TodoList?";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&";
        if (isJustCreated === null)
            throw new Error("The parameter 'isJustCreated' cannot be null.");
        else if (isJustCreated !== undefined)
            url_ += "isJustCreated=" + encodeURIComponent("" + isJustCreated) + "&";
        if (title === null)
            throw new Error("The parameter 'title' cannot be null.");
        else if (title !== undefined)
            url_ += "title=" + encodeURIComponent("" + title) + "&";
        if (archType === null)
            throw new Error("The parameter 'archType' cannot be null.");
        else if (archType !== undefined)
            url_ += "archType=" + encodeURIComponent("" + archType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processQueryTodoTaskList(_response);
        });
    }

    protected processQueryTodoTaskList(response: Response): Promise<MobileTaskListPaginationResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MobileTaskListPaginationResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MobileTaskListPaginationResult>(<any>null);
    }

    /**
     * 获取已办列表
     * @param userName (optional) 
     * @param skip (optional) 
     * @param take (optional) 
     * @param search (optional) 
     * @param body (optional) 
     * @return Success
     */
    queryDoneTaskList(userName: string | undefined, skip: number | undefined, take: number | undefined, search: string | undefined, body: string[] | undefined): Promise<MobileTaskListPaginationResult> {
        let url_ = this.baseUrl + "/api/Tasks/DoneList?";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processQueryDoneTaskList(_response);
        });
    }

    protected processQueryDoneTaskList(response: Response): Promise<MobileTaskListPaginationResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MobileTaskListPaginationResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MobileTaskListPaginationResult>(<any>null);
    }

    /**
     * 暂存
     * @param body (optional) 
     * @return Success
     */
    tempSaveTask(taskId: string, body: TempSaveTaskViewModel | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Tasks/{TaskId}/TempSave";
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{TaskId}", encodeURIComponent("" + taskId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTempSaveTask(_response);
        });
    }

    protected processTempSaveTask(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param taskId (optional) 
     * @return Success
     */
    getOutgoings(taskId: string | undefined): Promise<OutGoingItem[]> {
        let url_ = this.baseUrl + "/api/Tasks/outgoings?";
        if (taskId === null)
            throw new Error("The parameter 'taskId' cannot be null.");
        else if (taskId !== undefined)
            url_ += "taskId=" + encodeURIComponent("" + taskId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetOutgoings(_response);
        });
    }

    protected processGetOutgoings(response: Response): Promise<OutGoingItem[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OutGoingItem.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OutGoingItem[]>(<any>null);
    }

    /**
     * @return Success
     */
    getDisposesMobile(taskId: string): Promise<OutgoingItem1[]> {
        let url_ = this.baseUrl + "/api/Tasks/{taskId}/DisposesMobile";
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDisposesMobile(_response);
        });
    }

    protected processGetDisposesMobile(response: Response): Promise<OutgoingItem1[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OutgoingItem1.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OutgoingItem1[]>(<any>null);
    }

    /**
     * 根据流程步骤获取用户列表
     * @param taskId (optional) 
     * @param targetActvityId (optional) 
     * @param dispose (optional) 
     * @return Success
     */
    getUsersByDispose(taskId: string | undefined, targetActvityId: string | undefined, dispose: string | undefined): Promise<UserReply[]> {
        let url_ = this.baseUrl + "/api/Tasks/UsersByDispose?";
        if (taskId === null)
            throw new Error("The parameter 'taskId' cannot be null.");
        else if (taskId !== undefined)
            url_ += "taskId=" + encodeURIComponent("" + taskId) + "&";
        if (targetActvityId === null)
            throw new Error("The parameter 'targetActvityId' cannot be null.");
        else if (targetActvityId !== undefined)
            url_ += "targetActvityId=" + encodeURIComponent("" + targetActvityId) + "&";
        if (dispose === null)
            throw new Error("The parameter 'dispose' cannot be null.");
        else if (dispose !== undefined)
            url_ += "dispose=" + encodeURIComponent("" + dispose) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUsersByDispose(_response);
        });
    }

    protected processGetUsersByDispose(response: Response): Promise<UserReply[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserReply.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserReply[]>(<any>null);
    }

    /**
     * 最新的已办任务
     * @param skip (optional) 
     * @param take (optional) 
     * @param userName (optional) 
     * @param title (optional) 
     * @param processDefKey (optional) 
     * @param creatorUserName (optional) 
     * @param creatorUserDisplayNameLike (optional) 
     * @param drafterDepartment (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getNewestHistoryTasks(skip: number | undefined, take: number | undefined, userName: string | undefined, title: string | undefined, processDefKey: string | undefined, creatorUserName: string | undefined, creatorUserDisplayNameLike: string | undefined, drafterDepartment: string | undefined, startDate: Date | undefined, endDate: Date | undefined): Promise<NewestHistoryTaskTCollectionWithPagination> {
        let url_ = this.baseUrl + "/api/Tasks/newestHistoryTasks?";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&";
        if (title === null)
            throw new Error("The parameter 'title' cannot be null.");
        else if (title !== undefined)
            url_ += "title=" + encodeURIComponent("" + title) + "&";
        if (processDefKey === null)
            throw new Error("The parameter 'processDefKey' cannot be null.");
        else if (processDefKey !== undefined)
            url_ += "processDefKey=" + encodeURIComponent("" + processDefKey) + "&";
        if (creatorUserName === null)
            throw new Error("The parameter 'creatorUserName' cannot be null.");
        else if (creatorUserName !== undefined)
            url_ += "creatorUserName=" + encodeURIComponent("" + creatorUserName) + "&";
        if (creatorUserDisplayNameLike === null)
            throw new Error("The parameter 'creatorUserDisplayNameLike' cannot be null.");
        else if (creatorUserDisplayNameLike !== undefined)
            url_ += "creatorUserDisplayNameLike=" + encodeURIComponent("" + creatorUserDisplayNameLike) + "&";
        if (drafterDepartment === null)
            throw new Error("The parameter 'drafterDepartment' cannot be null.");
        else if (drafterDepartment !== undefined)
            url_ += "drafterDepartment=" + encodeURIComponent("" + drafterDepartment) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetNewestHistoryTasks(_response);
        });
    }

    protected processGetNewestHistoryTasks(response: Response): Promise<NewestHistoryTaskTCollectionWithPagination> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NewestHistoryTaskTCollectionWithPagination.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NewestHistoryTaskTCollectionWithPagination>(<any>null);
    }
}

export class TokenClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param grant_type (optional) 
     * @param client_id (optional) 
     * @param username (optional) 
     * @param password (optional) 
     * @param code (optional) 
     * @return Success
     */
    getToken(grant_type: GrantType | undefined, client_id: string | undefined, username: string | undefined, password: string | undefined, code: string | undefined): Promise<SuccessfulTokenResponse> {
        let url_ = this.baseUrl + "/connect/token";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (grant_type === null || grant_type === undefined)
            throw new Error("The parameter 'grant_type' cannot be null.");
        else
            content_.append("grant_type", grant_type.toString());
        if (client_id === null || client_id === undefined)
            throw new Error("The parameter 'client_id' cannot be null.");
        else
            content_.append("client_id", client_id.toString());
        if (username === null || username === undefined)
            throw new Error("The parameter 'username' cannot be null.");
        else
            content_.append("username", username.toString());
        if (password === null || password === undefined)
            throw new Error("The parameter 'password' cannot be null.");
        else
            content_.append("password", password.toString());
        if (code === null || code === undefined)
            throw new Error("The parameter 'code' cannot be null.");
        else
            content_.append("code", code.toString());

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetToken(_response);
        });
    }

    protected processGetToken(response: Response): Promise<SuccessfulTokenResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SuccessfulTokenResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = TokenErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SuccessfulTokenResponse>(<any>null);
    }
}

export class UserCustomOpinionsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param userName (optional) 
     * @return Success
     */
    getUserCustomOpinions(userName: string | undefined): Promise<UserCustomOpinionViewModel[]> {
        let url_ = this.baseUrl + "/api/UserCustomOpinions?";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserCustomOpinions(_response);
        });
    }

    protected processGetUserCustomOpinions(response: Response): Promise<UserCustomOpinionViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserCustomOpinionViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserCustomOpinionViewModel[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    postUserCustomOpinion(body: UserCustomOpinionViewModel | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/UserCustomOpinions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostUserCustomOpinion(_response);
        });
    }

    protected processPostUserCustomOpinion(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param userName (optional) 
     * @return Success
     */
    getUserCustomOpinionsForOldFlow(userName: string | undefined): Promise<UserCustomOpinionViewModel[]> {
        let url_ = this.baseUrl + "/api/UserCustomOpinions/OldFlow?";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserCustomOpinionsForOldFlow(_response);
        });
    }

    protected processGetUserCustomOpinionsForOldFlow(response: Response): Promise<UserCustomOpinionViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserCustomOpinionViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserCustomOpinionViewModel[]>(<any>null);
    }

    /**
     * @param userName (optional) 
     * @return Success
     */
    getUserCustomOpinionsForNewFlow(userName: string | undefined): Promise<UserCustomOpinionViewModel[]> {
        let url_ = this.baseUrl + "/api/UserCustomOpinions/NewFlow?";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserCustomOpinionsForNewFlow(_response);
        });
    }

    protected processGetUserCustomOpinionsForNewFlow(response: Response): Promise<UserCustomOpinionViewModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserCustomOpinionViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserCustomOpinionViewModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    getUserCustomOpinion(id: number): Promise<UserCustomOpinion> {
        let url_ = this.baseUrl + "/api/UserCustomOpinions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserCustomOpinion(_response);
        });
    }

    protected processGetUserCustomOpinion(response: Response): Promise<UserCustomOpinion> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserCustomOpinion.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserCustomOpinion>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    putUserCustomOpinion(id: number, body: UserCustomOpinion | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/UserCustomOpinions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPutUserCustomOpinion(_response);
        });
    }

    protected processPutUserCustomOpinion(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    deleteUserCustomOpinion(id: string): Promise<UserCustomOpinion> {
        let url_ = this.baseUrl + "/api/UserCustomOpinions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteUserCustomOpinion(_response);
        });
    }

    protected processDeleteUserCustomOpinion(response: Response): Promise<UserCustomOpinion> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserCustomOpinion.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserCustomOpinion>(<any>null);
    }
}

export class UserGroupsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 获取用户组
     * @return Success
     */
    getUserGroups(): Promise<UserGroup[]> {
        let url_ = this.baseUrl + "/api/UserGroups";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserGroups(_response);
        });
    }

    protected processGetUserGroups(response: Response): Promise<UserGroup[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserGroup.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserGroup[]>(<any>null);
    }

    /**
     * 创建用户组
     * @param body (optional) 
     * @return Success
     */
    createUserGroup(body: CreateUserGroupDto | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/UserGroups";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateUserGroup(_response);
        });
    }

    protected processCreateUserGroup(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * 根据用户组Id获取单个用户组
     * @return Success
     */
    getUserGroupById(id: number): Promise<UserGroup> {
        let url_ = this.baseUrl + "/api/UserGroups/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserGroupById(_response);
        });
    }

    protected processGetUserGroupById(response: Response): Promise<UserGroup> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserGroup.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserGroup>(<any>null);
    }

    /**
     * 更新用户组
     * @param body (optional) 
     * @return Success
     */
    updateUserGroup(id: number, body: UserGroup | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/UserGroups/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateUserGroup(_response);
        });
    }

    protected processUpdateUserGroup(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * 删除用户组
     * @return Success
     */
    deleteUserGroup(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/UserGroups/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteUserGroup(_response);
        });
    }

    protected processDeleteUserGroup(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * 获取组下用户
     * @return Success
     */
    getUsersOfUserGroup(id: number): Promise<UsersOfUserGroupDto[]> {
        let url_ = this.baseUrl + "/api/UserGroups/{id}/users";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUsersOfUserGroup(_response);
        });
    }

    protected processGetUsersOfUserGroup(response: Response): Promise<UsersOfUserGroupDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UsersOfUserGroupDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UsersOfUserGroupDto[]>(<any>null);
    }

    /**
     * 添加用户到用户组
     * @param body (optional) 
     * @return Success
     */
    addUsersToUserGroup(id: number, body: AddUsersToUserGroupViewModel | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/UserGroups/{id}/users";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddUsersToUserGroup(_response);
        });
    }

    protected processAddUsersToUserGroup(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key] ? ModelStateEntry.fromJS(resultData400[key]) : new ModelStateEntry();
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);
            });
        }
    }

    /**
     * 从用户组移除用户
     * @param body (optional) 
     * @return Success
     */
    removeUserFromUserGroup(id: number, body: UserIdAndDepartmentId[] | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/UserGroups/{id}/users";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveUserFromUserGroup(_response);
        });
    }

    protected processRemoveUserFromUserGroup(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * 更新用户在用户组内的排序
     * @param departmentId (optional) 
     * @param order (optional) 
     * @return Success
     */
    updateUserOrderInUserGroup(userGroupId: number, userId: string, departmentId: string | undefined, order: number | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/UserGroups/{userGroupId}/{userId}/order?";
        if (userGroupId === undefined || userGroupId === null)
            throw new Error("The parameter 'userGroupId' must be defined.");
        url_ = url_.replace("{userGroupId}", encodeURIComponent("" + userGroupId));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (departmentId === null)
            throw new Error("The parameter 'departmentId' cannot be null.");
        else if (departmentId !== undefined)
            url_ += "departmentId=" + encodeURIComponent("" + departmentId) + "&";
        if (order === null)
            throw new Error("The parameter 'order' cannot be null.");
        else if (order !== undefined)
            url_ += "order=" + encodeURIComponent("" + order) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateUserOrderInUserGroup(_response);
        });
    }

    protected processUpdateUserOrderInUserGroup(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class UserInfoClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 获取用户信息
     * @return Success
     */
    getUserInfo(): Promise<{ [key: string]: string; }> {
        let url_ = this.baseUrl + "/connect/userinfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserInfo(_response);
        });
    }

    protected processGetUserInfo(response: Response): Promise<{ [key: string]: string; }> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key];
                }
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<{ [key: string]: string; }>(<any>null);
    }
}

export class UserOpinionsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUserOpinion(id: string, body: UpdateUserOpinionViewModel | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/UserOpinions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateUserOpinion(_response);
        });
    }

    protected processUpdateUserOpinion(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param userName (optional) 
     * @return Success
     */
    deleteUserOpinion(id: string, userName: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/UserOpinions/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteUserOpinion(_response);
        });
    }

    protected processDeleteUserOpinion(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class UsersClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 查询用户列表
     * @param skip (optional) 
     * @param take (optional) 
     * @param queryUserName (optional) 
     * @param queryName (optional) 
     * @param includeUserRoles (optional) 
     * @param includeUserDepartments (optional) 
     * @return Success
     */
    getUsers(skip: number | undefined, take: number | undefined, queryUserName: string | undefined, queryName: string | undefined, includeUserRoles: boolean | undefined, includeUserDepartments: boolean | undefined): Promise<UserDtoPaginationResult> {
        let url_ = this.baseUrl + "/api/Users?";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&";
        if (queryUserName === null)
            throw new Error("The parameter 'queryUserName' cannot be null.");
        else if (queryUserName !== undefined)
            url_ += "queryUserName=" + encodeURIComponent("" + queryUserName) + "&";
        if (queryName === null)
            throw new Error("The parameter 'queryName' cannot be null.");
        else if (queryName !== undefined)
            url_ += "queryName=" + encodeURIComponent("" + queryName) + "&";
        if (includeUserRoles === null)
            throw new Error("The parameter 'includeUserRoles' cannot be null.");
        else if (includeUserRoles !== undefined)
            url_ += "includeUserRoles=" + encodeURIComponent("" + includeUserRoles) + "&";
        if (includeUserDepartments === null)
            throw new Error("The parameter 'includeUserDepartments' cannot be null.");
        else if (includeUserDepartments !== undefined)
            url_ += "includeUserDepartments=" + encodeURIComponent("" + includeUserDepartments) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUsers(_response);
        });
    }

    protected processGetUsers(response: Response): Promise<UserDtoPaginationResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoPaginationResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserDtoPaginationResult>(<any>null);
    }

    /**
     * 创建用户
     * @param body (optional) 
     * @return Success
     */
    createUser(body: CreateUserDto | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateUser(_response);
        });
    }

    protected processCreateUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * 通过用户名获取用户
     * @return Success
     */
    getUserByUserName(id: string): Promise<UserReply> {
        let url_ = this.baseUrl + "/api/Users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserByUserName(_response);
        });
    }

    protected processGetUserByUserName(response: Response): Promise<UserReply> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserReply.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserReply>(<any>null);
    }

    /**
     * 通过id删除用户
     * @return Success
     */
    deleteUserById(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteUserById(_response);
        });
    }

    protected processDeleteUserById(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * 更新用户
     * @param job (optional) 
     * @param body (optional) 
     * @return Success
     */
    updateUser(id: string, job: string | undefined, body: ApplicationUser | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Users/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (job === null)
            throw new Error("The parameter 'job' cannot be null.");
        else if (job !== undefined)
            url_ += "job=" + encodeURIComponent("" + job) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateUser(_response);
        });
    }

    protected processUpdateUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * 通过id获取用户
     * @return Success
     */
    getUserById(id: string): Promise<ApplicationUser> {
        let url_ = this.baseUrl + "/api/Users/{id}/WithId";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserById(_response);
        });
    }

    protected processGetUserById(response: Response): Promise<ApplicationUser> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationUser.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApplicationUser>(<any>null);
    }

    /**
     * @return Success
     */
    getUserDepartmentJobById(id: string): Promise<string> {
        let url_ = this.baseUrl + "/api/Users/{id}/DepartmentJob";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserDepartmentJobById(_response);
        });
    }

    protected processGetUserDepartmentJobById(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * 批量导入用户
     * @return Success
     */
    importUsersFromSteam(): Promise<void> {
        let url_ = this.baseUrl + "/api/Users/ImportUsers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processImportUsersFromSteam(_response);
        });
    }

    protected processImportUsersFromSteam(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * 获取Excel模板
     * @return Success
     */
    getUserExcel(): Promise<void> {
        let url_ = this.baseUrl + "/api/Users/UserExcel";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserExcel(_response);
        });
    }

    protected processGetUserExcel(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * 获取用户拥有的角色
     * @return Success
     */
    getRolesOfUser(userId: string): Promise<ApplicationRole[]> {
        let url_ = this.baseUrl + "/api/Users/{userId}/roles";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRolesOfUser(_response);
        });
    }

    protected processGetRolesOfUser(response: Response): Promise<ApplicationRole[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ApplicationRole.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApplicationRole[]>(<any>null);
    }

    /**
     * 为用户分配角色
     * @param body (optional) 
     * @return Success
     */
    addToRoles(userId: string, body: AddToRolesViewModel | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Users/{userId}/roles";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddToRoles(_response);
        });
    }

    protected processAddToRoles(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * 删除用户角色
     * @param body (optional) 
     * @return Success
     */
    removeUserRoles(userId: string, body: AddToRolesViewModel | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Users/{userId}/roles";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveUserRoles(_response);
        });
    }

    protected processRemoveUserRoles(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * 获取用户声明
     * @return Success
     */
    getUserClaims(userId: string): Promise<ApplicationIdentityUserClaim[]> {
        let url_ = this.baseUrl + "/api/Users/{userId}/claims";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserClaims(_response);
        });
    }

    protected processGetUserClaims(response: Response): Promise<ApplicationIdentityUserClaim[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ApplicationIdentityUserClaim.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApplicationIdentityUserClaim[]>(<any>null);
    }

    /**
     * 创建或者更新角色声明
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateUserClaim(userId: string, body: ApplicationIdentityUserClaim | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Users/{userId}/claims";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateOrUpdateUserClaim(_response);
        });
    }

    protected processCreateOrUpdateUserClaim(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * 删除用户声明
     * @return Success
     */
    deleteUserClaim(userId: string, claimId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/Users/{userId}/claims/{claimId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (claimId === undefined || claimId === null)
            throw new Error("The parameter 'claimId' must be defined.");
        url_ = url_.replace("{claimId}", encodeURIComponent("" + claimId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteUserClaim(_response);
        });
    }

    protected processDeleteUserClaim(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * 用户拥有的权限
     * @return Success
     */
    getPermissonsOfUser(userId: string): Promise<string[]> {
        let url_ = this.baseUrl + "/api/Users/{userId}/Permissons";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPermissonsOfUser(_response);
        });
    }

    protected processGetPermissonsOfUser(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(<any>null);
    }

    /**
     * 用户拥有的部门
     * @return Success
     */
    getUserDepartments(userId: string): Promise<Department[]> {
        let url_ = this.baseUrl + "/api/Users/{userId}/departments";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserDepartments(_response);
        });
    }

    protected processGetUserDepartments(response: Response): Promise<Department[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Department.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Department[]>(<any>null);
    }
}

export class UserTaskClaimsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 设置星标
     * @param businessKey (optional) 
     * @param star (optional) 
     * @return Success
     */
    setStar(businessKey: string | undefined, star: boolean | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/UserTaskClaims/setStar?";
        if (businessKey === null)
            throw new Error("The parameter 'businessKey' cannot be null.");
        else if (businessKey !== undefined)
            url_ += "businessKey=" + encodeURIComponent("" + businessKey) + "&";
        if (star === null)
            throw new Error("The parameter 'star' cannot be null.");
        else if (star !== undefined)
            url_ += "star=" + encodeURIComponent("" + star) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetStar(_response);
        });
    }

    protected processSetStar(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class UserTaskDelegatesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param userName (optional) 
     * @return Success
     */
    getUserTaskDelegates(userName: string | undefined): Promise<UserTaskDelegateViewModelTCollection> {
        let url_ = this.baseUrl + "/api/UserTaskDelegates?";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserTaskDelegates(_response);
        });
    }

    protected processGetUserTaskDelegates(response: Response): Promise<UserTaskDelegateViewModelTCollection> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserTaskDelegateViewModelTCollection.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserTaskDelegateViewModelTCollection>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createUserTaskDelegate(body: CreateUserTaskDelegateViewModel | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/UserTaskDelegates";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateUserTaskDelegate(_response);
        });
    }

    protected processCreateUserTaskDelegate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/UserTaskDelegates/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class UserTasksClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 完成任务(新引擎)
     * @param body (optional) 
     * @return Success
     */
    completeTask(body: CompleteTaskViewModel | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/UserTasks/CompleteTask";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCompleteTask(_response);
        });
    }

    protected processCompleteTask(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * 根据业务编号获取运行的用户任务
     * @return Success
     */
    getRuntimeUserTaskByBusinessKey(businessKey: string): Promise<RuntimeUserTaskTaskTCollection> {
        let url_ = this.baseUrl + "/api/UserTasks/runtime-usertasks/{businessKey}";
        if (businessKey === undefined || businessKey === null)
            throw new Error("The parameter 'businessKey' must be defined.");
        url_ = url_.replace("{businessKey}", encodeURIComponent("" + businessKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRuntimeUserTaskByBusinessKey(_response);
        });
    }

    protected processGetRuntimeUserTaskByBusinessKey(response: Response): Promise<RuntimeUserTaskTaskTCollection> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RuntimeUserTaskTaskTCollection.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RuntimeUserTaskTaskTCollection>(<any>null);
    }

    /**
     * 撤回
     * @param body (optional) 
     * @return Success
     */
    takebackActivity(doneTaskId: string, body: TakebackActivityViewModel | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/UserTasks/takeback/{doneTaskId}";
        if (doneTaskId === undefined || doneTaskId === null)
            throw new Error("The parameter 'doneTaskId' must be defined.");
        url_ = url_.replace("{doneTaskId}", encodeURIComponent("" + doneTaskId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTakebackActivity(_response);
        });
    }

    protected processTakebackActivity(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorModel.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class UtilsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    guid(): Promise<string> {
        let url_ = this.baseUrl + "/api/Utils/Guid";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGuid(_response);
        });
    }

    protected processGuid(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * @return Success
     */
    serverDateTime(): Promise<string> {
        let url_ = this.baseUrl + "/api/Utils/ServerDateTime";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processServerDateTime(_response);
        });
    }

    protected processServerDateTime(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }
}

export class ValuesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    text(): Promise<void> {
        let url_ = this.baseUrl + "/qq";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processText(_response);
        });
    }

    protected processText(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    get(): Promise<void> {
        let url_ = this.baseUrl + "/api/Values/arch";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    getOps(): Promise<void> {
        let url_ = this.baseUrl + "/api/Values/convertOps";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetOps(_response);
        });
    }

    protected processGetOps(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    convertPersons(): Promise<void> {
        let url_ = this.baseUrl + "/api/Values/person";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processConvertPersons(_response);
        });
    }

    protected processConvertPersons(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    index(): Promise<void> {
        let url_ = this.baseUrl + "/api/Values/dt";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processIndex(_response);
        });
    }

    protected processIndex(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class Values2019Client {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(): Promise<void> {
        let url_ = this.baseUrl + "/api/Values2019/arch";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    getOps(): Promise<void> {
        let url_ = this.baseUrl + "/api/Values2019/convertOps";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetOps(_response);
        });
    }

    protected processGetOps(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    convertPersons(): Promise<void> {
        let url_ = this.baseUrl + "/api/Values2019/person";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processConvertPersons(_response);
        });
    }

    protected processConvertPersons(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class ActivityOutgoingUsersConfig implements IActivityOutgoingUsersConfig {
    id?: number;
    prodefId?: string | undefined;
    prodefKey?: string | undefined;
    prodefName?: string | undefined;
    activityId?: string | undefined;
    activityName?: string | undefined;
    sequenceFlowName?: string | undefined;
    conditionExpression?: string | undefined;
    targetActivityId?: string | undefined;
    targetActivityName?: string | undefined;
    targetActivityTypeName?: string | undefined;
    targetActivityAssignee?: string | undefined;
    targetActivityIsMultiInstance?: boolean;
    targetActivityMultiInstanceCollection?: string | undefined;
    targetActivityMultiInstanceElementVariable?: string | undefined;
    order?: number;

    constructor(data?: IActivityOutgoingUsersConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.prodefId = _data["prodefId"];
            this.prodefKey = _data["prodefKey"];
            this.prodefName = _data["prodefName"];
            this.activityId = _data["activityId"];
            this.activityName = _data["activityName"];
            this.sequenceFlowName = _data["sequenceFlowName"];
            this.conditionExpression = _data["conditionExpression"];
            this.targetActivityId = _data["targetActivityId"];
            this.targetActivityName = _data["targetActivityName"];
            this.targetActivityTypeName = _data["targetActivityTypeName"];
            this.targetActivityAssignee = _data["targetActivityAssignee"];
            this.targetActivityIsMultiInstance = _data["targetActivityIsMultiInstance"];
            this.targetActivityMultiInstanceCollection = _data["targetActivityMultiInstanceCollection"];
            this.targetActivityMultiInstanceElementVariable = _data["targetActivityMultiInstanceElementVariable"];
            this.order = _data["order"];
        }
    }

    static fromJS(data: any): ActivityOutgoingUsersConfig {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityOutgoingUsersConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["prodefId"] = this.prodefId;
        data["prodefKey"] = this.prodefKey;
        data["prodefName"] = this.prodefName;
        data["activityId"] = this.activityId;
        data["activityName"] = this.activityName;
        data["sequenceFlowName"] = this.sequenceFlowName;
        data["conditionExpression"] = this.conditionExpression;
        data["targetActivityId"] = this.targetActivityId;
        data["targetActivityName"] = this.targetActivityName;
        data["targetActivityTypeName"] = this.targetActivityTypeName;
        data["targetActivityAssignee"] = this.targetActivityAssignee;
        data["targetActivityIsMultiInstance"] = this.targetActivityIsMultiInstance;
        data["targetActivityMultiInstanceCollection"] = this.targetActivityMultiInstanceCollection;
        data["targetActivityMultiInstanceElementVariable"] = this.targetActivityMultiInstanceElementVariable;
        data["order"] = this.order;
        return data; 
    }
}

export interface IActivityOutgoingUsersConfig {
    id?: number;
    prodefId?: string | undefined;
    prodefKey?: string | undefined;
    prodefName?: string | undefined;
    activityId?: string | undefined;
    activityName?: string | undefined;
    sequenceFlowName?: string | undefined;
    conditionExpression?: string | undefined;
    targetActivityId?: string | undefined;
    targetActivityName?: string | undefined;
    targetActivityTypeName?: string | undefined;
    targetActivityAssignee?: string | undefined;
    targetActivityIsMultiInstance?: boolean;
    targetActivityMultiInstanceCollection?: string | undefined;
    targetActivityMultiInstanceElementVariable?: string | undefined;
    order?: number;
}

/** 为用户分配角色视图模型 */
export class AddToRolesViewModel implements IAddToRolesViewModel {
    /** 用户id */
    userId!: string;
    /** 角色id列表 */
    roleIds!: string[];

    constructor(data?: IAddToRolesViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.roleIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            if (Array.isArray(_data["roleIds"])) {
                this.roleIds = [] as any;
                for (let item of _data["roleIds"])
                    this.roleIds!.push(item);
            }
        }
    }

    static fromJS(data: any): AddToRolesViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new AddToRolesViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        if (Array.isArray(this.roleIds)) {
            data["roleIds"] = [];
            for (let item of this.roleIds)
                data["roleIds"].push(item);
        }
        return data; 
    }
}

/** 为用户分配角色视图模型 */
export interface IAddToRolesViewModel {
    /** 用户id */
    userId: string;
    /** 角色id列表 */
    roleIds: string[];
}

export class AddUsersToUserGroupViewModel implements IAddUsersToUserGroupViewModel {
    userGroupId?: number;
    users?: UserIdAndDepartmentId[] | undefined;

    constructor(data?: IAddUsersToUserGroupViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userGroupId = _data["userGroupId"];
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(UserIdAndDepartmentId.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AddUsersToUserGroupViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new AddUsersToUserGroupViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userGroupId"] = this.userGroupId;
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAddUsersToUserGroupViewModel {
    userGroupId?: number;
    users?: UserIdAndDepartmentId[] | undefined;
}

export class AddUserToDepartmentViewModel implements IAddUserToDepartmentViewModel {
    departmentId?: string | undefined;
    userIds?: string[] | undefined;

    constructor(data?: IAddUserToDepartmentViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.departmentId = _data["departmentId"];
            if (Array.isArray(_data["userIds"])) {
                this.userIds = [] as any;
                for (let item of _data["userIds"])
                    this.userIds!.push(item);
            }
        }
    }

    static fromJS(data: any): AddUserToDepartmentViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new AddUserToDepartmentViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["departmentId"] = this.departmentId;
        if (Array.isArray(this.userIds)) {
            data["userIds"] = [];
            for (let item of this.userIds)
                data["userIds"].push(item);
        }
        return data; 
    }
}

export interface IAddUserToDepartmentViewModel {
    departmentId?: string | undefined;
    userIds?: string[] | undefined;
}

export class ApplicationIdentityUserClaim implements IApplicationIdentityUserClaim {
    id?: number;
    userId?: string | undefined;
    claimType?: string | undefined;
    claimValue?: string | undefined;
    claimValueType?: string | undefined;

    constructor(data?: IApplicationIdentityUserClaim) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.claimType = _data["claimType"];
            this.claimValue = _data["claimValue"];
            this.claimValueType = _data["claimValueType"];
        }
    }

    static fromJS(data: any): ApplicationIdentityUserClaim {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationIdentityUserClaim();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["claimType"] = this.claimType;
        data["claimValue"] = this.claimValue;
        data["claimValueType"] = this.claimValueType;
        return data; 
    }
}

export interface IApplicationIdentityUserClaim {
    id?: number;
    userId?: string | undefined;
    claimType?: string | undefined;
    claimValue?: string | undefined;
    claimValueType?: string | undefined;
}

export class ApplicationRole implements IApplicationRole {
    id?: string | undefined;
    name?: string | undefined;
    normalizedName?: string | undefined;
    concurrencyStamp?: string | undefined;
    desc?: string | undefined;
    nonEditable?: boolean;

    constructor(data?: IApplicationRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.normalizedName = _data["normalizedName"];
            this.concurrencyStamp = _data["concurrencyStamp"];
            this.desc = _data["desc"];
            this.nonEditable = _data["nonEditable"];
        }
    }

    static fromJS(data: any): ApplicationRole {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["normalizedName"] = this.normalizedName;
        data["concurrencyStamp"] = this.concurrencyStamp;
        data["desc"] = this.desc;
        data["nonEditable"] = this.nonEditable;
        return data; 
    }
}

export interface IApplicationRole {
    id?: string | undefined;
    name?: string | undefined;
    normalizedName?: string | undefined;
    concurrencyStamp?: string | undefined;
    desc?: string | undefined;
    nonEditable?: boolean;
}

export class ApplicationRoleTCollection implements IApplicationRoleTCollection {
    value?: ApplicationRole[] | undefined;

    constructor(data?: IApplicationRoleTCollection) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(ApplicationRole.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApplicationRoleTCollection {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationRoleTCollection();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IApplicationRoleTCollection {
    value?: ApplicationRole[] | undefined;
}

export class ApplicationUser implements IApplicationUser {
    id?: string | undefined;
    userName?: string | undefined;
    normalizedUserName?: string | undefined;
    email?: string | undefined;
    normalizedEmail?: string | undefined;
    emailConfirmed?: boolean;
    passwordHash?: string | undefined;
    securityStamp?: string | undefined;
    concurrencyStamp?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
    twoFactorEnabled?: boolean;
    lockoutEnd?: Date | undefined;
    lockoutEnabled?: boolean;
    accessFailedCount?: number;
    photo?: string | undefined;
    sex?: number;
    desc?: string | undefined;
    startWorkDate?: Date | undefined;
    name?: string | undefined;
    order?: number;

    constructor(data?: IApplicationUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.normalizedUserName = _data["normalizedUserName"];
            this.email = _data["email"];
            this.normalizedEmail = _data["normalizedEmail"];
            this.emailConfirmed = _data["emailConfirmed"];
            this.passwordHash = _data["passwordHash"];
            this.securityStamp = _data["securityStamp"];
            this.concurrencyStamp = _data["concurrencyStamp"];
            this.phoneNumber = _data["phoneNumber"];
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"];
            this.twoFactorEnabled = _data["twoFactorEnabled"];
            this.lockoutEnd = _data["lockoutEnd"] ? new Date(_data["lockoutEnd"].toString()) : <any>undefined;
            this.lockoutEnabled = _data["lockoutEnabled"];
            this.accessFailedCount = _data["accessFailedCount"];
            this.photo = _data["photo"];
            this.sex = _data["sex"];
            this.desc = _data["desc"];
            this.startWorkDate = _data["startWorkDate"] ? new Date(_data["startWorkDate"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.order = _data["order"];
        }
    }

    static fromJS(data: any): ApplicationUser {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["normalizedUserName"] = this.normalizedUserName;
        data["email"] = this.email;
        data["normalizedEmail"] = this.normalizedEmail;
        data["emailConfirmed"] = this.emailConfirmed;
        data["passwordHash"] = this.passwordHash;
        data["securityStamp"] = this.securityStamp;
        data["concurrencyStamp"] = this.concurrencyStamp;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
        data["twoFactorEnabled"] = this.twoFactorEnabled;
        data["lockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>undefined;
        data["lockoutEnabled"] = this.lockoutEnabled;
        data["accessFailedCount"] = this.accessFailedCount;
        data["photo"] = this.photo;
        data["sex"] = this.sex;
        data["desc"] = this.desc;
        data["startWorkDate"] = this.startWorkDate ? this.startWorkDate.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["order"] = this.order;
        return data; 
    }
}

export interface IApplicationUser {
    id?: string | undefined;
    userName?: string | undefined;
    normalizedUserName?: string | undefined;
    email?: string | undefined;
    normalizedEmail?: string | undefined;
    emailConfirmed?: boolean;
    passwordHash?: string | undefined;
    securityStamp?: string | undefined;
    concurrencyStamp?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
    twoFactorEnabled?: boolean;
    lockoutEnd?: Date | undefined;
    lockoutEnabled?: boolean;
    accessFailedCount?: number;
    photo?: string | undefined;
    sex?: number;
    desc?: string | undefined;
    startWorkDate?: Date | undefined;
    name?: string | undefined;
    order?: number;
}

export class AskForLeaveForm implements IAskForLeaveForm {
    id?: string | undefined;
    /** 标题 */
    title?: string | undefined;
    userName?: string | undefined;
    userDisplayName?: string | undefined;
    userDepartment?: string | undefined;
    /** 职务职级 */
    job?: string | undefined;
    /** 参加工作时间 */
    startWorkDateTime?: string | undefined;
    /** 休假类型 */
    type?: string | undefined;
    /** 休假年度 */
    year?: number;
    /** 批次 */
    batch?: string | undefined;
    beginDateTime?: string | undefined;
    endDateTime?: string | undefined;
    days?: number;
    /** 休假去向 */
    address?: string | undefined;
    /** 备注 */
    remark?: string | undefined;
    /** 部门领导是否确认 */
    isDepartmentLeaderConfirm?: boolean;
    businessForm?: BusinessForm;

    constructor(data?: IAskForLeaveForm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.userName = _data["userName"];
            this.userDisplayName = _data["userDisplayName"];
            this.userDepartment = _data["userDepartment"];
            this.job = _data["job"];
            this.startWorkDateTime = _data["startWorkDateTime"];
            this.type = _data["type"];
            this.year = _data["year"];
            this.batch = _data["batch"];
            this.beginDateTime = _data["beginDateTime"];
            this.endDateTime = _data["endDateTime"];
            this.days = _data["days"];
            this.address = _data["address"];
            this.remark = _data["remark"];
            this.isDepartmentLeaderConfirm = _data["isDepartmentLeaderConfirm"];
            this.businessForm = _data["businessForm"] ? BusinessForm.fromJS(_data["businessForm"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AskForLeaveForm {
        data = typeof data === 'object' ? data : {};
        let result = new AskForLeaveForm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["userName"] = this.userName;
        data["userDisplayName"] = this.userDisplayName;
        data["userDepartment"] = this.userDepartment;
        data["job"] = this.job;
        data["startWorkDateTime"] = this.startWorkDateTime;
        data["type"] = this.type;
        data["year"] = this.year;
        data["batch"] = this.batch;
        data["beginDateTime"] = this.beginDateTime;
        data["endDateTime"] = this.endDateTime;
        data["days"] = this.days;
        data["address"] = this.address;
        data["remark"] = this.remark;
        data["isDepartmentLeaderConfirm"] = this.isDepartmentLeaderConfirm;
        data["businessForm"] = this.businessForm ? this.businessForm.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IAskForLeaveForm {
    id?: string | undefined;
    /** 标题 */
    title?: string | undefined;
    userName?: string | undefined;
    userDisplayName?: string | undefined;
    userDepartment?: string | undefined;
    /** 职务职级 */
    job?: string | undefined;
    /** 参加工作时间 */
    startWorkDateTime?: string | undefined;
    /** 休假类型 */
    type?: string | undefined;
    /** 休假年度 */
    year?: number;
    /** 批次 */
    batch?: string | undefined;
    beginDateTime?: string | undefined;
    endDateTime?: string | undefined;
    days?: number;
    /** 休假去向 */
    address?: string | undefined;
    /** 备注 */
    remark?: string | undefined;
    /** 部门领导是否确认 */
    isDepartmentLeaderConfirm?: boolean;
    businessForm?: BusinessForm;
}

export class AskForLeaveFormTCollectionWithPagination implements IAskForLeaveFormTCollectionWithPagination {
    value?: AskForLeaveForm[] | undefined;
    total?: number;

    constructor(data?: IAskForLeaveFormTCollectionWithPagination) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(AskForLeaveForm.fromJS(item));
            }
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): AskForLeaveFormTCollectionWithPagination {
        data = typeof data === 'object' ? data : {};
        let result = new AskForLeaveFormTCollectionWithPagination();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        data["total"] = this.total;
        return data; 
    }
}

export interface IAskForLeaveFormTCollectionWithPagination {
    value?: AskForLeaveForm[] | undefined;
    total?: number;
}

export class Assembly implements IAssembly {
    readonly definedTypes?: TypeInfo[];
    readonly exportedTypes?: Type[];
    readonly codeBase?: string | undefined;
    entryPoint?: MethodInfo;
    readonly fullName?: string | undefined;
    readonly imageRuntimeVersion?: string;
    readonly isDynamic?: boolean;
    readonly location?: string;
    readonly reflectionOnly?: boolean;
    readonly isCollectible?: boolean;
    readonly isFullyTrusted?: boolean;
    readonly customAttributes?: CustomAttributeData[];
    readonly escapedCodeBase?: string;
    manifestModule?: Module;
    readonly modules?: Module[];
    readonly globalAssemblyCache?: boolean;
    readonly hostContext?: number;
    securityRuleSet?: SecurityRuleSet;

    constructor(data?: IAssembly) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["definedTypes"])) {
                (<any>this).definedTypes = [] as any;
                for (let item of _data["definedTypes"])
                    (<any>this).definedTypes!.push(TypeInfo.fromJS(item));
            }
            if (Array.isArray(_data["exportedTypes"])) {
                (<any>this).exportedTypes = [] as any;
                for (let item of _data["exportedTypes"])
                    (<any>this).exportedTypes!.push(Type.fromJS(item));
            }
            (<any>this).codeBase = _data["codeBase"];
            this.entryPoint = _data["entryPoint"] ? MethodInfo.fromJS(_data["entryPoint"]) : <any>undefined;
            (<any>this).fullName = _data["fullName"];
            (<any>this).imageRuntimeVersion = _data["imageRuntimeVersion"];
            (<any>this).isDynamic = _data["isDynamic"];
            (<any>this).location = _data["location"];
            (<any>this).reflectionOnly = _data["reflectionOnly"];
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).isFullyTrusted = _data["isFullyTrusted"];
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).escapedCodeBase = _data["escapedCodeBase"];
            this.manifestModule = _data["manifestModule"] ? Module.fromJS(_data["manifestModule"]) : <any>undefined;
            if (Array.isArray(_data["modules"])) {
                (<any>this).modules = [] as any;
                for (let item of _data["modules"])
                    (<any>this).modules!.push(Module.fromJS(item));
            }
            (<any>this).globalAssemblyCache = _data["globalAssemblyCache"];
            (<any>this).hostContext = _data["hostContext"];
            this.securityRuleSet = _data["securityRuleSet"];
        }
    }

    static fromJS(data: any): Assembly {
        data = typeof data === 'object' ? data : {};
        let result = new Assembly();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.definedTypes)) {
            data["definedTypes"] = [];
            for (let item of this.definedTypes)
                data["definedTypes"].push(item.toJSON());
        }
        if (Array.isArray(this.exportedTypes)) {
            data["exportedTypes"] = [];
            for (let item of this.exportedTypes)
                data["exportedTypes"].push(item.toJSON());
        }
        data["codeBase"] = this.codeBase;
        data["entryPoint"] = this.entryPoint ? this.entryPoint.toJSON() : <any>undefined;
        data["fullName"] = this.fullName;
        data["imageRuntimeVersion"] = this.imageRuntimeVersion;
        data["isDynamic"] = this.isDynamic;
        data["location"] = this.location;
        data["reflectionOnly"] = this.reflectionOnly;
        data["isCollectible"] = this.isCollectible;
        data["isFullyTrusted"] = this.isFullyTrusted;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["escapedCodeBase"] = this.escapedCodeBase;
        data["manifestModule"] = this.manifestModule ? this.manifestModule.toJSON() : <any>undefined;
        if (Array.isArray(this.modules)) {
            data["modules"] = [];
            for (let item of this.modules)
                data["modules"].push(item.toJSON());
        }
        data["globalAssemblyCache"] = this.globalAssemblyCache;
        data["hostContext"] = this.hostContext;
        data["securityRuleSet"] = this.securityRuleSet;
        return data; 
    }
}

export interface IAssembly {
    definedTypes?: TypeInfo[];
    exportedTypes?: Type[];
    codeBase?: string | undefined;
    entryPoint?: MethodInfo;
    fullName?: string | undefined;
    imageRuntimeVersion?: string;
    isDynamic?: boolean;
    location?: string;
    reflectionOnly?: boolean;
    isCollectible?: boolean;
    isFullyTrusted?: boolean;
    customAttributes?: CustomAttributeData[];
    escapedCodeBase?: string;
    manifestModule?: Module;
    modules?: Module[];
    globalAssemblyCache?: boolean;
    hostContext?: number;
    securityRuleSet?: SecurityRuleSet;
}

export class AssigneeUser implements IAssigneeUser {
    userName?: string | undefined;
    name?: string | undefined;

    constructor(data?: IAssigneeUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): AssigneeUser {
        data = typeof data === 'object' ? data : {};
        let result = new AssigneeUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        return data; 
    }
}

export interface IAssigneeUser {
    userName?: string | undefined;
    name?: string | undefined;
}

export class AssigneeUserGroup implements IAssigneeUserGroup {
    id?: number;
    activityOutgoingUsersConfigId?: number;
    nameType?: AssigneeUserGroupNameType;
    name?: string | undefined;
    isSameDepartment?: boolean;
    isShowWhenCurUserInUserGroup?: boolean;

    constructor(data?: IAssigneeUserGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.activityOutgoingUsersConfigId = _data["activityOutgoingUsersConfigId"];
            this.nameType = _data["nameType"];
            this.name = _data["name"];
            this.isSameDepartment = _data["isSameDepartment"];
            this.isShowWhenCurUserInUserGroup = _data["isShowWhenCurUserInUserGroup"];
        }
    }

    static fromJS(data: any): AssigneeUserGroup {
        data = typeof data === 'object' ? data : {};
        let result = new AssigneeUserGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["activityOutgoingUsersConfigId"] = this.activityOutgoingUsersConfigId;
        data["nameType"] = this.nameType;
        data["name"] = this.name;
        data["isSameDepartment"] = this.isSameDepartment;
        data["isShowWhenCurUserInUserGroup"] = this.isShowWhenCurUserInUserGroup;
        return data; 
    }
}

export interface IAssigneeUserGroup {
    id?: number;
    activityOutgoingUsersConfigId?: number;
    nameType?: AssigneeUserGroupNameType;
    name?: string | undefined;
    isSameDepartment?: boolean;
    isShowWhenCurUserInUserGroup?: boolean;
}

export enum AssigneeUserGroupNameType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class Attachment implements IAttachment {
    id?: string | undefined;
    name?: string | undefined;
    size?: number;

    constructor(data?: IAttachment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.size = _data["size"];
        }
    }

    static fromJS(data: any): Attachment {
        data = typeof data === 'object' ? data : {};
        let result = new Attachment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["size"] = this.size;
        return data; 
    }
}

export interface IAttachment {
    id?: string | undefined;
    name?: string | undefined;
    size?: number;
}

export class AttachmentManagerItem implements IAttachmentManagerItem {
    id?: string | undefined;
    businessKey?: string | undefined;
    originFileName?: string | undefined;
    humanizeBytesLength?: string | undefined;
    formTitle?: string | undefined;
    processDefKey?: string | undefined;
    processDefName?: string | undefined;
    createDateTimeFormat?: string | undefined;
    displayDepartment?: string | undefined;

    constructor(data?: IAttachmentManagerItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.businessKey = _data["businessKey"];
            this.originFileName = _data["originFileName"];
            this.humanizeBytesLength = _data["humanizeBytesLength"];
            this.formTitle = _data["formTitle"];
            this.processDefKey = _data["processDefKey"];
            this.processDefName = _data["processDefName"];
            this.createDateTimeFormat = _data["createDateTimeFormat"];
            this.displayDepartment = _data["displayDepartment"];
        }
    }

    static fromJS(data: any): AttachmentManagerItem {
        data = typeof data === 'object' ? data : {};
        let result = new AttachmentManagerItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["businessKey"] = this.businessKey;
        data["originFileName"] = this.originFileName;
        data["humanizeBytesLength"] = this.humanizeBytesLength;
        data["formTitle"] = this.formTitle;
        data["processDefKey"] = this.processDefKey;
        data["processDefName"] = this.processDefName;
        data["createDateTimeFormat"] = this.createDateTimeFormat;
        data["displayDepartment"] = this.displayDepartment;
        return data; 
    }
}

export interface IAttachmentManagerItem {
    id?: string | undefined;
    businessKey?: string | undefined;
    originFileName?: string | undefined;
    humanizeBytesLength?: string | undefined;
    formTitle?: string | undefined;
    processDefKey?: string | undefined;
    processDefName?: string | undefined;
    createDateTimeFormat?: string | undefined;
    displayDepartment?: string | undefined;
}

export class AttachmentManagerItemTCollectionWithPagination implements IAttachmentManagerItemTCollectionWithPagination {
    value?: AttachmentManagerItem[] | undefined;
    total?: number;

    constructor(data?: IAttachmentManagerItemTCollectionWithPagination) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(AttachmentManagerItem.fromJS(item));
            }
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): AttachmentManagerItemTCollectionWithPagination {
        data = typeof data === 'object' ? data : {};
        let result = new AttachmentManagerItemTCollectionWithPagination();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        data["total"] = this.total;
        return data; 
    }
}

export interface IAttachmentManagerItemTCollectionWithPagination {
    value?: AttachmentManagerItem[] | undefined;
    total?: number;
}

export class BusinessForm implements IBusinessForm {
    id?: number;
    businessKey?: string | undefined;
    externalSystemBusinessKey?: string | undefined;
    xmlFields?: string | undefined;
    fieldItems?: FieldItem[] | undefined;
    processDefId?: string | undefined;
    processDefKey?: string | undefined;
    processDefName?: string | undefined;
    title?: string | undefined;
    drafterUserName?: string | undefined;
    drafterName?: string | undefined;
    drafterDepartment?: string | undefined;
    maxDueEndDateTime?: Date | undefined;
    createDateTime?: Date | undefined;
    lastEditorUserName?: string | undefined;
    lastEditDateTime?: Date | undefined;
    customNumber1?: string | undefined;
    customNumber2?: string | undefined;
    customNumber3?: string | undefined;
    tag?: string | undefined;
    hidden?: boolean | undefined;

    constructor(data?: IBusinessForm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.businessKey = _data["businessKey"];
            this.externalSystemBusinessKey = _data["externalSystemBusinessKey"];
            this.xmlFields = _data["xmlFields"];
            if (Array.isArray(_data["fieldItems"])) {
                this.fieldItems = [] as any;
                for (let item of _data["fieldItems"])
                    this.fieldItems!.push(FieldItem.fromJS(item));
            }
            this.processDefId = _data["processDefId"];
            this.processDefKey = _data["processDefKey"];
            this.processDefName = _data["processDefName"];
            this.title = _data["title"];
            this.drafterUserName = _data["drafterUserName"];
            this.drafterName = _data["drafterName"];
            this.drafterDepartment = _data["drafterDepartment"];
            this.maxDueEndDateTime = _data["maxDueEndDateTime"] ? new Date(_data["maxDueEndDateTime"].toString()) : <any>undefined;
            this.createDateTime = _data["createDateTime"] ? new Date(_data["createDateTime"].toString()) : <any>undefined;
            this.lastEditorUserName = _data["lastEditorUserName"];
            this.lastEditDateTime = _data["lastEditDateTime"] ? new Date(_data["lastEditDateTime"].toString()) : <any>undefined;
            this.customNumber1 = _data["customNumber1"];
            this.customNumber2 = _data["customNumber2"];
            this.customNumber3 = _data["customNumber3"];
            this.tag = _data["tag"];
            this.hidden = _data["hidden"];
        }
    }

    static fromJS(data: any): BusinessForm {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessForm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["businessKey"] = this.businessKey;
        data["externalSystemBusinessKey"] = this.externalSystemBusinessKey;
        data["xmlFields"] = this.xmlFields;
        if (Array.isArray(this.fieldItems)) {
            data["fieldItems"] = [];
            for (let item of this.fieldItems)
                data["fieldItems"].push(item.toJSON());
        }
        data["processDefId"] = this.processDefId;
        data["processDefKey"] = this.processDefKey;
        data["processDefName"] = this.processDefName;
        data["title"] = this.title;
        data["drafterUserName"] = this.drafterUserName;
        data["drafterName"] = this.drafterName;
        data["drafterDepartment"] = this.drafterDepartment;
        data["maxDueEndDateTime"] = this.maxDueEndDateTime ? this.maxDueEndDateTime.toISOString() : <any>undefined;
        data["createDateTime"] = this.createDateTime ? this.createDateTime.toISOString() : <any>undefined;
        data["lastEditorUserName"] = this.lastEditorUserName;
        data["lastEditDateTime"] = this.lastEditDateTime ? this.lastEditDateTime.toISOString() : <any>undefined;
        data["customNumber1"] = this.customNumber1;
        data["customNumber2"] = this.customNumber2;
        data["customNumber3"] = this.customNumber3;
        data["tag"] = this.tag;
        data["hidden"] = this.hidden;
        return data; 
    }
}

export interface IBusinessForm {
    id?: number;
    businessKey?: string | undefined;
    externalSystemBusinessKey?: string | undefined;
    xmlFields?: string | undefined;
    fieldItems?: FieldItem[] | undefined;
    processDefId?: string | undefined;
    processDefKey?: string | undefined;
    processDefName?: string | undefined;
    title?: string | undefined;
    drafterUserName?: string | undefined;
    drafterName?: string | undefined;
    drafterDepartment?: string | undefined;
    maxDueEndDateTime?: Date | undefined;
    createDateTime?: Date | undefined;
    lastEditorUserName?: string | undefined;
    lastEditDateTime?: Date | undefined;
    customNumber1?: string | undefined;
    customNumber2?: string | undefined;
    customNumber3?: string | undefined;
    tag?: string | undefined;
    hidden?: boolean | undefined;
}

export enum CallingConventions {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _32 = 32,
    _64 = 64,
}

export class CCSPItem implements ICCSPItem {
    createDateTimeFormat?: string | undefined;
    persons?: string | undefined;
    startDateTimeFormat?: string | undefined;
    endDateTimeFormat?: string | undefined;
    personCount?: number;
    title?: string | undefined;
    businessKey?: string | undefined;
    unit?: string | undefined;

    constructor(data?: ICCSPItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createDateTimeFormat = _data["createDateTimeFormat"];
            this.persons = _data["persons"];
            this.startDateTimeFormat = _data["startDateTimeFormat"];
            this.endDateTimeFormat = _data["endDateTimeFormat"];
            this.personCount = _data["personCount"];
            this.title = _data["title"];
            this.businessKey = _data["businessKey"];
            this.unit = _data["unit"];
        }
    }

    static fromJS(data: any): CCSPItem {
        data = typeof data === 'object' ? data : {};
        let result = new CCSPItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createDateTimeFormat"] = this.createDateTimeFormat;
        data["persons"] = this.persons;
        data["startDateTimeFormat"] = this.startDateTimeFormat;
        data["endDateTimeFormat"] = this.endDateTimeFormat;
        data["personCount"] = this.personCount;
        data["title"] = this.title;
        data["businessKey"] = this.businessKey;
        data["unit"] = this.unit;
        return data; 
    }
}

export interface ICCSPItem {
    createDateTimeFormat?: string | undefined;
    persons?: string | undefined;
    startDateTimeFormat?: string | undefined;
    endDateTimeFormat?: string | undefined;
    personCount?: number;
    title?: string | undefined;
    businessKey?: string | undefined;
    unit?: string | undefined;
}

export class CCSPReportViewModel implements ICCSPReportViewModel {
    dailyCCSPItems?: DailyCCSPItem[] | undefined;
    totalPersonCount?: number;

    constructor(data?: ICCSPReportViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["dailyCCSPItems"])) {
                this.dailyCCSPItems = [] as any;
                for (let item of _data["dailyCCSPItems"])
                    this.dailyCCSPItems!.push(DailyCCSPItem.fromJS(item));
            }
            this.totalPersonCount = _data["totalPersonCount"];
        }
    }

    static fromJS(data: any): CCSPReportViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new CCSPReportViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.dailyCCSPItems)) {
            data["dailyCCSPItems"] = [];
            for (let item of this.dailyCCSPItems)
                data["dailyCCSPItems"].push(item.toJSON());
        }
        data["totalPersonCount"] = this.totalPersonCount;
        return data; 
    }
}

export interface ICCSPReportViewModel {
    dailyCCSPItems?: DailyCCSPItem[] | undefined;
    totalPersonCount?: number;
}

export class Claim implements IClaim {
    issuer?: string;
    originalIssuer?: string;
    readonly properties?: { [key: string]: string; };
    subject?: ClaimsIdentity;
    type?: string;
    value?: string;
    valueType?: string;

    constructor(data?: IClaim) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.issuer = _data["issuer"];
            this.originalIssuer = _data["originalIssuer"];
            if (_data["properties"]) {
                (<any>this).properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>(<any>this).properties)![key] = _data["properties"][key];
                }
            }
            this.subject = _data["subject"] ? ClaimsIdentity.fromJS(_data["subject"]) : <any>undefined;
            this.type = _data["type"];
            this.value = _data["value"];
            this.valueType = _data["valueType"];
        }
    }

    static fromJS(data: any): Claim {
        data = typeof data === 'object' ? data : {};
        let result = new Claim();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["issuer"] = this.issuer;
        data["originalIssuer"] = this.originalIssuer;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = this.properties[key];
            }
        }
        data["subject"] = this.subject ? this.subject.toJSON() : <any>undefined;
        data["type"] = this.type;
        data["value"] = this.value;
        data["valueType"] = this.valueType;
        return data; 
    }
}

export interface IClaim {
    issuer?: string;
    originalIssuer?: string;
    properties?: { [key: string]: string; };
    subject?: ClaimsIdentity;
    type?: string;
    value?: string;
    valueType?: string;
}

export class ClaimsIdentity implements IClaimsIdentity {
    authenticationType?: string | undefined;
    readonly isAuthenticated?: boolean;
    actor?: ClaimsIdentity;
    bootstrapContext?: any | undefined;
    claims?: Claim[];
    label?: string | undefined;
    readonly name?: string | undefined;
    readonly nameClaimType?: string;
    readonly roleClaimType?: string;

    constructor(data?: IClaimsIdentity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.authenticationType = _data["authenticationType"];
            (<any>this).isAuthenticated = _data["isAuthenticated"];
            this.actor = _data["actor"] ? ClaimsIdentity.fromJS(_data["actor"]) : <any>undefined;
            this.bootstrapContext = _data["bootstrapContext"];
            if (Array.isArray(_data["claims"])) {
                this.claims = [] as any;
                for (let item of _data["claims"])
                    this.claims!.push(Claim.fromJS(item));
            }
            this.label = _data["label"];
            (<any>this).name = _data["name"];
            (<any>this).nameClaimType = _data["nameClaimType"];
            (<any>this).roleClaimType = _data["roleClaimType"];
        }
    }

    static fromJS(data: any): ClaimsIdentity {
        data = typeof data === 'object' ? data : {};
        let result = new ClaimsIdentity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authenticationType"] = this.authenticationType;
        data["isAuthenticated"] = this.isAuthenticated;
        data["actor"] = this.actor ? this.actor.toJSON() : <any>undefined;
        data["bootstrapContext"] = this.bootstrapContext;
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item.toJSON());
        }
        data["label"] = this.label;
        data["name"] = this.name;
        data["nameClaimType"] = this.nameClaimType;
        data["roleClaimType"] = this.roleClaimType;
        return data; 
    }
}

export interface IClaimsIdentity {
    authenticationType?: string | undefined;
    isAuthenticated?: boolean;
    actor?: ClaimsIdentity;
    bootstrapContext?: any | undefined;
    claims?: Claim[];
    label?: string | undefined;
    name?: string | undefined;
    nameClaimType?: string;
    roleClaimType?: string;
}

export class CompleteTaskForReadOnlyForm implements ICompleteTaskForReadOnlyForm {
    taskId?: string | undefined;
    opinion?: string | undefined;
    disposeItems?: DisposeItem[] | undefined;

    constructor(data?: ICompleteTaskForReadOnlyForm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.taskId = _data["taskId"];
            this.opinion = _data["opinion"];
            if (Array.isArray(_data["disposeItems"])) {
                this.disposeItems = [] as any;
                for (let item of _data["disposeItems"])
                    this.disposeItems!.push(DisposeItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CompleteTaskForReadOnlyForm {
        data = typeof data === 'object' ? data : {};
        let result = new CompleteTaskForReadOnlyForm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taskId"] = this.taskId;
        data["opinion"] = this.opinion;
        if (Array.isArray(this.disposeItems)) {
            data["disposeItems"] = [];
            for (let item of this.disposeItems)
                data["disposeItems"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICompleteTaskForReadOnlyForm {
    taskId?: string | undefined;
    opinion?: string | undefined;
    disposeItems?: DisposeItem[] | undefined;
}

/** 完成任务视图模型 */
export class CompleteTaskViewModel implements ICompleteTaskViewModel {
    taskId?: string | undefined;
    opinion?: string | undefined;
    title!: string;
    maxEndDateTime?: string | undefined;
    formFields?: FormField[] | undefined;
    disposeItems?: DisposeItem[] | undefined;
    variables?: { [key: string]: any; } | undefined;
    variablesLocal?: { [key: string]: any; } | undefined;

    constructor(data?: ICompleteTaskViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.taskId = _data["taskId"];
            this.opinion = _data["opinion"];
            this.title = _data["title"];
            this.maxEndDateTime = _data["maxEndDateTime"];
            if (Array.isArray(_data["formFields"])) {
                this.formFields = [] as any;
                for (let item of _data["formFields"])
                    this.formFields!.push(FormField.fromJS(item));
            }
            if (Array.isArray(_data["disposeItems"])) {
                this.disposeItems = [] as any;
                for (let item of _data["disposeItems"])
                    this.disposeItems!.push(DisposeItem.fromJS(item));
            }
            if (_data["variables"]) {
                this.variables = {} as any;
                for (let key in _data["variables"]) {
                    if (_data["variables"].hasOwnProperty(key))
                        (<any>this.variables)![key] = _data["variables"][key];
                }
            }
            if (_data["variablesLocal"]) {
                this.variablesLocal = {} as any;
                for (let key in _data["variablesLocal"]) {
                    if (_data["variablesLocal"].hasOwnProperty(key))
                        (<any>this.variablesLocal)![key] = _data["variablesLocal"][key];
                }
            }
        }
    }

    static fromJS(data: any): CompleteTaskViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new CompleteTaskViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taskId"] = this.taskId;
        data["opinion"] = this.opinion;
        data["title"] = this.title;
        data["maxEndDateTime"] = this.maxEndDateTime;
        if (Array.isArray(this.formFields)) {
            data["formFields"] = [];
            for (let item of this.formFields)
                data["formFields"].push(item.toJSON());
        }
        if (Array.isArray(this.disposeItems)) {
            data["disposeItems"] = [];
            for (let item of this.disposeItems)
                data["disposeItems"].push(item.toJSON());
        }
        if (this.variables) {
            data["variables"] = {};
            for (let key in this.variables) {
                if (this.variables.hasOwnProperty(key))
                    (<any>data["variables"])[key] = this.variables[key];
            }
        }
        if (this.variablesLocal) {
            data["variablesLocal"] = {};
            for (let key in this.variablesLocal) {
                if (this.variablesLocal.hasOwnProperty(key))
                    (<any>data["variablesLocal"])[key] = this.variablesLocal[key];
            }
        }
        return data; 
    }
}

/** 完成任务视图模型 */
export interface ICompleteTaskViewModel {
    taskId?: string | undefined;
    opinion?: string | undefined;
    title: string;
    maxEndDateTime?: string | undefined;
    formFields?: FormField[] | undefined;
    disposeItems?: DisposeItem[] | undefined;
    variables?: { [key: string]: any; } | undefined;
    variablesLocal?: { [key: string]: any; } | undefined;
}

export class ConstructorInfo implements IConstructorInfo {
    readonly name?: string;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    readonly customAttributes?: CustomAttributeData[];
    readonly isCollectible?: boolean;
    readonly metadataToken?: number;
    attributes?: MethodAttributes;
    methodImplementationFlags?: MethodImplAttributes;
    callingConvention?: CallingConventions;
    readonly isAbstract?: boolean;
    readonly isConstructor?: boolean;
    readonly isFinal?: boolean;
    readonly isHideBySig?: boolean;
    readonly isSpecialName?: boolean;
    readonly isStatic?: boolean;
    readonly isVirtual?: boolean;
    readonly isAssembly?: boolean;
    readonly isFamily?: boolean;
    readonly isFamilyAndAssembly?: boolean;
    readonly isFamilyOrAssembly?: boolean;
    readonly isPrivate?: boolean;
    readonly isPublic?: boolean;
    readonly isConstructedGenericMethod?: boolean;
    readonly isGenericMethod?: boolean;
    readonly isGenericMethodDefinition?: boolean;
    readonly containsGenericParameters?: boolean;
    methodHandle?: RuntimeMethodHandle;
    readonly isSecurityCritical?: boolean;
    readonly isSecuritySafeCritical?: boolean;
    readonly isSecurityTransparent?: boolean;
    memberType?: MemberTypes;

    constructor(data?: IConstructorInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["name"];
            this.declaringType = _data["declaringType"] ? Type.fromJS(_data["declaringType"]) : <any>undefined;
            this.reflectedType = _data["reflectedType"] ? Type.fromJS(_data["reflectedType"]) : <any>undefined;
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
            this.attributes = _data["attributes"];
            this.methodImplementationFlags = _data["methodImplementationFlags"];
            this.callingConvention = _data["callingConvention"];
            (<any>this).isAbstract = _data["isAbstract"];
            (<any>this).isConstructor = _data["isConstructor"];
            (<any>this).isFinal = _data["isFinal"];
            (<any>this).isHideBySig = _data["isHideBySig"];
            (<any>this).isSpecialName = _data["isSpecialName"];
            (<any>this).isStatic = _data["isStatic"];
            (<any>this).isVirtual = _data["isVirtual"];
            (<any>this).isAssembly = _data["isAssembly"];
            (<any>this).isFamily = _data["isFamily"];
            (<any>this).isFamilyAndAssembly = _data["isFamilyAndAssembly"];
            (<any>this).isFamilyOrAssembly = _data["isFamilyOrAssembly"];
            (<any>this).isPrivate = _data["isPrivate"];
            (<any>this).isPublic = _data["isPublic"];
            (<any>this).isConstructedGenericMethod = _data["isConstructedGenericMethod"];
            (<any>this).isGenericMethod = _data["isGenericMethod"];
            (<any>this).isGenericMethodDefinition = _data["isGenericMethodDefinition"];
            (<any>this).containsGenericParameters = _data["containsGenericParameters"];
            this.methodHandle = _data["methodHandle"] ? RuntimeMethodHandle.fromJS(_data["methodHandle"]) : <any>undefined;
            (<any>this).isSecurityCritical = _data["isSecurityCritical"];
            (<any>this).isSecuritySafeCritical = _data["isSecuritySafeCritical"];
            (<any>this).isSecurityTransparent = _data["isSecurityTransparent"];
            this.memberType = _data["memberType"];
        }
    }

    static fromJS(data: any): ConstructorInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ConstructorInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["declaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["reflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        data["attributes"] = this.attributes;
        data["methodImplementationFlags"] = this.methodImplementationFlags;
        data["callingConvention"] = this.callingConvention;
        data["isAbstract"] = this.isAbstract;
        data["isConstructor"] = this.isConstructor;
        data["isFinal"] = this.isFinal;
        data["isHideBySig"] = this.isHideBySig;
        data["isSpecialName"] = this.isSpecialName;
        data["isStatic"] = this.isStatic;
        data["isVirtual"] = this.isVirtual;
        data["isAssembly"] = this.isAssembly;
        data["isFamily"] = this.isFamily;
        data["isFamilyAndAssembly"] = this.isFamilyAndAssembly;
        data["isFamilyOrAssembly"] = this.isFamilyOrAssembly;
        data["isPrivate"] = this.isPrivate;
        data["isPublic"] = this.isPublic;
        data["isConstructedGenericMethod"] = this.isConstructedGenericMethod;
        data["isGenericMethod"] = this.isGenericMethod;
        data["isGenericMethodDefinition"] = this.isGenericMethodDefinition;
        data["containsGenericParameters"] = this.containsGenericParameters;
        data["methodHandle"] = this.methodHandle ? this.methodHandle.toJSON() : <any>undefined;
        data["isSecurityCritical"] = this.isSecurityCritical;
        data["isSecuritySafeCritical"] = this.isSecuritySafeCritical;
        data["isSecurityTransparent"] = this.isSecurityTransparent;
        data["memberType"] = this.memberType;
        return data; 
    }
}

export interface IConstructorInfo {
    name?: string;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    customAttributes?: CustomAttributeData[];
    isCollectible?: boolean;
    metadataToken?: number;
    attributes?: MethodAttributes;
    methodImplementationFlags?: MethodImplAttributes;
    callingConvention?: CallingConventions;
    isAbstract?: boolean;
    isConstructor?: boolean;
    isFinal?: boolean;
    isHideBySig?: boolean;
    isSpecialName?: boolean;
    isStatic?: boolean;
    isVirtual?: boolean;
    isAssembly?: boolean;
    isFamily?: boolean;
    isFamilyAndAssembly?: boolean;
    isFamilyOrAssembly?: boolean;
    isPrivate?: boolean;
    isPublic?: boolean;
    isConstructedGenericMethod?: boolean;
    isGenericMethod?: boolean;
    isGenericMethodDefinition?: boolean;
    containsGenericParameters?: boolean;
    methodHandle?: RuntimeMethodHandle;
    isSecurityCritical?: boolean;
    isSecuritySafeCritical?: boolean;
    isSecurityTransparent?: boolean;
    memberType?: MemberTypes;
}

export class CountItem implements ICountItem {
    processDefName?: string | undefined;
    count?: number;
    dateTime?: string | undefined;

    constructor(data?: ICountItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.processDefName = _data["processDefName"];
            this.count = _data["count"];
            this.dateTime = _data["dateTime"];
        }
    }

    static fromJS(data: any): CountItem {
        data = typeof data === 'object' ? data : {};
        let result = new CountItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["processDefName"] = this.processDefName;
        data["count"] = this.count;
        data["dateTime"] = this.dateTime;
        return data; 
    }
}

export interface ICountItem {
    processDefName?: string | undefined;
    count?: number;
    dateTime?: string | undefined;
}

export class CreateDepartmentDto implements ICreateDepartmentDto {
    name!: string;
    desc?: string | undefined;
    organizationId?: number;
    parentDepartmentId?: string | undefined;
    isVirtual?: boolean;

    constructor(data?: ICreateDepartmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.desc = _data["desc"];
            this.organizationId = _data["organizationId"];
            this.parentDepartmentId = _data["parentDepartmentId"];
            this.isVirtual = _data["isVirtual"];
        }
    }

    static fromJS(data: any): CreateDepartmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDepartmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["desc"] = this.desc;
        data["organizationId"] = this.organizationId;
        data["parentDepartmentId"] = this.parentDepartmentId;
        data["isVirtual"] = this.isVirtual;
        return data; 
    }
}

export interface ICreateDepartmentDto {
    name: string;
    desc?: string | undefined;
    organizationId?: number;
    parentDepartmentId?: string | undefined;
    isVirtual?: boolean;
}

export class CreateRoleDto implements ICreateRoleDto {
    name!: string;
    desc?: string | undefined;
    nonEditable?: boolean;

    constructor(data?: ICreateRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.desc = _data["desc"];
            this.nonEditable = _data["nonEditable"];
        }
    }

    static fromJS(data: any): CreateRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["desc"] = this.desc;
        data["nonEditable"] = this.nonEditable;
        return data; 
    }
}

export interface ICreateRoleDto {
    name: string;
    desc?: string | undefined;
    nonEditable?: boolean;
}

export class CreateUserDto implements ICreateUserDto {
    userName!: string;
    name!: string;
    password!: string;
    phoneNumber?: string | undefined;
    roles?: string[] | undefined;
    orgName?: string | undefined;
    departmentName?: string | undefined;

    constructor(data?: ICreateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.password = _data["password"];
            this.phoneNumber = _data["phoneNumber"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
            this.orgName = _data["orgName"];
            this.departmentName = _data["departmentName"];
        }
    }

    static fromJS(data: any): CreateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["password"] = this.password;
        data["phoneNumber"] = this.phoneNumber;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        data["orgName"] = this.orgName;
        data["departmentName"] = this.departmentName;
        return data; 
    }
}

export interface ICreateUserDto {
    userName: string;
    name: string;
    password: string;
    phoneNumber?: string | undefined;
    roles?: string[] | undefined;
    orgName?: string | undefined;
    departmentName?: string | undefined;
}

export class CreateUserGroupDto implements ICreateUserGroupDto {
    name!: string;
    desc?: string | undefined;
    order?: number;

    constructor(data?: ICreateUserGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.desc = _data["desc"];
            this.order = _data["order"];
        }
    }

    static fromJS(data: any): CreateUserGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["desc"] = this.desc;
        data["order"] = this.order;
        return data; 
    }
}

export interface ICreateUserGroupDto {
    name: string;
    desc?: string | undefined;
    order?: number;
}

export class CreateUserTaskDelegateViewModel implements ICreateUserTaskDelegateViewModel {
    fromUserName?: string | undefined;
    toUserName?: string | undefined;
    startDateTime?: Date | undefined;
    endDateTime?: Date | undefined;

    constructor(data?: ICreateUserTaskDelegateViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fromUserName = _data["fromUserName"];
            this.toUserName = _data["toUserName"];
            this.startDateTime = _data["startDateTime"] ? new Date(_data["startDateTime"].toString()) : <any>undefined;
            this.endDateTime = _data["endDateTime"] ? new Date(_data["endDateTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateUserTaskDelegateViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserTaskDelegateViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fromUserName"] = this.fromUserName;
        data["toUserName"] = this.toUserName;
        data["startDateTime"] = this.startDateTime ? this.startDateTime.toISOString() : <any>undefined;
        data["endDateTime"] = this.endDateTime ? this.endDateTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ICreateUserTaskDelegateViewModel {
    fromUserName?: string | undefined;
    toUserName?: string | undefined;
    startDateTime?: Date | undefined;
    endDateTime?: Date | undefined;
}

export class CustomAttributeData implements ICustomAttributeData {
    attributeType?: Type;
    constructor_?: ConstructorInfo;
    readonly constructorArguments?: CustomAttributeTypedArgument[];
    readonly namedArguments?: CustomAttributeNamedArgument[];

    constructor(data?: ICustomAttributeData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.attributeType = _data["attributeType"] ? Type.fromJS(_data["attributeType"]) : <any>undefined;
            this.constructor_ = _data["constructor"] ? ConstructorInfo.fromJS(_data["constructor"]) : <any>undefined;
            if (Array.isArray(_data["constructorArguments"])) {
                (<any>this).constructorArguments = [] as any;
                for (let item of _data["constructorArguments"])
                    (<any>this).constructorArguments!.push(CustomAttributeTypedArgument.fromJS(item));
            }
            if (Array.isArray(_data["namedArguments"])) {
                (<any>this).namedArguments = [] as any;
                for (let item of _data["namedArguments"])
                    (<any>this).namedArguments!.push(CustomAttributeNamedArgument.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CustomAttributeData {
        data = typeof data === 'object' ? data : {};
        let result = new CustomAttributeData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["attributeType"] = this.attributeType ? this.attributeType.toJSON() : <any>undefined;
        data["constructor"] = this.constructor_ ? this.constructor_.toJSON() : <any>undefined;
        if (Array.isArray(this.constructorArguments)) {
            data["constructorArguments"] = [];
            for (let item of this.constructorArguments)
                data["constructorArguments"].push(item.toJSON());
        }
        if (Array.isArray(this.namedArguments)) {
            data["namedArguments"] = [];
            for (let item of this.namedArguments)
                data["namedArguments"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICustomAttributeData {
    attributeType?: Type;
    constructor_?: ConstructorInfo;
    constructorArguments?: CustomAttributeTypedArgument[];
    namedArguments?: CustomAttributeNamedArgument[];
}

export class CustomAttributeNamedArgument implements ICustomAttributeNamedArgument {
    memberInfo?: MemberInfo;
    typedValue?: CustomAttributeTypedArgument;
    readonly memberName?: string;
    readonly isField?: boolean;

    constructor(data?: ICustomAttributeNamedArgument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberInfo = _data["memberInfo"] ? MemberInfo.fromJS(_data["memberInfo"]) : <any>undefined;
            this.typedValue = _data["typedValue"] ? CustomAttributeTypedArgument.fromJS(_data["typedValue"]) : <any>undefined;
            (<any>this).memberName = _data["memberName"];
            (<any>this).isField = _data["isField"];
        }
    }

    static fromJS(data: any): CustomAttributeNamedArgument {
        data = typeof data === 'object' ? data : {};
        let result = new CustomAttributeNamedArgument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberInfo"] = this.memberInfo ? this.memberInfo.toJSON() : <any>undefined;
        data["typedValue"] = this.typedValue ? this.typedValue.toJSON() : <any>undefined;
        data["memberName"] = this.memberName;
        data["isField"] = this.isField;
        return data; 
    }
}

export interface ICustomAttributeNamedArgument {
    memberInfo?: MemberInfo;
    typedValue?: CustomAttributeTypedArgument;
    memberName?: string;
    isField?: boolean;
}

export class CustomAttributeTypedArgument implements ICustomAttributeTypedArgument {
    argumentType?: Type;
    value?: any | undefined;

    constructor(data?: ICustomAttributeTypedArgument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.argumentType = _data["argumentType"] ? Type.fromJS(_data["argumentType"]) : <any>undefined;
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): CustomAttributeTypedArgument {
        data = typeof data === 'object' ? data : {};
        let result = new CustomAttributeTypedArgument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["argumentType"] = this.argumentType ? this.argumentType.toJSON() : <any>undefined;
        data["value"] = this.value;
        return data; 
    }
}

export interface ICustomAttributeTypedArgument {
    argumentType?: Type;
    value?: any | undefined;
}

export class DailyCCSPItem implements IDailyCCSPItem {
    dateTime?: Date;
    items?: CCSPItem[] | undefined;

    constructor(data?: IDailyCCSPItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dateTime = _data["dateTime"] ? new Date(_data["dateTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CCSPItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DailyCCSPItem {
        data = typeof data === 'object' ? data : {};
        let result = new DailyCCSPItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDailyCCSPItem {
    dateTime?: Date;
    items?: CCSPItem[] | undefined;
}

export class DateGroup implements IDateGroup {
    week?: string | undefined;
    dateTime?: string | undefined;
    items?: LeaderActivityItem[] | undefined;

    constructor(data?: IDateGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.week = _data["week"];
            this.dateTime = _data["dateTime"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LeaderActivityItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DateGroup {
        data = typeof data === 'object' ? data : {};
        let result = new DateGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["week"] = this.week;
        data["dateTime"] = this.dateTime;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDateGroup {
    week?: string | undefined;
    dateTime?: string | undefined;
    items?: LeaderActivityItem[] | undefined;
}

export class DateGroupTCollection implements IDateGroupTCollection {
    value?: DateGroup[] | undefined;

    constructor(data?: IDateGroupTCollection) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(DateGroup.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DateGroupTCollection {
        data = typeof data === 'object' ? data : {};
        let result = new DateGroupTCollection();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDateGroupTCollection {
    value?: DateGroup[] | undefined;
}

export class DealProcesseViewModel implements IDealProcesseViewModel {
    id?: number;
    activityName?: string | undefined;
    senderName?: string | undefined;
    opinion?: string | undefined;
    deteTime?: string | undefined;
    dispose?: string | undefined;
    /** 签收时间 */
    assigneeDateTimeFormat?: string | undefined;

    constructor(data?: IDealProcesseViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.activityName = _data["activityName"];
            this.senderName = _data["senderName"];
            this.opinion = _data["opinion"];
            this.deteTime = _data["deteTime"];
            this.dispose = _data["dispose"];
            this.assigneeDateTimeFormat = _data["assigneeDateTimeFormat"];
        }
    }

    static fromJS(data: any): DealProcesseViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new DealProcesseViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["activityName"] = this.activityName;
        data["senderName"] = this.senderName;
        data["opinion"] = this.opinion;
        data["deteTime"] = this.deteTime;
        data["dispose"] = this.dispose;
        data["assigneeDateTimeFormat"] = this.assigneeDateTimeFormat;
        return data; 
    }
}

export interface IDealProcesseViewModel {
    id?: number;
    activityName?: string | undefined;
    senderName?: string | undefined;
    opinion?: string | undefined;
    deteTime?: string | undefined;
    dispose?: string | undefined;
    /** 签收时间 */
    assigneeDateTimeFormat?: string | undefined;
}

export class DeleteProcessInstancceViewModel implements IDeleteProcessInstancceViewModel {
    processInstanceId?: string | undefined;
    deleteReason?: string | undefined;

    constructor(data?: IDeleteProcessInstancceViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.processInstanceId = _data["processInstanceId"];
            this.deleteReason = _data["deleteReason"];
        }
    }

    static fromJS(data: any): DeleteProcessInstancceViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteProcessInstancceViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["processInstanceId"] = this.processInstanceId;
        data["deleteReason"] = this.deleteReason;
        return data; 
    }
}

export interface IDeleteProcessInstancceViewModel {
    processInstanceId?: string | undefined;
    deleteReason?: string | undefined;
}

export class Department implements IDepartment {
    id?: string | undefined;
    organizationId?: number;
    name?: string | undefined;
    desc?: string | undefined;
    createDateTime?: Date;
    order?: number;
    parentDepartmentId?: string | undefined;
    isVirtual?: boolean;

    constructor(data?: IDepartment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.organizationId = _data["organizationId"];
            this.name = _data["name"];
            this.desc = _data["desc"];
            this.createDateTime = _data["createDateTime"] ? new Date(_data["createDateTime"].toString()) : <any>undefined;
            this.order = _data["order"];
            this.parentDepartmentId = _data["parentDepartmentId"];
            this.isVirtual = _data["isVirtual"];
        }
    }

    static fromJS(data: any): Department {
        data = typeof data === 'object' ? data : {};
        let result = new Department();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["organizationId"] = this.organizationId;
        data["name"] = this.name;
        data["desc"] = this.desc;
        data["createDateTime"] = this.createDateTime ? this.createDateTime.toISOString() : <any>undefined;
        data["order"] = this.order;
        data["parentDepartmentId"] = this.parentDepartmentId;
        data["isVirtual"] = this.isVirtual;
        return data; 
    }
}

export interface IDepartment {
    id?: string | undefined;
    organizationId?: number;
    name?: string | undefined;
    desc?: string | undefined;
    createDateTime?: Date;
    order?: number;
    parentDepartmentId?: string | undefined;
    isVirtual?: boolean;
}

export class DepartmentGroup implements IDepartmentGroup {
    key!: string;
    data!: DiyUser[];

    constructor(data?: IDepartmentGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(DiyUser.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DepartmentGroup {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDepartmentGroup {
    key: string;
    data: DiyUser[];
}

export class DepartmentTreeNode implements IDepartmentTreeNode {
    title?: string | undefined;
    key!: string;
    order?: number;
    readonly scopedSlots?: any | undefined;
    children?: DepartmentTreeNode[] | undefined;
    parentDepartmentId?: string | undefined;

    constructor(data?: IDepartmentTreeNode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.key = _data["key"];
            this.order = _data["order"];
            (<any>this).scopedSlots = _data["scopedSlots"];
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(DepartmentTreeNode.fromJS(item));
            }
            this.parentDepartmentId = _data["parentDepartmentId"];
        }
    }

    static fromJS(data: any): DepartmentTreeNode {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentTreeNode();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["key"] = this.key;
        data["order"] = this.order;
        data["scopedSlots"] = this.scopedSlots;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        data["parentDepartmentId"] = this.parentDepartmentId;
        return data; 
    }
}

export interface IDepartmentTreeNode {
    title?: string | undefined;
    key: string;
    order?: number;
    scopedSlots?: any | undefined;
    children?: DepartmentTreeNode[] | undefined;
    parentDepartmentId?: string | undefined;
}

export class DepartmentViewModel implements IDepartmentViewModel {
    department?: Department;
    children?: DepartmentViewModel[] | undefined;

    constructor(data?: IDepartmentViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.department = _data["department"] ? Department.fromJS(_data["department"]) : <any>undefined;
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(DepartmentViewModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DepartmentViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["department"] = this.department ? this.department.toJSON() : <any>undefined;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDepartmentViewModel {
    department?: Department;
    children?: DepartmentViewModel[] | undefined;
}

export class DisposeItem implements IDisposeItem {
    disposeVarName?: string | undefined;
    disposeVarValue?: string | undefined;
    assigneeVarName?: string | undefined;
    assigneeVarValue?: string | undefined;
    targetActivityIsMultiInstance?: boolean;
    userListVarName?: string | undefined;

    constructor(data?: IDisposeItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.disposeVarName = _data["disposeVarName"];
            this.disposeVarValue = _data["disposeVarValue"];
            this.assigneeVarName = _data["assigneeVarName"];
            this.assigneeVarValue = _data["assigneeVarValue"];
            this.targetActivityIsMultiInstance = _data["targetActivityIsMultiInstance"];
            this.userListVarName = _data["userListVarName"];
        }
    }

    static fromJS(data: any): DisposeItem {
        data = typeof data === 'object' ? data : {};
        let result = new DisposeItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["disposeVarName"] = this.disposeVarName;
        data["disposeVarValue"] = this.disposeVarValue;
        data["assigneeVarName"] = this.assigneeVarName;
        data["assigneeVarValue"] = this.assigneeVarValue;
        data["targetActivityIsMultiInstance"] = this.targetActivityIsMultiInstance;
        data["userListVarName"] = this.userListVarName;
        return data; 
    }
}

export interface IDisposeItem {
    disposeVarName?: string | undefined;
    disposeVarValue?: string | undefined;
    assigneeVarName?: string | undefined;
    assigneeVarValue?: string | undefined;
    targetActivityIsMultiInstance?: boolean;
    userListVarName?: string | undefined;
}

export class DiyUser implements IDiyUser {
    departmentName?: string | undefined;
    name?: string | undefined;
    job?: string | undefined;
    officePhone?: string | undefined;
    mobilePhone?: string | undefined;
    office?: string | undefined;
    remark?: string | undefined;

    constructor(data?: IDiyUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.departmentName = _data["departmentName"];
            this.name = _data["name"];
            this.job = _data["job"];
            this.officePhone = _data["officePhone"];
            this.mobilePhone = _data["mobilePhone"];
            this.office = _data["office"];
            this.remark = _data["remark"];
        }
    }

    static fromJS(data: any): DiyUser {
        data = typeof data === 'object' ? data : {};
        let result = new DiyUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["departmentName"] = this.departmentName;
        data["name"] = this.name;
        data["job"] = this.job;
        data["officePhone"] = this.officePhone;
        data["mobilePhone"] = this.mobilePhone;
        data["office"] = this.office;
        data["remark"] = this.remark;
        return data; 
    }
}

export interface IDiyUser {
    departmentName?: string | undefined;
    name?: string | undefined;
    job?: string | undefined;
    officePhone?: string | undefined;
    mobilePhone?: string | undefined;
    office?: string | undefined;
    remark?: string | undefined;
}

export class ErrorDto implements IErrorDto {
    code?: string | undefined;
    message?: string | undefined;
    innerError?: Innererror;

    constructor(data?: IErrorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            this.innerError = _data["innerError"] ? Innererror.fromJS(_data["innerError"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ErrorDto {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        data["innerError"] = this.innerError ? this.innerError.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IErrorDto {
    code?: string | undefined;
    message?: string | undefined;
    innerError?: Innererror;
}

export class ErrorModel implements IErrorModel {
    error?: ErrorDto;

    constructor(data?: IErrorModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.error = _data["error"] ? ErrorDto.fromJS(_data["error"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ErrorModel {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IErrorModel {
    error?: ErrorDto;
}

export enum EventAttributes {
    _0 = 0,
    _512 = 512,
    _1024 = 1024,
}

export class EventInfo implements IEventInfo {
    readonly name?: string;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    readonly customAttributes?: CustomAttributeData[];
    readonly isCollectible?: boolean;
    readonly metadataToken?: number;
    memberType?: MemberTypes;
    attributes?: EventAttributes;
    readonly isSpecialName?: boolean;
    addMethod?: MethodInfo;
    removeMethod?: MethodInfo;
    raiseMethod?: MethodInfo;
    readonly isMulticast?: boolean;
    eventHandlerType?: Type;

    constructor(data?: IEventInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["name"];
            this.declaringType = _data["declaringType"] ? Type.fromJS(_data["declaringType"]) : <any>undefined;
            this.reflectedType = _data["reflectedType"] ? Type.fromJS(_data["reflectedType"]) : <any>undefined;
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
            this.memberType = _data["memberType"];
            this.attributes = _data["attributes"];
            (<any>this).isSpecialName = _data["isSpecialName"];
            this.addMethod = _data["addMethod"] ? MethodInfo.fromJS(_data["addMethod"]) : <any>undefined;
            this.removeMethod = _data["removeMethod"] ? MethodInfo.fromJS(_data["removeMethod"]) : <any>undefined;
            this.raiseMethod = _data["raiseMethod"] ? MethodInfo.fromJS(_data["raiseMethod"]) : <any>undefined;
            (<any>this).isMulticast = _data["isMulticast"];
            this.eventHandlerType = _data["eventHandlerType"] ? Type.fromJS(_data["eventHandlerType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EventInfo {
        data = typeof data === 'object' ? data : {};
        let result = new EventInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["declaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["reflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        data["memberType"] = this.memberType;
        data["attributes"] = this.attributes;
        data["isSpecialName"] = this.isSpecialName;
        data["addMethod"] = this.addMethod ? this.addMethod.toJSON() : <any>undefined;
        data["removeMethod"] = this.removeMethod ? this.removeMethod.toJSON() : <any>undefined;
        data["raiseMethod"] = this.raiseMethod ? this.raiseMethod.toJSON() : <any>undefined;
        data["isMulticast"] = this.isMulticast;
        data["eventHandlerType"] = this.eventHandlerType ? this.eventHandlerType.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IEventInfo {
    name?: string;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    customAttributes?: CustomAttributeData[];
    isCollectible?: boolean;
    metadataToken?: number;
    memberType?: MemberTypes;
    attributes?: EventAttributes;
    isSpecialName?: boolean;
    addMethod?: MethodInfo;
    removeMethod?: MethodInfo;
    raiseMethod?: MethodInfo;
    isMulticast?: boolean;
    eventHandlerType?: Type;
}

export class Exception implements IException {
    targetSite?: MethodBase;
    message?: string;
    readonly data?: { [key: string]: any; };
    innerException?: Exception;
    helpLink?: string | undefined;
    source?: string | undefined;
    hResult?: number;
    readonly stackTrace?: string | undefined;

    constructor(data?: IException) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.targetSite = _data["targetSite"] ? MethodBase.fromJS(_data["targetSite"]) : <any>undefined;
            this.message = _data["message"];
            if (_data["data"]) {
                (<any>this).data = {} as any;
                for (let key in _data["data"]) {
                    if (_data["data"].hasOwnProperty(key))
                        (<any>(<any>this).data)![key] = _data["data"][key];
                }
            }
            this.innerException = _data["innerException"] ? Exception.fromJS(_data["innerException"]) : <any>undefined;
            this.helpLink = _data["helpLink"];
            this.source = _data["source"];
            this.hResult = _data["hResult"];
            (<any>this).stackTrace = _data["stackTrace"];
        }
    }

    static fromJS(data: any): Exception {
        data = typeof data === 'object' ? data : {};
        let result = new Exception();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["targetSite"] = this.targetSite ? this.targetSite.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (this.data) {
            data["data"] = {};
            for (let key in this.data) {
                if (this.data.hasOwnProperty(key))
                    (<any>data["data"])[key] = this.data[key];
            }
        }
        data["innerException"] = this.innerException ? this.innerException.toJSON() : <any>undefined;
        data["helpLink"] = this.helpLink;
        data["source"] = this.source;
        data["hResult"] = this.hResult;
        data["stackTrace"] = this.stackTrace;
        return data; 
    }
}

export interface IException {
    targetSite?: MethodBase;
    message?: string;
    data?: { [key: string]: any; };
    innerException?: Exception;
    helpLink?: string | undefined;
    source?: string | undefined;
    hResult?: number;
    stackTrace?: string | undefined;
}

export enum FieldAttributes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _16 = 16,
    _32 = 32,
    _64 = 64,
    _128 = 128,
    _256 = 256,
    _512 = 512,
    _1024 = 1024,
    _4096 = 4096,
    _8192 = 8192,
    _32768 = 32768,
    _38144 = 38144,
}

export class FieldInfo implements IFieldInfo {
    readonly name?: string;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    readonly customAttributes?: CustomAttributeData[];
    readonly isCollectible?: boolean;
    readonly metadataToken?: number;
    memberType?: MemberTypes;
    attributes?: FieldAttributes;
    fieldType?: Type;
    readonly isInitOnly?: boolean;
    readonly isLiteral?: boolean;
    readonly isNotSerialized?: boolean;
    readonly isPinvokeImpl?: boolean;
    readonly isSpecialName?: boolean;
    readonly isStatic?: boolean;
    readonly isAssembly?: boolean;
    readonly isFamily?: boolean;
    readonly isFamilyAndAssembly?: boolean;
    readonly isFamilyOrAssembly?: boolean;
    readonly isPrivate?: boolean;
    readonly isPublic?: boolean;
    readonly isSecurityCritical?: boolean;
    readonly isSecuritySafeCritical?: boolean;
    readonly isSecurityTransparent?: boolean;
    fieldHandle?: RuntimeFieldHandle;

    constructor(data?: IFieldInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["name"];
            this.declaringType = _data["declaringType"] ? Type.fromJS(_data["declaringType"]) : <any>undefined;
            this.reflectedType = _data["reflectedType"] ? Type.fromJS(_data["reflectedType"]) : <any>undefined;
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
            this.memberType = _data["memberType"];
            this.attributes = _data["attributes"];
            this.fieldType = _data["fieldType"] ? Type.fromJS(_data["fieldType"]) : <any>undefined;
            (<any>this).isInitOnly = _data["isInitOnly"];
            (<any>this).isLiteral = _data["isLiteral"];
            (<any>this).isNotSerialized = _data["isNotSerialized"];
            (<any>this).isPinvokeImpl = _data["isPinvokeImpl"];
            (<any>this).isSpecialName = _data["isSpecialName"];
            (<any>this).isStatic = _data["isStatic"];
            (<any>this).isAssembly = _data["isAssembly"];
            (<any>this).isFamily = _data["isFamily"];
            (<any>this).isFamilyAndAssembly = _data["isFamilyAndAssembly"];
            (<any>this).isFamilyOrAssembly = _data["isFamilyOrAssembly"];
            (<any>this).isPrivate = _data["isPrivate"];
            (<any>this).isPublic = _data["isPublic"];
            (<any>this).isSecurityCritical = _data["isSecurityCritical"];
            (<any>this).isSecuritySafeCritical = _data["isSecuritySafeCritical"];
            (<any>this).isSecurityTransparent = _data["isSecurityTransparent"];
            this.fieldHandle = _data["fieldHandle"] ? RuntimeFieldHandle.fromJS(_data["fieldHandle"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FieldInfo {
        data = typeof data === 'object' ? data : {};
        let result = new FieldInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["declaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["reflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        data["memberType"] = this.memberType;
        data["attributes"] = this.attributes;
        data["fieldType"] = this.fieldType ? this.fieldType.toJSON() : <any>undefined;
        data["isInitOnly"] = this.isInitOnly;
        data["isLiteral"] = this.isLiteral;
        data["isNotSerialized"] = this.isNotSerialized;
        data["isPinvokeImpl"] = this.isPinvokeImpl;
        data["isSpecialName"] = this.isSpecialName;
        data["isStatic"] = this.isStatic;
        data["isAssembly"] = this.isAssembly;
        data["isFamily"] = this.isFamily;
        data["isFamilyAndAssembly"] = this.isFamilyAndAssembly;
        data["isFamilyOrAssembly"] = this.isFamilyOrAssembly;
        data["isPrivate"] = this.isPrivate;
        data["isPublic"] = this.isPublic;
        data["isSecurityCritical"] = this.isSecurityCritical;
        data["isSecuritySafeCritical"] = this.isSecuritySafeCritical;
        data["isSecurityTransparent"] = this.isSecurityTransparent;
        data["fieldHandle"] = this.fieldHandle ? this.fieldHandle.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IFieldInfo {
    name?: string;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    customAttributes?: CustomAttributeData[];
    isCollectible?: boolean;
    metadataToken?: number;
    memberType?: MemberTypes;
    attributes?: FieldAttributes;
    fieldType?: Type;
    isInitOnly?: boolean;
    isLiteral?: boolean;
    isNotSerialized?: boolean;
    isPinvokeImpl?: boolean;
    isSpecialName?: boolean;
    isStatic?: boolean;
    isAssembly?: boolean;
    isFamily?: boolean;
    isFamilyAndAssembly?: boolean;
    isFamilyOrAssembly?: boolean;
    isPrivate?: boolean;
    isPublic?: boolean;
    isSecurityCritical?: boolean;
    isSecuritySafeCritical?: boolean;
    isSecurityTransparent?: boolean;
    fieldHandle?: RuntimeFieldHandle;
}

export class FieldItem implements IFieldItem {
    key?: string | undefined;
    name?: string | undefined;
    value?: string | undefined;

    constructor(data?: IFieldItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): FieldItem {
        data = typeof data === 'object' ? data : {};
        let result = new FieldItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface IFieldItem {
    key?: string | undefined;
    name?: string | undefined;
    value?: string | undefined;
}

export class FolderItem implements IFolderItem {
    id?: string | undefined;
    subject?: string | undefined;
    senderName?: string | undefined;
    size?: string | undefined;
    dateTimeReceived?: string | undefined;
    isRead?: boolean;

    constructor(data?: IFolderItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.subject = _data["subject"];
            this.senderName = _data["senderName"];
            this.size = _data["size"];
            this.dateTimeReceived = _data["dateTimeReceived"];
            this.isRead = _data["isRead"];
        }
    }

    static fromJS(data: any): FolderItem {
        data = typeof data === 'object' ? data : {};
        let result = new FolderItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["subject"] = this.subject;
        data["senderName"] = this.senderName;
        data["size"] = this.size;
        data["dateTimeReceived"] = this.dateTimeReceived;
        data["isRead"] = this.isRead;
        return data; 
    }
}

export interface IFolderItem {
    id?: string | undefined;
    subject?: string | undefined;
    senderName?: string | undefined;
    size?: string | undefined;
    dateTimeReceived?: string | undefined;
    isRead?: boolean;
}

export enum FolderName {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class FormAttachmentDto implements IFormAttachmentDto {
    id?: number;
    creatorUserName!: string;
    businessKey!: string;
    orignFileName!: string;
    fileName!: string;
    contentType!: string;
    bytesLength?: number;
    createDateTime?: Date;
    lastUploadDateTime?: Date;
    lastUploadUserName?: string | undefined;
    order?: number;
    rowVersion?: number;
    tag?: string | undefined;
    notAllowedDelete?: boolean | undefined;
    hidden?: boolean | undefined;
    stringId?: string | undefined;
    humanizeBytesLength?: string | undefined;
    stringRowVersion?: string | undefined;
    downloadUrl?: string | undefined;
    uploadUrl?: string | undefined;

    constructor(data?: IFormAttachmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creatorUserName = _data["creatorUserName"];
            this.businessKey = _data["businessKey"];
            this.orignFileName = _data["orignFileName"];
            this.fileName = _data["fileName"];
            this.contentType = _data["contentType"];
            this.bytesLength = _data["bytesLength"];
            this.createDateTime = _data["createDateTime"] ? new Date(_data["createDateTime"].toString()) : <any>undefined;
            this.lastUploadDateTime = _data["lastUploadDateTime"] ? new Date(_data["lastUploadDateTime"].toString()) : <any>undefined;
            this.lastUploadUserName = _data["lastUploadUserName"];
            this.order = _data["order"];
            this.rowVersion = _data["rowVersion"];
            this.tag = _data["tag"];
            this.notAllowedDelete = _data["notAllowedDelete"];
            this.hidden = _data["hidden"];
            this.stringId = _data["stringId"];
            this.humanizeBytesLength = _data["humanizeBytesLength"];
            this.stringRowVersion = _data["stringRowVersion"];
            this.downloadUrl = _data["downloadUrl"];
            this.uploadUrl = _data["uploadUrl"];
        }
    }

    static fromJS(data: any): FormAttachmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormAttachmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creatorUserName"] = this.creatorUserName;
        data["businessKey"] = this.businessKey;
        data["orignFileName"] = this.orignFileName;
        data["fileName"] = this.fileName;
        data["contentType"] = this.contentType;
        data["bytesLength"] = this.bytesLength;
        data["createDateTime"] = this.createDateTime ? this.createDateTime.toISOString() : <any>undefined;
        data["lastUploadDateTime"] = this.lastUploadDateTime ? this.lastUploadDateTime.toISOString() : <any>undefined;
        data["lastUploadUserName"] = this.lastUploadUserName;
        data["order"] = this.order;
        data["rowVersion"] = this.rowVersion;
        data["tag"] = this.tag;
        data["notAllowedDelete"] = this.notAllowedDelete;
        data["hidden"] = this.hidden;
        data["stringId"] = this.stringId;
        data["humanizeBytesLength"] = this.humanizeBytesLength;
        data["stringRowVersion"] = this.stringRowVersion;
        data["downloadUrl"] = this.downloadUrl;
        data["uploadUrl"] = this.uploadUrl;
        return data; 
    }
}

export interface IFormAttachmentDto {
    id?: number;
    creatorUserName: string;
    businessKey: string;
    orignFileName: string;
    fileName: string;
    contentType: string;
    bytesLength?: number;
    createDateTime?: Date;
    lastUploadDateTime?: Date;
    lastUploadUserName?: string | undefined;
    order?: number;
    rowVersion?: number;
    tag?: string | undefined;
    notAllowedDelete?: boolean | undefined;
    hidden?: boolean | undefined;
    stringId?: string | undefined;
    humanizeBytesLength?: string | undefined;
    stringRowVersion?: string | undefined;
    downloadUrl?: string | undefined;
    uploadUrl?: string | undefined;
}

export class FormDetailViewModel implements IFormDetailViewModel {
    taskId?: string | undefined;
    activityName?: string | undefined;
    /** 流程是否结束 */
    isFlowFinished?: boolean;
    /** 刚刚创建的？没有经过流程 */
    isJustCreated?: boolean | undefined;
    /** 当前用户填写过意见 */
    curUserHasAnyOpinion?: boolean | undefined;
    /** 暂存意见 */
    tempSaveOpinion?: string | undefined;
    form?: BusinessForm;
    canEditForm?: boolean;
    canUploadOrUpdateFiles?: boolean;

    constructor(data?: IFormDetailViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.taskId = _data["taskId"];
            this.activityName = _data["activityName"];
            this.isFlowFinished = _data["isFlowFinished"];
            this.isJustCreated = _data["isJustCreated"];
            this.curUserHasAnyOpinion = _data["curUserHasAnyOpinion"];
            this.tempSaveOpinion = _data["tempSaveOpinion"];
            this.form = _data["form"] ? BusinessForm.fromJS(_data["form"]) : <any>undefined;
            this.canEditForm = _data["canEditForm"];
            this.canUploadOrUpdateFiles = _data["canUploadOrUpdateFiles"];
        }
    }

    static fromJS(data: any): FormDetailViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new FormDetailViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taskId"] = this.taskId;
        data["activityName"] = this.activityName;
        data["isFlowFinished"] = this.isFlowFinished;
        data["isJustCreated"] = this.isJustCreated;
        data["curUserHasAnyOpinion"] = this.curUserHasAnyOpinion;
        data["tempSaveOpinion"] = this.tempSaveOpinion;
        data["form"] = this.form ? this.form.toJSON() : <any>undefined;
        data["canEditForm"] = this.canEditForm;
        data["canUploadOrUpdateFiles"] = this.canUploadOrUpdateFiles;
        return data; 
    }
}

export interface IFormDetailViewModel {
    taskId?: string | undefined;
    activityName?: string | undefined;
    /** 流程是否结束 */
    isFlowFinished?: boolean;
    /** 刚刚创建的？没有经过流程 */
    isJustCreated?: boolean | undefined;
    /** 当前用户填写过意见 */
    curUserHasAnyOpinion?: boolean | undefined;
    /** 暂存意见 */
    tempSaveOpinion?: string | undefined;
    form?: BusinessForm;
    canEditForm?: boolean;
    canUploadOrUpdateFiles?: boolean;
}

export class FormDto implements IFormDto {
    businessKey?: string | undefined;
    procDefKey?: string | undefined;
    proDefName?: string | undefined;
    title?: string | undefined;
    drafterUserName?: string | undefined;
    drafterName?: string | undefined;
    drafterDept?: string | undefined;
    createDateTime?: Date;
    maxEndDateTime?: Date | undefined;
    formFields?: FormField[] | undefined;
    emergencyLevel?: string | undefined;

    constructor(data?: IFormDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.businessKey = _data["businessKey"];
            this.procDefKey = _data["procDefKey"];
            this.proDefName = _data["proDefName"];
            this.title = _data["title"];
            this.drafterUserName = _data["drafterUserName"];
            this.drafterName = _data["drafterName"];
            this.drafterDept = _data["drafterDept"];
            this.createDateTime = _data["createDateTime"] ? new Date(_data["createDateTime"].toString()) : <any>undefined;
            this.maxEndDateTime = _data["maxEndDateTime"] ? new Date(_data["maxEndDateTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["formFields"])) {
                this.formFields = [] as any;
                for (let item of _data["formFields"])
                    this.formFields!.push(FormField.fromJS(item));
            }
            this.emergencyLevel = _data["emergencyLevel"];
        }
    }

    static fromJS(data: any): FormDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessKey"] = this.businessKey;
        data["procDefKey"] = this.procDefKey;
        data["proDefName"] = this.proDefName;
        data["title"] = this.title;
        data["drafterUserName"] = this.drafterUserName;
        data["drafterName"] = this.drafterName;
        data["drafterDept"] = this.drafterDept;
        data["createDateTime"] = this.createDateTime ? this.createDateTime.toISOString() : <any>undefined;
        data["maxEndDateTime"] = this.maxEndDateTime ? this.maxEndDateTime.toISOString() : <any>undefined;
        if (Array.isArray(this.formFields)) {
            data["formFields"] = [];
            for (let item of this.formFields)
                data["formFields"].push(item.toJSON());
        }
        data["emergencyLevel"] = this.emergencyLevel;
        return data; 
    }
}

export interface IFormDto {
    businessKey?: string | undefined;
    procDefKey?: string | undefined;
    proDefName?: string | undefined;
    title?: string | undefined;
    drafterUserName?: string | undefined;
    drafterName?: string | undefined;
    drafterDept?: string | undefined;
    createDateTime?: Date;
    maxEndDateTime?: Date | undefined;
    formFields?: FormField[] | undefined;
    emergencyLevel?: string | undefined;
}

export class FormField implements IFormField {
    key?: string | undefined;
    displayName?: string | undefined;
    value?: string | undefined;

    constructor(data?: IFormField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.displayName = _data["displayName"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): FormField {
        data = typeof data === 'object' ? data : {};
        let result = new FormField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["displayName"] = this.displayName;
        data["value"] = this.value;
        return data; 
    }
}

export interface IFormField {
    key?: string | undefined;
    displayName?: string | undefined;
    value?: string | undefined;
}

export enum GenericParameterAttributes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _8 = 8,
    _16 = 16,
    _28 = 28,
}

export enum GetFormDetailMode {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export enum GrantType {
    _0 = 0,
    _1 = 1,
}

export class HistoryFlowViewModel implements IHistoryFlowViewModel {
    id?: string | undefined;
    processInstanceId?: string | undefined;
    businessKey?: string | undefined;
    state?: string | undefined;
    creatorDisplayName?: string | undefined;
    title?: string | undefined;
    /** 删除原因 */
    deleteReason?: string | undefined;

    constructor(data?: IHistoryFlowViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.processInstanceId = _data["processInstanceId"];
            this.businessKey = _data["businessKey"];
            this.state = _data["state"];
            this.creatorDisplayName = _data["creatorDisplayName"];
            this.title = _data["title"];
            this.deleteReason = _data["deleteReason"];
        }
    }

    static fromJS(data: any): HistoryFlowViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new HistoryFlowViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["processInstanceId"] = this.processInstanceId;
        data["businessKey"] = this.businessKey;
        data["state"] = this.state;
        data["creatorDisplayName"] = this.creatorDisplayName;
        data["title"] = this.title;
        data["deleteReason"] = this.deleteReason;
        return data; 
    }
}

export interface IHistoryFlowViewModel {
    id?: string | undefined;
    processInstanceId?: string | undefined;
    businessKey?: string | undefined;
    state?: string | undefined;
    creatorDisplayName?: string | undefined;
    title?: string | undefined;
    /** 删除原因 */
    deleteReason?: string | undefined;
}

export class HistoryFlowViewModelTCollectionWithPagination implements IHistoryFlowViewModelTCollectionWithPagination {
    value?: HistoryFlowViewModel[] | undefined;
    total?: number;

    constructor(data?: IHistoryFlowViewModelTCollectionWithPagination) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(HistoryFlowViewModel.fromJS(item));
            }
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): HistoryFlowViewModelTCollectionWithPagination {
        data = typeof data === 'object' ? data : {};
        let result = new HistoryFlowViewModelTCollectionWithPagination();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        data["total"] = this.total;
        return data; 
    }
}

export interface IHistoryFlowViewModelTCollectionWithPagination {
    value?: HistoryFlowViewModel[] | undefined;
    total?: number;
}

export class HistoryProcesseInstance implements IHistoryProcesseInstance {
    id?: string | undefined;
    startTime?: Date | undefined;
    startTimeFormat?: string | undefined;
    endTime?: Date | undefined;
    state?: string | undefined;
    form?: BusinessForm;
    emergencyLevel?: string | undefined;
    archNo?: string | undefined;
    /** 显示部门 */
    displayDepartment?: string | undefined;
    claims?: Claim[] | undefined;

    constructor(data?: IHistoryProcesseInstance) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.startTime = _data["startTime"] ? new Date(_data["startTime"].toString()) : <any>undefined;
            this.startTimeFormat = _data["startTimeFormat"];
            this.endTime = _data["endTime"] ? new Date(_data["endTime"].toString()) : <any>undefined;
            this.state = _data["state"];
            this.form = _data["form"] ? BusinessForm.fromJS(_data["form"]) : <any>undefined;
            this.emergencyLevel = _data["emergencyLevel"];
            this.archNo = _data["archNo"];
            this.displayDepartment = _data["displayDepartment"];
            if (Array.isArray(_data["claims"])) {
                this.claims = [] as any;
                for (let item of _data["claims"])
                    this.claims!.push(Claim.fromJS(item));
            }
        }
    }

    static fromJS(data: any): HistoryProcesseInstance {
        data = typeof data === 'object' ? data : {};
        let result = new HistoryProcesseInstance();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["startTimeFormat"] = this.startTimeFormat;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["state"] = this.state;
        data["form"] = this.form ? this.form.toJSON() : <any>undefined;
        data["emergencyLevel"] = this.emergencyLevel;
        data["archNo"] = this.archNo;
        data["displayDepartment"] = this.displayDepartment;
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IHistoryProcesseInstance {
    id?: string | undefined;
    startTime?: Date | undefined;
    startTimeFormat?: string | undefined;
    endTime?: Date | undefined;
    state?: string | undefined;
    form?: BusinessForm;
    emergencyLevel?: string | undefined;
    archNo?: string | undefined;
    /** 显示部门 */
    displayDepartment?: string | undefined;
    claims?: Claim[] | undefined;
}

export class HistoryProcesseInstancePaginationResult implements IHistoryProcesseInstancePaginationResult {
    succeeded?: boolean;
    errorMessage?: string | undefined;
    rows?: HistoryProcesseInstance[] | undefined;
    total?: number;
    pageSize?: number;

    constructor(data?: IHistoryProcesseInstancePaginationResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.errorMessage = _data["errorMessage"];
            if (Array.isArray(_data["rows"])) {
                this.rows = [] as any;
                for (let item of _data["rows"])
                    this.rows!.push(HistoryProcesseInstance.fromJS(item));
            }
            this.total = _data["total"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): HistoryProcesseInstancePaginationResult {
        data = typeof data === 'object' ? data : {};
        let result = new HistoryProcesseInstancePaginationResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["errorMessage"] = this.errorMessage;
        if (Array.isArray(this.rows)) {
            data["rows"] = [];
            for (let item of this.rows)
                data["rows"].push(item.toJSON());
        }
        data["total"] = this.total;
        data["pageSize"] = this.pageSize;
        return data; 
    }
}

export interface IHistoryProcesseInstancePaginationResult {
    succeeded?: boolean;
    errorMessage?: string | undefined;
    rows?: HistoryProcesseInstance[] | undefined;
    total?: number;
    pageSize?: number;
}

export class ICustomAttributeProvider implements IICustomAttributeProvider {

    constructor(data?: IICustomAttributeProvider) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): ICustomAttributeProvider {
        data = typeof data === 'object' ? data : {};
        let result = new ICustomAttributeProvider();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IICustomAttributeProvider {
}

export class InboxListViewModel implements IInboxListViewModel {
    value?: FolderItem[] | undefined;
    total?: number;
    unreadCount?: number;

    constructor(data?: IInboxListViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(FolderItem.fromJS(item));
            }
            this.total = _data["total"];
            this.unreadCount = _data["unreadCount"];
        }
    }

    static fromJS(data: any): InboxListViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new InboxListViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        data["total"] = this.total;
        data["unreadCount"] = this.unreadCount;
        return data; 
    }
}

export interface IInboxListViewModel {
    value?: FolderItem[] | undefined;
    total?: number;
    unreadCount?: number;
}

export class Innererror implements IInnererror {
    date?: Date;
    requestId?: string | undefined;
    clientRequestId?: string | undefined;

    constructor(data?: IInnererror) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.requestId = _data["requestId"];
            this.clientRequestId = _data["clientRequestId"];
        }
    }

    static fromJS(data: any): Innererror {
        data = typeof data === 'object' ? data : {};
        let result = new Innererror();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["requestId"] = this.requestId;
        data["clientRequestId"] = this.clientRequestId;
        return data; 
    }
}

export interface IInnererror {
    date?: Date;
    requestId?: string | undefined;
    clientRequestId?: string | undefined;
}

export class IntPtr implements IIntPtr {

    constructor(data?: IIntPtr) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): IntPtr {
        data = typeof data === 'object' ? data : {};
        let result = new IntPtr();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IIntPtr {
}

export class KeyValueViewModel implements IKeyValueViewModel {
    key?: string | undefined;
    value?: any | undefined;

    constructor(data?: IKeyValueViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): KeyValueViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new KeyValueViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        return data; 
    }
}

export interface IKeyValueViewModel {
    key?: string | undefined;
    value?: any | undefined;
}

export enum LayoutKind {
    _0 = 0,
    _2 = 2,
    _3 = 3,
}

export class LeaderActivityItem implements ILeaderActivityItem {
    id?: string | undefined;
    customDateTime?: string | undefined;
    content?: string | undefined;
    address?: string | undefined;
    persons?: string | undefined;
    remark?: string | undefined;

    constructor(data?: ILeaderActivityItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.customDateTime = _data["customDateTime"];
            this.content = _data["content"];
            this.address = _data["address"];
            this.persons = _data["persons"];
            this.remark = _data["remark"];
        }
    }

    static fromJS(data: any): LeaderActivityItem {
        data = typeof data === 'object' ? data : {};
        let result = new LeaderActivityItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["customDateTime"] = this.customDateTime;
        data["content"] = this.content;
        data["address"] = this.address;
        data["persons"] = this.persons;
        data["remark"] = this.remark;
        return data; 
    }
}

export interface ILeaderActivityItem {
    id?: string | undefined;
    customDateTime?: string | undefined;
    content?: string | undefined;
    address?: string | undefined;
    persons?: string | undefined;
    remark?: string | undefined;
}

export class ListItemWithBody implements IListItemWithBody {
    id?: string | undefined;
    subject?: string | undefined;
    senderName?: string | undefined;
    size?: string | undefined;
    dateTimeReceived?: string | undefined;
    isRead?: boolean;
    senderEmail?: string | undefined;
    displayTo?: string | undefined;
    /** 收件人地址列表 */
    toRecipients?: string[] | undefined;
    body?: string | undefined;
    attachments?: Attachment[] | undefined;

    constructor(data?: IListItemWithBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.subject = _data["subject"];
            this.senderName = _data["senderName"];
            this.size = _data["size"];
            this.dateTimeReceived = _data["dateTimeReceived"];
            this.isRead = _data["isRead"];
            this.senderEmail = _data["senderEmail"];
            this.displayTo = _data["displayTo"];
            if (Array.isArray(_data["toRecipients"])) {
                this.toRecipients = [] as any;
                for (let item of _data["toRecipients"])
                    this.toRecipients!.push(item);
            }
            this.body = _data["body"];
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments!.push(Attachment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListItemWithBody {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemWithBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["subject"] = this.subject;
        data["senderName"] = this.senderName;
        data["size"] = this.size;
        data["dateTimeReceived"] = this.dateTimeReceived;
        data["isRead"] = this.isRead;
        data["senderEmail"] = this.senderEmail;
        data["displayTo"] = this.displayTo;
        if (Array.isArray(this.toRecipients)) {
            data["toRecipients"] = [];
            for (let item of this.toRecipients)
                data["toRecipients"].push(item);
        }
        data["body"] = this.body;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListItemWithBody {
    id?: string | undefined;
    subject?: string | undefined;
    senderName?: string | undefined;
    size?: string | undefined;
    dateTimeReceived?: string | undefined;
    isRead?: boolean;
    senderEmail?: string | undefined;
    displayTo?: string | undefined;
    /** 收件人地址列表 */
    toRecipients?: string[] | undefined;
    body?: string | undefined;
    attachments?: Attachment[] | undefined;
}

export class MemberInfo implements IMemberInfo {
    memberType?: MemberTypes;
    declaringType?: Type;
    reflectedType?: Type;
    readonly name?: string;
    module?: Module;
    readonly customAttributes?: CustomAttributeData[];
    readonly isCollectible?: boolean;
    readonly metadataToken?: number;

    constructor(data?: IMemberInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberType = _data["memberType"];
            this.declaringType = _data["declaringType"] ? Type.fromJS(_data["declaringType"]) : <any>undefined;
            this.reflectedType = _data["reflectedType"] ? Type.fromJS(_data["reflectedType"]) : <any>undefined;
            (<any>this).name = _data["name"];
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
        }
    }

    static fromJS(data: any): MemberInfo {
        data = typeof data === 'object' ? data : {};
        let result = new MemberInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberType"] = this.memberType;
        data["declaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["reflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        return data; 
    }
}

export interface IMemberInfo {
    memberType?: MemberTypes;
    declaringType?: Type;
    reflectedType?: Type;
    name?: string;
    module?: Module;
    customAttributes?: CustomAttributeData[];
    isCollectible?: boolean;
    metadataToken?: number;
}

export enum MemberTypes {
    _1 = 1,
    _2 = 2,
    _4 = 4,
    _8 = 8,
    _16 = 16,
    _32 = 32,
    _64 = 64,
    _128 = 128,
    _191 = 191,
}

export enum MethodAttributes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _16 = 16,
    _32 = 32,
    _64 = 64,
    _128 = 128,
    _256 = 256,
    _512 = 512,
    _1024 = 1024,
    _2048 = 2048,
    _4096 = 4096,
    _8192 = 8192,
    _16384 = 16384,
    _32768 = 32768,
    _53248 = 53248,
}

export class MethodBase implements IMethodBase {
    memberType?: MemberTypes;
    readonly name?: string;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    readonly customAttributes?: CustomAttributeData[];
    readonly isCollectible?: boolean;
    readonly metadataToken?: number;
    attributes?: MethodAttributes;
    methodImplementationFlags?: MethodImplAttributes;
    callingConvention?: CallingConventions;
    readonly isAbstract?: boolean;
    readonly isConstructor?: boolean;
    readonly isFinal?: boolean;
    readonly isHideBySig?: boolean;
    readonly isSpecialName?: boolean;
    readonly isStatic?: boolean;
    readonly isVirtual?: boolean;
    readonly isAssembly?: boolean;
    readonly isFamily?: boolean;
    readonly isFamilyAndAssembly?: boolean;
    readonly isFamilyOrAssembly?: boolean;
    readonly isPrivate?: boolean;
    readonly isPublic?: boolean;
    readonly isConstructedGenericMethod?: boolean;
    readonly isGenericMethod?: boolean;
    readonly isGenericMethodDefinition?: boolean;
    readonly containsGenericParameters?: boolean;
    methodHandle?: RuntimeMethodHandle;
    readonly isSecurityCritical?: boolean;
    readonly isSecuritySafeCritical?: boolean;
    readonly isSecurityTransparent?: boolean;

    constructor(data?: IMethodBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberType = _data["memberType"];
            (<any>this).name = _data["name"];
            this.declaringType = _data["declaringType"] ? Type.fromJS(_data["declaringType"]) : <any>undefined;
            this.reflectedType = _data["reflectedType"] ? Type.fromJS(_data["reflectedType"]) : <any>undefined;
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
            this.attributes = _data["attributes"];
            this.methodImplementationFlags = _data["methodImplementationFlags"];
            this.callingConvention = _data["callingConvention"];
            (<any>this).isAbstract = _data["isAbstract"];
            (<any>this).isConstructor = _data["isConstructor"];
            (<any>this).isFinal = _data["isFinal"];
            (<any>this).isHideBySig = _data["isHideBySig"];
            (<any>this).isSpecialName = _data["isSpecialName"];
            (<any>this).isStatic = _data["isStatic"];
            (<any>this).isVirtual = _data["isVirtual"];
            (<any>this).isAssembly = _data["isAssembly"];
            (<any>this).isFamily = _data["isFamily"];
            (<any>this).isFamilyAndAssembly = _data["isFamilyAndAssembly"];
            (<any>this).isFamilyOrAssembly = _data["isFamilyOrAssembly"];
            (<any>this).isPrivate = _data["isPrivate"];
            (<any>this).isPublic = _data["isPublic"];
            (<any>this).isConstructedGenericMethod = _data["isConstructedGenericMethod"];
            (<any>this).isGenericMethod = _data["isGenericMethod"];
            (<any>this).isGenericMethodDefinition = _data["isGenericMethodDefinition"];
            (<any>this).containsGenericParameters = _data["containsGenericParameters"];
            this.methodHandle = _data["methodHandle"] ? RuntimeMethodHandle.fromJS(_data["methodHandle"]) : <any>undefined;
            (<any>this).isSecurityCritical = _data["isSecurityCritical"];
            (<any>this).isSecuritySafeCritical = _data["isSecuritySafeCritical"];
            (<any>this).isSecurityTransparent = _data["isSecurityTransparent"];
        }
    }

    static fromJS(data: any): MethodBase {
        data = typeof data === 'object' ? data : {};
        let result = new MethodBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberType"] = this.memberType;
        data["name"] = this.name;
        data["declaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["reflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        data["attributes"] = this.attributes;
        data["methodImplementationFlags"] = this.methodImplementationFlags;
        data["callingConvention"] = this.callingConvention;
        data["isAbstract"] = this.isAbstract;
        data["isConstructor"] = this.isConstructor;
        data["isFinal"] = this.isFinal;
        data["isHideBySig"] = this.isHideBySig;
        data["isSpecialName"] = this.isSpecialName;
        data["isStatic"] = this.isStatic;
        data["isVirtual"] = this.isVirtual;
        data["isAssembly"] = this.isAssembly;
        data["isFamily"] = this.isFamily;
        data["isFamilyAndAssembly"] = this.isFamilyAndAssembly;
        data["isFamilyOrAssembly"] = this.isFamilyOrAssembly;
        data["isPrivate"] = this.isPrivate;
        data["isPublic"] = this.isPublic;
        data["isConstructedGenericMethod"] = this.isConstructedGenericMethod;
        data["isGenericMethod"] = this.isGenericMethod;
        data["isGenericMethodDefinition"] = this.isGenericMethodDefinition;
        data["containsGenericParameters"] = this.containsGenericParameters;
        data["methodHandle"] = this.methodHandle ? this.methodHandle.toJSON() : <any>undefined;
        data["isSecurityCritical"] = this.isSecurityCritical;
        data["isSecuritySafeCritical"] = this.isSecuritySafeCritical;
        data["isSecurityTransparent"] = this.isSecurityTransparent;
        return data; 
    }
}

export interface IMethodBase {
    memberType?: MemberTypes;
    name?: string;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    customAttributes?: CustomAttributeData[];
    isCollectible?: boolean;
    metadataToken?: number;
    attributes?: MethodAttributes;
    methodImplementationFlags?: MethodImplAttributes;
    callingConvention?: CallingConventions;
    isAbstract?: boolean;
    isConstructor?: boolean;
    isFinal?: boolean;
    isHideBySig?: boolean;
    isSpecialName?: boolean;
    isStatic?: boolean;
    isVirtual?: boolean;
    isAssembly?: boolean;
    isFamily?: boolean;
    isFamilyAndAssembly?: boolean;
    isFamilyOrAssembly?: boolean;
    isPrivate?: boolean;
    isPublic?: boolean;
    isConstructedGenericMethod?: boolean;
    isGenericMethod?: boolean;
    isGenericMethodDefinition?: boolean;
    containsGenericParameters?: boolean;
    methodHandle?: RuntimeMethodHandle;
    isSecurityCritical?: boolean;
    isSecuritySafeCritical?: boolean;
    isSecurityTransparent?: boolean;
}

export enum MethodImplAttributes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _8 = 8,
    _16 = 16,
    _32 = 32,
    _64 = 64,
    _128 = 128,
    _256 = 256,
    _512 = 512,
    _4096 = 4096,
    _65535 = 65535,
}

export class MethodInfo implements IMethodInfo {
    readonly name?: string;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    readonly customAttributes?: CustomAttributeData[];
    readonly isCollectible?: boolean;
    readonly metadataToken?: number;
    attributes?: MethodAttributes;
    methodImplementationFlags?: MethodImplAttributes;
    callingConvention?: CallingConventions;
    readonly isAbstract?: boolean;
    readonly isConstructor?: boolean;
    readonly isFinal?: boolean;
    readonly isHideBySig?: boolean;
    readonly isSpecialName?: boolean;
    readonly isStatic?: boolean;
    readonly isVirtual?: boolean;
    readonly isAssembly?: boolean;
    readonly isFamily?: boolean;
    readonly isFamilyAndAssembly?: boolean;
    readonly isFamilyOrAssembly?: boolean;
    readonly isPrivate?: boolean;
    readonly isPublic?: boolean;
    readonly isConstructedGenericMethod?: boolean;
    readonly isGenericMethod?: boolean;
    readonly isGenericMethodDefinition?: boolean;
    readonly containsGenericParameters?: boolean;
    methodHandle?: RuntimeMethodHandle;
    readonly isSecurityCritical?: boolean;
    readonly isSecuritySafeCritical?: boolean;
    readonly isSecurityTransparent?: boolean;
    memberType?: MemberTypes;
    returnParameter?: ParameterInfo;
    returnType?: Type;
    returnTypeCustomAttributes?: ICustomAttributeProvider;

    constructor(data?: IMethodInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["name"];
            this.declaringType = _data["declaringType"] ? Type.fromJS(_data["declaringType"]) : <any>undefined;
            this.reflectedType = _data["reflectedType"] ? Type.fromJS(_data["reflectedType"]) : <any>undefined;
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
            this.attributes = _data["attributes"];
            this.methodImplementationFlags = _data["methodImplementationFlags"];
            this.callingConvention = _data["callingConvention"];
            (<any>this).isAbstract = _data["isAbstract"];
            (<any>this).isConstructor = _data["isConstructor"];
            (<any>this).isFinal = _data["isFinal"];
            (<any>this).isHideBySig = _data["isHideBySig"];
            (<any>this).isSpecialName = _data["isSpecialName"];
            (<any>this).isStatic = _data["isStatic"];
            (<any>this).isVirtual = _data["isVirtual"];
            (<any>this).isAssembly = _data["isAssembly"];
            (<any>this).isFamily = _data["isFamily"];
            (<any>this).isFamilyAndAssembly = _data["isFamilyAndAssembly"];
            (<any>this).isFamilyOrAssembly = _data["isFamilyOrAssembly"];
            (<any>this).isPrivate = _data["isPrivate"];
            (<any>this).isPublic = _data["isPublic"];
            (<any>this).isConstructedGenericMethod = _data["isConstructedGenericMethod"];
            (<any>this).isGenericMethod = _data["isGenericMethod"];
            (<any>this).isGenericMethodDefinition = _data["isGenericMethodDefinition"];
            (<any>this).containsGenericParameters = _data["containsGenericParameters"];
            this.methodHandle = _data["methodHandle"] ? RuntimeMethodHandle.fromJS(_data["methodHandle"]) : <any>undefined;
            (<any>this).isSecurityCritical = _data["isSecurityCritical"];
            (<any>this).isSecuritySafeCritical = _data["isSecuritySafeCritical"];
            (<any>this).isSecurityTransparent = _data["isSecurityTransparent"];
            this.memberType = _data["memberType"];
            this.returnParameter = _data["returnParameter"] ? ParameterInfo.fromJS(_data["returnParameter"]) : <any>undefined;
            this.returnType = _data["returnType"] ? Type.fromJS(_data["returnType"]) : <any>undefined;
            this.returnTypeCustomAttributes = _data["returnTypeCustomAttributes"] ? ICustomAttributeProvider.fromJS(_data["returnTypeCustomAttributes"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MethodInfo {
        data = typeof data === 'object' ? data : {};
        let result = new MethodInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["declaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["reflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        data["attributes"] = this.attributes;
        data["methodImplementationFlags"] = this.methodImplementationFlags;
        data["callingConvention"] = this.callingConvention;
        data["isAbstract"] = this.isAbstract;
        data["isConstructor"] = this.isConstructor;
        data["isFinal"] = this.isFinal;
        data["isHideBySig"] = this.isHideBySig;
        data["isSpecialName"] = this.isSpecialName;
        data["isStatic"] = this.isStatic;
        data["isVirtual"] = this.isVirtual;
        data["isAssembly"] = this.isAssembly;
        data["isFamily"] = this.isFamily;
        data["isFamilyAndAssembly"] = this.isFamilyAndAssembly;
        data["isFamilyOrAssembly"] = this.isFamilyOrAssembly;
        data["isPrivate"] = this.isPrivate;
        data["isPublic"] = this.isPublic;
        data["isConstructedGenericMethod"] = this.isConstructedGenericMethod;
        data["isGenericMethod"] = this.isGenericMethod;
        data["isGenericMethodDefinition"] = this.isGenericMethodDefinition;
        data["containsGenericParameters"] = this.containsGenericParameters;
        data["methodHandle"] = this.methodHandle ? this.methodHandle.toJSON() : <any>undefined;
        data["isSecurityCritical"] = this.isSecurityCritical;
        data["isSecuritySafeCritical"] = this.isSecuritySafeCritical;
        data["isSecurityTransparent"] = this.isSecurityTransparent;
        data["memberType"] = this.memberType;
        data["returnParameter"] = this.returnParameter ? this.returnParameter.toJSON() : <any>undefined;
        data["returnType"] = this.returnType ? this.returnType.toJSON() : <any>undefined;
        data["returnTypeCustomAttributes"] = this.returnTypeCustomAttributes ? this.returnTypeCustomAttributes.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IMethodInfo {
    name?: string;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    customAttributes?: CustomAttributeData[];
    isCollectible?: boolean;
    metadataToken?: number;
    attributes?: MethodAttributes;
    methodImplementationFlags?: MethodImplAttributes;
    callingConvention?: CallingConventions;
    isAbstract?: boolean;
    isConstructor?: boolean;
    isFinal?: boolean;
    isHideBySig?: boolean;
    isSpecialName?: boolean;
    isStatic?: boolean;
    isVirtual?: boolean;
    isAssembly?: boolean;
    isFamily?: boolean;
    isFamilyAndAssembly?: boolean;
    isFamilyOrAssembly?: boolean;
    isPrivate?: boolean;
    isPublic?: boolean;
    isConstructedGenericMethod?: boolean;
    isGenericMethod?: boolean;
    isGenericMethodDefinition?: boolean;
    containsGenericParameters?: boolean;
    methodHandle?: RuntimeMethodHandle;
    isSecurityCritical?: boolean;
    isSecuritySafeCritical?: boolean;
    isSecurityTransparent?: boolean;
    memberType?: MemberTypes;
    returnParameter?: ParameterInfo;
    returnType?: Type;
    returnTypeCustomAttributes?: ICustomAttributeProvider;
}

export class MobileLoginInfoViewModel implements IMobileLoginInfoViewModel {
    brand?: string | undefined;
    mobileDeviceType?: string | undefined;
    system?: string | undefined;
    systemVersion?: string | undefined;
    appVersion?: string | undefined;

    constructor(data?: IMobileLoginInfoViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.brand = _data["brand"];
            this.mobileDeviceType = _data["mobileDeviceType"];
            this.system = _data["system"];
            this.systemVersion = _data["systemVersion"];
            this.appVersion = _data["appVersion"];
        }
    }

    static fromJS(data: any): MobileLoginInfoViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new MobileLoginInfoViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brand"] = this.brand;
        data["mobileDeviceType"] = this.mobileDeviceType;
        data["system"] = this.system;
        data["systemVersion"] = this.systemVersion;
        data["appVersion"] = this.appVersion;
        return data; 
    }
}

export interface IMobileLoginInfoViewModel {
    brand?: string | undefined;
    mobileDeviceType?: string | undefined;
    system?: string | undefined;
    systemVersion?: string | undefined;
    appVersion?: string | undefined;
}

export class MobileTaskList implements IMobileTaskList {
    taskId?: string | undefined;
    processInstanceId?: string | undefined;
    activityName?: string | undefined;
    senderName?: string | undefined;
    title?: string | undefined;
    processDefKey?: string | undefined;
    processDefName?: string | undefined;
    createDateTime?: string | undefined;
    createDateTimeOffset?: Date | undefined;
    businessKey?: string | undefined;
    /** 紧急程度 */
    emergencyLevel?: string | undefined;
    /** 拟稿人 */
    drafterName?: string | undefined;
    /** 文号 */
    archNo?: string | undefined;
    claims?: Claim[] | undefined;

    constructor(data?: IMobileTaskList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.taskId = _data["taskId"];
            this.processInstanceId = _data["processInstanceId"];
            this.activityName = _data["activityName"];
            this.senderName = _data["senderName"];
            this.title = _data["title"];
            this.processDefKey = _data["processDefKey"];
            this.processDefName = _data["processDefName"];
            this.createDateTime = _data["createDateTime"];
            this.createDateTimeOffset = _data["createDateTimeOffset"] ? new Date(_data["createDateTimeOffset"].toString()) : <any>undefined;
            this.businessKey = _data["businessKey"];
            this.emergencyLevel = _data["emergencyLevel"];
            this.drafterName = _data["drafterName"];
            this.archNo = _data["archNo"];
            if (Array.isArray(_data["claims"])) {
                this.claims = [] as any;
                for (let item of _data["claims"])
                    this.claims!.push(Claim.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MobileTaskList {
        data = typeof data === 'object' ? data : {};
        let result = new MobileTaskList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taskId"] = this.taskId;
        data["processInstanceId"] = this.processInstanceId;
        data["activityName"] = this.activityName;
        data["senderName"] = this.senderName;
        data["title"] = this.title;
        data["processDefKey"] = this.processDefKey;
        data["processDefName"] = this.processDefName;
        data["createDateTime"] = this.createDateTime;
        data["createDateTimeOffset"] = this.createDateTimeOffset ? this.createDateTimeOffset.toISOString() : <any>undefined;
        data["businessKey"] = this.businessKey;
        data["emergencyLevel"] = this.emergencyLevel;
        data["drafterName"] = this.drafterName;
        data["archNo"] = this.archNo;
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IMobileTaskList {
    taskId?: string | undefined;
    processInstanceId?: string | undefined;
    activityName?: string | undefined;
    senderName?: string | undefined;
    title?: string | undefined;
    processDefKey?: string | undefined;
    processDefName?: string | undefined;
    createDateTime?: string | undefined;
    createDateTimeOffset?: Date | undefined;
    businessKey?: string | undefined;
    /** 紧急程度 */
    emergencyLevel?: string | undefined;
    /** 拟稿人 */
    drafterName?: string | undefined;
    /** 文号 */
    archNo?: string | undefined;
    claims?: Claim[] | undefined;
}

export class MobileTaskListPaginationResult implements IMobileTaskListPaginationResult {
    succeeded?: boolean;
    errorMessage?: string | undefined;
    rows?: MobileTaskList[] | undefined;
    total?: number;
    pageSize?: number;

    constructor(data?: IMobileTaskListPaginationResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.errorMessage = _data["errorMessage"];
            if (Array.isArray(_data["rows"])) {
                this.rows = [] as any;
                for (let item of _data["rows"])
                    this.rows!.push(MobileTaskList.fromJS(item));
            }
            this.total = _data["total"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): MobileTaskListPaginationResult {
        data = typeof data === 'object' ? data : {};
        let result = new MobileTaskListPaginationResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["errorMessage"] = this.errorMessage;
        if (Array.isArray(this.rows)) {
            data["rows"] = [];
            for (let item of this.rows)
                data["rows"].push(item.toJSON());
        }
        data["total"] = this.total;
        data["pageSize"] = this.pageSize;
        return data; 
    }
}

export interface IMobileTaskListPaginationResult {
    succeeded?: boolean;
    errorMessage?: string | undefined;
    rows?: MobileTaskList[] | undefined;
    total?: number;
    pageSize?: number;
}

export class ModelError implements IModelError {
    exception?: Exception;
    errorMessage?: string;

    constructor(data?: IModelError) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exception = _data["exception"] ? Exception.fromJS(_data["exception"]) : <any>undefined;
            this.errorMessage = _data["errorMessage"];
        }
    }

    static fromJS(data: any): ModelError {
        data = typeof data === 'object' ? data : {};
        let result = new ModelError();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exception"] = this.exception ? this.exception.toJSON() : <any>undefined;
        data["errorMessage"] = this.errorMessage;
        return data; 
    }
}

export interface IModelError {
    exception?: Exception;
    errorMessage?: string;
}

export class ModelStateEntry implements IModelStateEntry {
    rawValue?: any | undefined;
    attemptedValue?: string | undefined;
    readonly errors?: ModelError[];
    validationState?: ModelValidationState;
    readonly isContainerNode?: boolean;
    readonly children?: ModelStateEntry[] | undefined;

    constructor(data?: IModelStateEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rawValue = _data["rawValue"];
            this.attemptedValue = _data["attemptedValue"];
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(ModelError.fromJS(item));
            }
            this.validationState = _data["validationState"];
            (<any>this).isContainerNode = _data["isContainerNode"];
            if (Array.isArray(_data["children"])) {
                (<any>this).children = [] as any;
                for (let item of _data["children"])
                    (<any>this).children!.push(ModelStateEntry.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ModelStateEntry {
        data = typeof data === 'object' ? data : {};
        let result = new ModelStateEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rawValue"] = this.rawValue;
        data["attemptedValue"] = this.attemptedValue;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["validationState"] = this.validationState;
        data["isContainerNode"] = this.isContainerNode;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IModelStateEntry {
    rawValue?: any | undefined;
    attemptedValue?: string | undefined;
    errors?: ModelError[];
    validationState?: ModelValidationState;
    isContainerNode?: boolean;
    children?: ModelStateEntry[] | undefined;
}

export enum ModelValidationState {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class Module implements IModule {
    assembly?: Assembly;
    readonly fullyQualifiedName?: string;
    readonly name?: string;
    readonly mdStreamVersion?: number;
    readonly moduleVersionId?: string;
    readonly scopeName?: string;
    moduleHandle?: ModuleHandle;
    readonly customAttributes?: CustomAttributeData[];
    readonly metadataToken?: number;

    constructor(data?: IModule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.assembly = _data["assembly"] ? Assembly.fromJS(_data["assembly"]) : <any>undefined;
            (<any>this).fullyQualifiedName = _data["fullyQualifiedName"];
            (<any>this).name = _data["name"];
            (<any>this).mdStreamVersion = _data["mdStreamVersion"];
            (<any>this).moduleVersionId = _data["moduleVersionId"];
            (<any>this).scopeName = _data["scopeName"];
            this.moduleHandle = _data["moduleHandle"] ? ModuleHandle.fromJS(_data["moduleHandle"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).metadataToken = _data["metadataToken"];
        }
    }

    static fromJS(data: any): Module {
        data = typeof data === 'object' ? data : {};
        let result = new Module();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assembly"] = this.assembly ? this.assembly.toJSON() : <any>undefined;
        data["fullyQualifiedName"] = this.fullyQualifiedName;
        data["name"] = this.name;
        data["mdStreamVersion"] = this.mdStreamVersion;
        data["moduleVersionId"] = this.moduleVersionId;
        data["scopeName"] = this.scopeName;
        data["moduleHandle"] = this.moduleHandle ? this.moduleHandle.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["metadataToken"] = this.metadataToken;
        return data; 
    }
}

export interface IModule {
    assembly?: Assembly;
    fullyQualifiedName?: string;
    name?: string;
    mdStreamVersion?: number;
    moduleVersionId?: string;
    scopeName?: string;
    moduleHandle?: ModuleHandle;
    customAttributes?: CustomAttributeData[];
    metadataToken?: number;
}

export class ModuleHandle implements IModuleHandle {
    readonly mdStreamVersion?: number;

    constructor(data?: IModuleHandle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).mdStreamVersion = _data["mdStreamVersion"];
        }
    }

    static fromJS(data: any): ModuleHandle {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleHandle();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mdStreamVersion"] = this.mdStreamVersion;
        return data; 
    }
}

export interface IModuleHandle {
    mdStreamVersion?: number;
}

export class NewestHistoryTask implements INewestHistoryTask {
    taskId?: string | undefined;
    createUserDisplayName?: string | undefined;
    senderDisplayName?: string | undefined;
    archNo?: string | undefined;
    title?: string | undefined;
    activityName?: string | undefined;
    dealDateTimeFormat?: string | undefined;
    emergencyLevel?: string | undefined;
    processDefKey?: string | undefined;
    processDefName?: string | undefined;
    businessKey?: string | undefined;
    claims?: Claim[] | undefined;

    constructor(data?: INewestHistoryTask) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.taskId = _data["taskId"];
            this.createUserDisplayName = _data["createUserDisplayName"];
            this.senderDisplayName = _data["senderDisplayName"];
            this.archNo = _data["archNo"];
            this.title = _data["title"];
            this.activityName = _data["activityName"];
            this.dealDateTimeFormat = _data["dealDateTimeFormat"];
            this.emergencyLevel = _data["emergencyLevel"];
            this.processDefKey = _data["processDefKey"];
            this.processDefName = _data["processDefName"];
            this.businessKey = _data["businessKey"];
            if (Array.isArray(_data["claims"])) {
                this.claims = [] as any;
                for (let item of _data["claims"])
                    this.claims!.push(Claim.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NewestHistoryTask {
        data = typeof data === 'object' ? data : {};
        let result = new NewestHistoryTask();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taskId"] = this.taskId;
        data["createUserDisplayName"] = this.createUserDisplayName;
        data["senderDisplayName"] = this.senderDisplayName;
        data["archNo"] = this.archNo;
        data["title"] = this.title;
        data["activityName"] = this.activityName;
        data["dealDateTimeFormat"] = this.dealDateTimeFormat;
        data["emergencyLevel"] = this.emergencyLevel;
        data["processDefKey"] = this.processDefKey;
        data["processDefName"] = this.processDefName;
        data["businessKey"] = this.businessKey;
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item.toJSON());
        }
        return data; 
    }
}

export interface INewestHistoryTask {
    taskId?: string | undefined;
    createUserDisplayName?: string | undefined;
    senderDisplayName?: string | undefined;
    archNo?: string | undefined;
    title?: string | undefined;
    activityName?: string | undefined;
    dealDateTimeFormat?: string | undefined;
    emergencyLevel?: string | undefined;
    processDefKey?: string | undefined;
    processDefName?: string | undefined;
    businessKey?: string | undefined;
    claims?: Claim[] | undefined;
}

export class NewestHistoryTaskTCollectionWithPagination implements INewestHistoryTaskTCollectionWithPagination {
    value?: NewestHistoryTask[] | undefined;
    total?: number;

    constructor(data?: INewestHistoryTaskTCollectionWithPagination) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(NewestHistoryTask.fromJS(item));
            }
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): NewestHistoryTaskTCollectionWithPagination {
        data = typeof data === 'object' ? data : {};
        let result = new NewestHistoryTaskTCollectionWithPagination();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        data["total"] = this.total;
        return data; 
    }
}

export interface INewestHistoryTaskTCollectionWithPagination {
    value?: NewestHistoryTask[] | undefined;
    total?: number;
}

export class NewestUploadAndDownloadUrlViewModel implements INewestUploadAndDownloadUrlViewModel {
    downloadUrl?: string | undefined;
    uploadUrl?: string | undefined;

    constructor(data?: INewestUploadAndDownloadUrlViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.downloadUrl = _data["downloadUrl"];
            this.uploadUrl = _data["uploadUrl"];
        }
    }

    static fromJS(data: any): NewestUploadAndDownloadUrlViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new NewestUploadAndDownloadUrlViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["downloadUrl"] = this.downloadUrl;
        data["uploadUrl"] = this.uploadUrl;
        return data; 
    }
}

export interface INewestUploadAndDownloadUrlViewModel {
    downloadUrl?: string | undefined;
    uploadUrl?: string | undefined;
}

export class Opinion implements IOpinion {
    id?: number;
    opinionTypeId?: number;
    userName!: string;
    userDepartmentName?: string | undefined;
    businessKey!: string;
    activityKey!: string;
    activityName!: string;
    text!: string;
    dateTime!: Date;
    isTempSave?: boolean;
    userAgent?: string | undefined;
    clientIpAddress?: string | undefined;

    constructor(data?: IOpinion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.opinionTypeId = _data["opinionTypeId"];
            this.userName = _data["userName"];
            this.userDepartmentName = _data["userDepartmentName"];
            this.businessKey = _data["businessKey"];
            this.activityKey = _data["activityKey"];
            this.activityName = _data["activityName"];
            this.text = _data["text"];
            this.dateTime = _data["dateTime"] ? new Date(_data["dateTime"].toString()) : <any>undefined;
            this.isTempSave = _data["isTempSave"];
            this.userAgent = _data["userAgent"];
            this.clientIpAddress = _data["clientIpAddress"];
        }
    }

    static fromJS(data: any): Opinion {
        data = typeof data === 'object' ? data : {};
        let result = new Opinion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["opinionTypeId"] = this.opinionTypeId;
        data["userName"] = this.userName;
        data["userDepartmentName"] = this.userDepartmentName;
        data["businessKey"] = this.businessKey;
        data["activityKey"] = this.activityKey;
        data["activityName"] = this.activityName;
        data["text"] = this.text;
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
        data["isTempSave"] = this.isTempSave;
        data["userAgent"] = this.userAgent;
        data["clientIpAddress"] = this.clientIpAddress;
        return data; 
    }
}

export interface IOpinion {
    id?: number;
    opinionTypeId?: number;
    userName: string;
    userDepartmentName?: string | undefined;
    businessKey: string;
    activityKey: string;
    activityName: string;
    text: string;
    dateTime: Date;
    isTempSave?: boolean;
    userAgent?: string | undefined;
    clientIpAddress?: string | undefined;
}

export class OpinionGroup implements IOpinionGroup {
    typeName?: string | undefined;
    opinions?: OpinionItemOfGroup[] | undefined;

    constructor(data?: IOpinionGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.typeName = _data["typeName"];
            if (Array.isArray(_data["opinions"])) {
                this.opinions = [] as any;
                for (let item of _data["opinions"])
                    this.opinions!.push(OpinionItemOfGroup.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OpinionGroup {
        data = typeof data === 'object' ? data : {};
        let result = new OpinionGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeName"] = this.typeName;
        if (Array.isArray(this.opinions)) {
            data["opinions"] = [];
            for (let item of this.opinions)
                data["opinions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IOpinionGroup {
    typeName?: string | undefined;
    opinions?: OpinionItemOfGroup[] | undefined;
}

export class OpinionItem implements IOpinionItem {
    stringId?: string | undefined;
    user?: UserReply;
    opinion?: Opinion;
    formatDateTime?: string | undefined;
    /** 部门排序 */
    departmentOrder?: number | undefined;

    constructor(data?: IOpinionItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stringId = _data["stringId"];
            this.user = _data["user"] ? UserReply.fromJS(_data["user"]) : <any>undefined;
            this.opinion = _data["opinion"] ? Opinion.fromJS(_data["opinion"]) : <any>undefined;
            this.formatDateTime = _data["formatDateTime"];
            this.departmentOrder = _data["departmentOrder"];
        }
    }

    static fromJS(data: any): OpinionItem {
        data = typeof data === 'object' ? data : {};
        let result = new OpinionItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stringId"] = this.stringId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["opinion"] = this.opinion ? this.opinion.toJSON() : <any>undefined;
        data["formatDateTime"] = this.formatDateTime;
        data["departmentOrder"] = this.departmentOrder;
        return data; 
    }
}

export interface IOpinionItem {
    stringId?: string | undefined;
    user?: UserReply;
    opinion?: Opinion;
    formatDateTime?: string | undefined;
    /** 部门排序 */
    departmentOrder?: number | undefined;
}

export class OpinionItemOfGroup implements IOpinionItemOfGroup {
    id?: string | undefined;
    text?: string | undefined;
    userDisplayName?: string | undefined;
    userMainDepartment?: string | undefined;
    dateTimeFormat?: string | undefined;

    constructor(data?: IOpinionItemOfGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.text = _data["text"];
            this.userDisplayName = _data["userDisplayName"];
            this.userMainDepartment = _data["userMainDepartment"];
            this.dateTimeFormat = _data["dateTimeFormat"];
        }
    }

    static fromJS(data: any): OpinionItemOfGroup {
        data = typeof data === 'object' ? data : {};
        let result = new OpinionItemOfGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["text"] = this.text;
        data["userDisplayName"] = this.userDisplayName;
        data["userMainDepartment"] = this.userMainDepartment;
        data["dateTimeFormat"] = this.dateTimeFormat;
        return data; 
    }
}

export interface IOpinionItemOfGroup {
    id?: string | undefined;
    text?: string | undefined;
    userDisplayName?: string | undefined;
    userMainDepartment?: string | undefined;
    dateTimeFormat?: string | undefined;
}

export class OpinionTypeViewModel implements IOpinionTypeViewModel {
    id?: number;
    processDefKey!: string;
    name!: string;
    displayName?: string | undefined;
    desc?: string | undefined;
    order?: number;
    allowEditOnActvities?: string | undefined;
    opinionButtons?: string | undefined;
    completeButton?: string | undefined;
    isDirectedComplete?: boolean;
    enabled?: boolean;
    arrAllowEditOnActvities?: string[] | undefined;
    arrOpinionButtons?: string[] | undefined;

    constructor(data?: IOpinionTypeViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.processDefKey = _data["processDefKey"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.desc = _data["desc"];
            this.order = _data["order"];
            this.allowEditOnActvities = _data["allowEditOnActvities"];
            this.opinionButtons = _data["opinionButtons"];
            this.completeButton = _data["completeButton"];
            this.isDirectedComplete = _data["isDirectedComplete"];
            this.enabled = _data["enabled"];
            if (Array.isArray(_data["arrAllowEditOnActvities"])) {
                this.arrAllowEditOnActvities = [] as any;
                for (let item of _data["arrAllowEditOnActvities"])
                    this.arrAllowEditOnActvities!.push(item);
            }
            if (Array.isArray(_data["arrOpinionButtons"])) {
                this.arrOpinionButtons = [] as any;
                for (let item of _data["arrOpinionButtons"])
                    this.arrOpinionButtons!.push(item);
            }
        }
    }

    static fromJS(data: any): OpinionTypeViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new OpinionTypeViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["processDefKey"] = this.processDefKey;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["desc"] = this.desc;
        data["order"] = this.order;
        data["allowEditOnActvities"] = this.allowEditOnActvities;
        data["opinionButtons"] = this.opinionButtons;
        data["completeButton"] = this.completeButton;
        data["isDirectedComplete"] = this.isDirectedComplete;
        data["enabled"] = this.enabled;
        if (Array.isArray(this.arrAllowEditOnActvities)) {
            data["arrAllowEditOnActvities"] = [];
            for (let item of this.arrAllowEditOnActvities)
                data["arrAllowEditOnActvities"].push(item);
        }
        if (Array.isArray(this.arrOpinionButtons)) {
            data["arrOpinionButtons"] = [];
            for (let item of this.arrOpinionButtons)
                data["arrOpinionButtons"].push(item);
        }
        return data; 
    }
}

export interface IOpinionTypeViewModel {
    id?: number;
    processDefKey: string;
    name: string;
    displayName?: string | undefined;
    desc?: string | undefined;
    order?: number;
    allowEditOnActvities?: string | undefined;
    opinionButtons?: string | undefined;
    completeButton?: string | undefined;
    isDirectedComplete?: boolean;
    enabled?: boolean;
    arrAllowEditOnActvities?: string[] | undefined;
    arrOpinionButtons?: string[] | undefined;
}

export class OpinionViewModel implements IOpinionViewModel {
    opinionType?: OpinionTypeViewModel;
    opinionItems?: OpinionItem[] | undefined;

    constructor(data?: IOpinionViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.opinionType = _data["opinionType"] ? OpinionTypeViewModel.fromJS(_data["opinionType"]) : <any>undefined;
            if (Array.isArray(_data["opinionItems"])) {
                this.opinionItems = [] as any;
                for (let item of _data["opinionItems"])
                    this.opinionItems!.push(OpinionItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OpinionViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new OpinionViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["opinionType"] = this.opinionType ? this.opinionType.toJSON() : <any>undefined;
        if (Array.isArray(this.opinionItems)) {
            data["opinionItems"] = [];
            for (let item of this.opinionItems)
                data["opinionItems"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IOpinionViewModel {
    opinionType?: OpinionTypeViewModel;
    opinionItems?: OpinionItem[] | undefined;
}

export class Organization implements IOrganization {
    id?: number;
    name!: string;
    desc?: string | undefined;

    constructor(data?: IOrganization) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.desc = _data["desc"];
        }
    }

    static fromJS(data: any): Organization {
        data = typeof data === 'object' ? data : {};
        let result = new Organization();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["desc"] = this.desc;
        return data; 
    }
}

export interface IOrganization {
    id?: number;
    name: string;
    desc?: string | undefined;
}

export class OutgoingConfigItem implements IOutgoingConfigItem {
    confg?: ActivityOutgoingUsersConfig;
    assigneeUserGroups?: AssigneeUserGroup[] | undefined;

    constructor(data?: IOutgoingConfigItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.confg = _data["confg"] ? ActivityOutgoingUsersConfig.fromJS(_data["confg"]) : <any>undefined;
            if (Array.isArray(_data["assigneeUserGroups"])) {
                this.assigneeUserGroups = [] as any;
                for (let item of _data["assigneeUserGroups"])
                    this.assigneeUserGroups!.push(AssigneeUserGroup.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OutgoingConfigItem {
        data = typeof data === 'object' ? data : {};
        let result = new OutgoingConfigItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["confg"] = this.confg ? this.confg.toJSON() : <any>undefined;
        if (Array.isArray(this.assigneeUserGroups)) {
            data["assigneeUserGroups"] = [];
            for (let item of this.assigneeUserGroups)
                data["assigneeUserGroups"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IOutgoingConfigItem {
    confg?: ActivityOutgoingUsersConfig;
    assigneeUserGroups?: AssigneeUserGroup[] | undefined;
}

export class OutGoingItem implements IOutGoingItem {
    dispose?: string | undefined;

    constructor(data?: IOutGoingItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dispose = _data["dispose"];
        }
    }

    static fromJS(data: any): OutGoingItem {
        data = typeof data === 'object' ? data : {};
        let result = new OutGoingItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dispose"] = this.dispose;
        return data; 
    }
}

export interface IOutGoingItem {
    dispose?: string | undefined;
}

export class OutgoingItem1 implements IOutgoingItem1 {
    seqFlowName?: string | undefined;
    targetActivityId?: string | undefined;
    targetIsMulInstance?: boolean;
    isCondition?: boolean;
    order?: number;
    checked?: boolean;

    constructor(data?: IOutgoingItem1) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.seqFlowName = _data["seqFlowName"];
            this.targetActivityId = _data["targetActivityId"];
            this.targetIsMulInstance = _data["targetIsMulInstance"];
            this.isCondition = _data["isCondition"];
            this.order = _data["order"];
            this.checked = _data["checked"];
        }
    }

    static fromJS(data: any): OutgoingItem1 {
        data = typeof data === 'object' ? data : {};
        let result = new OutgoingItem1();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["seqFlowName"] = this.seqFlowName;
        data["targetActivityId"] = this.targetActivityId;
        data["targetIsMulInstance"] = this.targetIsMulInstance;
        data["isCondition"] = this.isCondition;
        data["order"] = this.order;
        data["checked"] = this.checked;
        return data; 
    }
}

export interface IOutgoingItem1 {
    seqFlowName?: string | undefined;
    targetActivityId?: string | undefined;
    targetIsMulInstance?: boolean;
    isCondition?: boolean;
    order?: number;
    checked?: boolean;
}

export enum ParameterAttributes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _4 = 4,
    _8 = 8,
    _16 = 16,
    _4096 = 4096,
    _8192 = 8192,
    _16384 = 16384,
    _32768 = 32768,
    _61440 = 61440,
}

export class ParameterInfo implements IParameterInfo {
    attributes?: ParameterAttributes;
    member?: MemberInfo;
    readonly name?: string | undefined;
    parameterType?: Type;
    readonly position?: number;
    readonly isIn?: boolean;
    readonly isLcid?: boolean;
    readonly isOptional?: boolean;
    readonly isOut?: boolean;
    readonly isRetval?: boolean;
    readonly defaultValue?: any | undefined;
    readonly rawDefaultValue?: any | undefined;
    readonly hasDefaultValue?: boolean;
    readonly customAttributes?: CustomAttributeData[];
    readonly metadataToken?: number;

    constructor(data?: IParameterInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.attributes = _data["attributes"];
            this.member = _data["member"] ? MemberInfo.fromJS(_data["member"]) : <any>undefined;
            (<any>this).name = _data["name"];
            this.parameterType = _data["parameterType"] ? Type.fromJS(_data["parameterType"]) : <any>undefined;
            (<any>this).position = _data["position"];
            (<any>this).isIn = _data["isIn"];
            (<any>this).isLcid = _data["isLcid"];
            (<any>this).isOptional = _data["isOptional"];
            (<any>this).isOut = _data["isOut"];
            (<any>this).isRetval = _data["isRetval"];
            (<any>this).defaultValue = _data["defaultValue"];
            (<any>this).rawDefaultValue = _data["rawDefaultValue"];
            (<any>this).hasDefaultValue = _data["hasDefaultValue"];
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).metadataToken = _data["metadataToken"];
        }
    }

    static fromJS(data: any): ParameterInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ParameterInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["attributes"] = this.attributes;
        data["member"] = this.member ? this.member.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["parameterType"] = this.parameterType ? this.parameterType.toJSON() : <any>undefined;
        data["position"] = this.position;
        data["isIn"] = this.isIn;
        data["isLcid"] = this.isLcid;
        data["isOptional"] = this.isOptional;
        data["isOut"] = this.isOut;
        data["isRetval"] = this.isRetval;
        data["defaultValue"] = this.defaultValue;
        data["rawDefaultValue"] = this.rawDefaultValue;
        data["hasDefaultValue"] = this.hasDefaultValue;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["metadataToken"] = this.metadataToken;
        return data; 
    }
}

export interface IParameterInfo {
    attributes?: ParameterAttributes;
    member?: MemberInfo;
    name?: string | undefined;
    parameterType?: Type;
    position?: number;
    isIn?: boolean;
    isLcid?: boolean;
    isOptional?: boolean;
    isOut?: boolean;
    isRetval?: boolean;
    defaultValue?: any | undefined;
    rawDefaultValue?: any | undefined;
    hasDefaultValue?: boolean;
    customAttributes?: CustomAttributeData[];
    metadataToken?: number;
}

export class Permisson implements IPermisson {
    id?: string | undefined;
    name!: string;
    displyName!: string;
    desc?: string | undefined;
    enabled?: boolean;

    constructor(data?: IPermisson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displyName = _data["displyName"];
            this.desc = _data["desc"];
            this.enabled = _data["enabled"];
        }
    }

    static fromJS(data: any): Permisson {
        data = typeof data === 'object' ? data : {};
        let result = new Permisson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displyName"] = this.displyName;
        data["desc"] = this.desc;
        data["enabled"] = this.enabled;
        return data; 
    }
}

export interface IPermisson {
    id?: string | undefined;
    name: string;
    displyName: string;
    desc?: string | undefined;
    enabled?: boolean;
}

export class PermissonPaginationResult implements IPermissonPaginationResult {
    succeeded?: boolean;
    errorMessage?: string | undefined;
    rows?: Permisson[] | undefined;
    total?: number;
    pageSize?: number;

    constructor(data?: IPermissonPaginationResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.errorMessage = _data["errorMessage"];
            if (Array.isArray(_data["rows"])) {
                this.rows = [] as any;
                for (let item of _data["rows"])
                    this.rows!.push(Permisson.fromJS(item));
            }
            this.total = _data["total"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): PermissonPaginationResult {
        data = typeof data === 'object' ? data : {};
        let result = new PermissonPaginationResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["errorMessage"] = this.errorMessage;
        if (Array.isArray(this.rows)) {
            data["rows"] = [];
            for (let item of this.rows)
                data["rows"].push(item.toJSON());
        }
        data["total"] = this.total;
        data["pageSize"] = this.pageSize;
        return data; 
    }
}

export interface IPermissonPaginationResult {
    succeeded?: boolean;
    errorMessage?: string | undefined;
    rows?: Permisson[] | undefined;
    total?: number;
    pageSize?: number;
}

export class PersonalReportVM implements IPersonalReportVM {
    userDepartmentName?: string | undefined;
    userDisplayName?: string | undefined;
    userOrder?: number;
    todoCount?: number;
    doneCount?: number;
    doneCountItems?: CountItem[] | undefined;
    todoCountItems?: CountItem[] | undefined;

    constructor(data?: IPersonalReportVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userDepartmentName = _data["userDepartmentName"];
            this.userDisplayName = _data["userDisplayName"];
            this.userOrder = _data["userOrder"];
            this.todoCount = _data["todoCount"];
            this.doneCount = _data["doneCount"];
            if (Array.isArray(_data["doneCountItems"])) {
                this.doneCountItems = [] as any;
                for (let item of _data["doneCountItems"])
                    this.doneCountItems!.push(CountItem.fromJS(item));
            }
            if (Array.isArray(_data["todoCountItems"])) {
                this.todoCountItems = [] as any;
                for (let item of _data["todoCountItems"])
                    this.todoCountItems!.push(CountItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PersonalReportVM {
        data = typeof data === 'object' ? data : {};
        let result = new PersonalReportVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userDepartmentName"] = this.userDepartmentName;
        data["userDisplayName"] = this.userDisplayName;
        data["userOrder"] = this.userOrder;
        data["todoCount"] = this.todoCount;
        data["doneCount"] = this.doneCount;
        if (Array.isArray(this.doneCountItems)) {
            data["doneCountItems"] = [];
            for (let item of this.doneCountItems)
                data["doneCountItems"].push(item.toJSON());
        }
        if (Array.isArray(this.todoCountItems)) {
            data["todoCountItems"] = [];
            for (let item of this.todoCountItems)
                data["todoCountItems"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPersonalReportVM {
    userDepartmentName?: string | undefined;
    userDisplayName?: string | undefined;
    userOrder?: number;
    todoCount?: number;
    doneCount?: number;
    doneCountItems?: CountItem[] | undefined;
    todoCountItems?: CountItem[] | undefined;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data; 
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
}

export class ProcessDefConfig implements IProcessDefConfig {
    processDefConfigItems?: ProcessDefConfigItem[] | undefined;

    constructor(data?: IProcessDefConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["processDefConfigItems"])) {
                this.processDefConfigItems = [] as any;
                for (let item of _data["processDefConfigItems"])
                    this.processDefConfigItems!.push(ProcessDefConfigItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProcessDefConfig {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessDefConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.processDefConfigItems)) {
            data["processDefConfigItems"] = [];
            for (let item of this.processDefConfigItems)
                data["processDefConfigItems"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IProcessDefConfig {
    processDefConfigItems?: ProcessDefConfigItem[] | undefined;
}

/** 处理定义配置 */
export class ProcessDefConfigItem implements IProcessDefConfigItem {
    processDefId?: string | undefined;
    processDefKey?: string | undefined;
    processDefName?: string | undefined;
    processDefConfigUserTaskItems?: ProcessDefConfigUserTaskItem[] | undefined;

    constructor(data?: IProcessDefConfigItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.processDefId = _data["processDefId"];
            this.processDefKey = _data["processDefKey"];
            this.processDefName = _data["processDefName"];
            if (Array.isArray(_data["processDefConfigUserTaskItems"])) {
                this.processDefConfigUserTaskItems = [] as any;
                for (let item of _data["processDefConfigUserTaskItems"])
                    this.processDefConfigUserTaskItems!.push(ProcessDefConfigUserTaskItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProcessDefConfigItem {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessDefConfigItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["processDefId"] = this.processDefId;
        data["processDefKey"] = this.processDefKey;
        data["processDefName"] = this.processDefName;
        if (Array.isArray(this.processDefConfigUserTaskItems)) {
            data["processDefConfigUserTaskItems"] = [];
            for (let item of this.processDefConfigUserTaskItems)
                data["processDefConfigUserTaskItems"].push(item.toJSON());
        }
        return data; 
    }
}

/** 处理定义配置 */
export interface IProcessDefConfigItem {
    processDefId?: string | undefined;
    processDefKey?: string | undefined;
    processDefName?: string | undefined;
    processDefConfigUserTaskItems?: ProcessDefConfigUserTaskItem[] | undefined;
}

export class ProcessDefConfigUserTaskItem implements IProcessDefConfigUserTaskItem {
    /** 活动Id */
    activityId?: string | undefined;
    /** 活动名称 */
    activityName?: string | undefined;
    /** 能够上传附件 */
    canUploadAttachments?: boolean;
    /** 能够修改附件 */
    canModifyAttachments?: boolean;
    /** 能够删除附件 */
    canDeleteAttachments?: boolean;
    /** 能够修改表单 */
    canModifyForm?: boolean;
    queryMode?: QueryMode;
    /** 额外签收人 */
    includeAssignees?: ApplicationUser[] | undefined;
    /** 额外签收部门 */
    includeAssigneeDepartments?: Department[] | undefined;
    /** 排除签收人 */
    excludeAssignees?: ApplicationUser[] | undefined;
    /** 排除签收部门 */
    excludeAssigneeDepartments?: Department[] | undefined;

    constructor(data?: IProcessDefConfigUserTaskItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.activityId = _data["activityId"];
            this.activityName = _data["activityName"];
            this.canUploadAttachments = _data["canUploadAttachments"];
            this.canModifyAttachments = _data["canModifyAttachments"];
            this.canDeleteAttachments = _data["canDeleteAttachments"];
            this.canModifyForm = _data["canModifyForm"];
            this.queryMode = _data["queryMode"];
            if (Array.isArray(_data["includeAssignees"])) {
                this.includeAssignees = [] as any;
                for (let item of _data["includeAssignees"])
                    this.includeAssignees!.push(ApplicationUser.fromJS(item));
            }
            if (Array.isArray(_data["includeAssigneeDepartments"])) {
                this.includeAssigneeDepartments = [] as any;
                for (let item of _data["includeAssigneeDepartments"])
                    this.includeAssigneeDepartments!.push(Department.fromJS(item));
            }
            if (Array.isArray(_data["excludeAssignees"])) {
                this.excludeAssignees = [] as any;
                for (let item of _data["excludeAssignees"])
                    this.excludeAssignees!.push(ApplicationUser.fromJS(item));
            }
            if (Array.isArray(_data["excludeAssigneeDepartments"])) {
                this.excludeAssigneeDepartments = [] as any;
                for (let item of _data["excludeAssigneeDepartments"])
                    this.excludeAssigneeDepartments!.push(Department.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProcessDefConfigUserTaskItem {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessDefConfigUserTaskItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityId"] = this.activityId;
        data["activityName"] = this.activityName;
        data["canUploadAttachments"] = this.canUploadAttachments;
        data["canModifyAttachments"] = this.canModifyAttachments;
        data["canDeleteAttachments"] = this.canDeleteAttachments;
        data["canModifyForm"] = this.canModifyForm;
        data["queryMode"] = this.queryMode;
        if (Array.isArray(this.includeAssignees)) {
            data["includeAssignees"] = [];
            for (let item of this.includeAssignees)
                data["includeAssignees"].push(item.toJSON());
        }
        if (Array.isArray(this.includeAssigneeDepartments)) {
            data["includeAssigneeDepartments"] = [];
            for (let item of this.includeAssigneeDepartments)
                data["includeAssigneeDepartments"].push(item.toJSON());
        }
        if (Array.isArray(this.excludeAssignees)) {
            data["excludeAssignees"] = [];
            for (let item of this.excludeAssignees)
                data["excludeAssignees"].push(item.toJSON());
        }
        if (Array.isArray(this.excludeAssigneeDepartments)) {
            data["excludeAssigneeDepartments"] = [];
            for (let item of this.excludeAssigneeDepartments)
                data["excludeAssigneeDepartments"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IProcessDefConfigUserTaskItem {
    /** 活动Id */
    activityId?: string | undefined;
    /** 活动名称 */
    activityName?: string | undefined;
    /** 能够上传附件 */
    canUploadAttachments?: boolean;
    /** 能够修改附件 */
    canModifyAttachments?: boolean;
    /** 能够删除附件 */
    canDeleteAttachments?: boolean;
    /** 能够修改表单 */
    canModifyForm?: boolean;
    queryMode?: QueryMode;
    /** 额外签收人 */
    includeAssignees?: ApplicationUser[] | undefined;
    /** 额外签收部门 */
    includeAssigneeDepartments?: Department[] | undefined;
    /** 排除签收人 */
    excludeAssignees?: ApplicationUser[] | undefined;
    /** 排除签收部门 */
    excludeAssigneeDepartments?: Department[] | undefined;
}

export class ProcessDefViewModel implements IProcessDefViewModel {
    id?: string | undefined;
    key?: string | undefined;
    name?: string | undefined;
    /** 描述 */
    description?: string | undefined;
    /** 用户任务活动 */
    userTaskActvities?: StringKeyValue[] | undefined;

    constructor(data?: IProcessDefViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.key = _data["key"];
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["userTaskActvities"])) {
                this.userTaskActvities = [] as any;
                for (let item of _data["userTaskActvities"])
                    this.userTaskActvities!.push(StringKeyValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProcessDefViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessDefViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["key"] = this.key;
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.userTaskActvities)) {
            data["userTaskActvities"] = [];
            for (let item of this.userTaskActvities)
                data["userTaskActvities"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IProcessDefViewModel {
    id?: string | undefined;
    key?: string | undefined;
    name?: string | undefined;
    /** 描述 */
    description?: string | undefined;
    /** 用户任务活动 */
    userTaskActvities?: StringKeyValue[] | undefined;
}

export enum PropertyAttributes {
    _0 = 0,
    _512 = 512,
    _1024 = 1024,
    _4096 = 4096,
    _8192 = 8192,
    _16384 = 16384,
    _32768 = 32768,
    _62464 = 62464,
}

export class PropertyInfo implements IPropertyInfo {
    readonly name?: string;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    readonly customAttributes?: CustomAttributeData[];
    readonly isCollectible?: boolean;
    readonly metadataToken?: number;
    memberType?: MemberTypes;
    propertyType?: Type;
    attributes?: PropertyAttributes;
    readonly isSpecialName?: boolean;
    readonly canRead?: boolean;
    readonly canWrite?: boolean;
    getMethod?: MethodInfo;
    setMethod?: MethodInfo;

    constructor(data?: IPropertyInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["name"];
            this.declaringType = _data["declaringType"] ? Type.fromJS(_data["declaringType"]) : <any>undefined;
            this.reflectedType = _data["reflectedType"] ? Type.fromJS(_data["reflectedType"]) : <any>undefined;
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
            this.memberType = _data["memberType"];
            this.propertyType = _data["propertyType"] ? Type.fromJS(_data["propertyType"]) : <any>undefined;
            this.attributes = _data["attributes"];
            (<any>this).isSpecialName = _data["isSpecialName"];
            (<any>this).canRead = _data["canRead"];
            (<any>this).canWrite = _data["canWrite"];
            this.getMethod = _data["getMethod"] ? MethodInfo.fromJS(_data["getMethod"]) : <any>undefined;
            this.setMethod = _data["setMethod"] ? MethodInfo.fromJS(_data["setMethod"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PropertyInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["declaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["reflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        data["memberType"] = this.memberType;
        data["propertyType"] = this.propertyType ? this.propertyType.toJSON() : <any>undefined;
        data["attributes"] = this.attributes;
        data["isSpecialName"] = this.isSpecialName;
        data["canRead"] = this.canRead;
        data["canWrite"] = this.canWrite;
        data["getMethod"] = this.getMethod ? this.getMethod.toJSON() : <any>undefined;
        data["setMethod"] = this.setMethod ? this.setMethod.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IPropertyInfo {
    name?: string;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    customAttributes?: CustomAttributeData[];
    isCollectible?: boolean;
    metadataToken?: number;
    memberType?: MemberTypes;
    propertyType?: Type;
    attributes?: PropertyAttributes;
    isSpecialName?: boolean;
    canRead?: boolean;
    canWrite?: boolean;
    getMethod?: MethodInfo;
    setMethod?: MethodInfo;
}

export enum QueryMode {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _9 = 9,
    _10 = 10,
    _11 = 11,
}

/** 查询用户(带部门和职位信息) */
export class QueryUsersDepartmentsItem implements IQueryUsersDepartmentsItem {
    total?: number;
    user?: ApplicationUser;
    departmentId?: string | undefined;
    departmentName?: string | undefined;
    departmentJob?: string | undefined;

    constructor(data?: IQueryUsersDepartmentsItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.total = _data["total"];
            this.user = _data["user"] ? ApplicationUser.fromJS(_data["user"]) : <any>undefined;
            this.departmentId = _data["departmentId"];
            this.departmentName = _data["departmentName"];
            this.departmentJob = _data["departmentJob"];
        }
    }

    static fromJS(data: any): QueryUsersDepartmentsItem {
        data = typeof data === 'object' ? data : {};
        let result = new QueryUsersDepartmentsItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["departmentId"] = this.departmentId;
        data["departmentName"] = this.departmentName;
        data["departmentJob"] = this.departmentJob;
        return data; 
    }
}

/** 查询用户(带部门和职位信息) */
export interface IQueryUsersDepartmentsItem {
    total?: number;
    user?: ApplicationUser;
    departmentId?: string | undefined;
    departmentName?: string | undefined;
    departmentJob?: string | undefined;
}

export class ReAddPermissonsToRoleDto implements IReAddPermissonsToRoleDto {
    roleId!: string;
    permissonIds?: string[] | undefined;

    constructor(data?: IReAddPermissonsToRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"];
            if (Array.isArray(_data["permissonIds"])) {
                this.permissonIds = [] as any;
                for (let item of _data["permissonIds"])
                    this.permissonIds!.push(item);
            }
        }
    }

    static fromJS(data: any): ReAddPermissonsToRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReAddPermissonsToRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        if (Array.isArray(this.permissonIds)) {
            data["permissonIds"] = [];
            for (let item of this.permissonIds)
                data["permissonIds"].push(item);
        }
        return data; 
    }
}

export interface IReAddPermissonsToRoleDto {
    roleId: string;
    permissonIds?: string[] | undefined;
}

export class ReStartProcessViewModel implements IReStartProcessViewModel {
    businessKey?: string | undefined;
    userName?: string | undefined;

    constructor(data?: IReStartProcessViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.businessKey = _data["businessKey"];
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): ReStartProcessViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ReStartProcessViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessKey"] = this.businessKey;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface IReStartProcessViewModel {
    businessKey?: string | undefined;
    userName?: string | undefined;
}

export class RuntimeFieldHandle implements IRuntimeFieldHandle {
    value?: IntPtr;

    constructor(data?: IRuntimeFieldHandle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"] ? IntPtr.fromJS(_data["value"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RuntimeFieldHandle {
        data = typeof data === 'object' ? data : {};
        let result = new RuntimeFieldHandle();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IRuntimeFieldHandle {
    value?: IntPtr;
}

export class RuntimeFlowViewModel implements IRuntimeFlowViewModel {
    rootProcInstId?: string | undefined;
    businessKey?: string | undefined;
    creatorDisplayName?: string | undefined;
    title?: string | undefined;
    runtimeTasks?: RuntimeTask[] | undefined;

    constructor(data?: IRuntimeFlowViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rootProcInstId = _data["rootProcInstId"];
            this.businessKey = _data["businessKey"];
            this.creatorDisplayName = _data["creatorDisplayName"];
            this.title = _data["title"];
            if (Array.isArray(_data["runtimeTasks"])) {
                this.runtimeTasks = [] as any;
                for (let item of _data["runtimeTasks"])
                    this.runtimeTasks!.push(RuntimeTask.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RuntimeFlowViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new RuntimeFlowViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rootProcInstId"] = this.rootProcInstId;
        data["businessKey"] = this.businessKey;
        data["creatorDisplayName"] = this.creatorDisplayName;
        data["title"] = this.title;
        if (Array.isArray(this.runtimeTasks)) {
            data["runtimeTasks"] = [];
            for (let item of this.runtimeTasks)
                data["runtimeTasks"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IRuntimeFlowViewModel {
    rootProcInstId?: string | undefined;
    businessKey?: string | undefined;
    creatorDisplayName?: string | undefined;
    title?: string | undefined;
    runtimeTasks?: RuntimeTask[] | undefined;
}

export class RuntimeFlowViewModelTCollectionWithPagination implements IRuntimeFlowViewModelTCollectionWithPagination {
    value?: RuntimeFlowViewModel[] | undefined;
    total?: number;

    constructor(data?: IRuntimeFlowViewModelTCollectionWithPagination) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(RuntimeFlowViewModel.fromJS(item));
            }
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): RuntimeFlowViewModelTCollectionWithPagination {
        data = typeof data === 'object' ? data : {};
        let result = new RuntimeFlowViewModelTCollectionWithPagination();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        data["total"] = this.total;
        return data; 
    }
}

export interface IRuntimeFlowViewModelTCollectionWithPagination {
    value?: RuntimeFlowViewModel[] | undefined;
    total?: number;
}

export class RuntimeMethodHandle implements IRuntimeMethodHandle {
    value?: IntPtr;

    constructor(data?: IRuntimeMethodHandle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"] ? IntPtr.fromJS(_data["value"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RuntimeMethodHandle {
        data = typeof data === 'object' ? data : {};
        let result = new RuntimeMethodHandle();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IRuntimeMethodHandle {
    value?: IntPtr;
}

export class RuntimeTask implements IRuntimeTask {
    taskId?: string | undefined;
    taskName?: string | undefined;
    assigneeUserDisplayName?: string | undefined;
    procDefName?: string | undefined;

    constructor(data?: IRuntimeTask) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.taskId = _data["taskId"];
            this.taskName = _data["taskName"];
            this.assigneeUserDisplayName = _data["assigneeUserDisplayName"];
            this.procDefName = _data["procDefName"];
        }
    }

    static fromJS(data: any): RuntimeTask {
        data = typeof data === 'object' ? data : {};
        let result = new RuntimeTask();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taskId"] = this.taskId;
        data["taskName"] = this.taskName;
        data["assigneeUserDisplayName"] = this.assigneeUserDisplayName;
        data["procDefName"] = this.procDefName;
        return data; 
    }
}

export interface IRuntimeTask {
    taskId?: string | undefined;
    taskName?: string | undefined;
    assigneeUserDisplayName?: string | undefined;
    procDefName?: string | undefined;
}

export class RuntimeTypeHandle implements IRuntimeTypeHandle {
    value?: IntPtr;

    constructor(data?: IRuntimeTypeHandle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"] ? IntPtr.fromJS(_data["value"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RuntimeTypeHandle {
        data = typeof data === 'object' ? data : {};
        let result = new RuntimeTypeHandle();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IRuntimeTypeHandle {
    value?: IntPtr;
}

export class RuntimeUserTaskTask implements IRuntimeUserTaskTask {
    userName?: string | undefined;
    userDisplayName?: string | undefined;
    phoneNumber?: string | undefined;
    departmentName?: string | undefined;
    taskId?: string | undefined;
    activityName?: string | undefined;
    assigneeDatetime?: string | undefined;
    activityInstanceId?: string | undefined;

    constructor(data?: IRuntimeUserTaskTask) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.userDisplayName = _data["userDisplayName"];
            this.phoneNumber = _data["phoneNumber"];
            this.departmentName = _data["departmentName"];
            this.taskId = _data["taskId"];
            this.activityName = _data["activityName"];
            this.assigneeDatetime = _data["assigneeDatetime"];
            this.activityInstanceId = _data["activityInstanceId"];
        }
    }

    static fromJS(data: any): RuntimeUserTaskTask {
        data = typeof data === 'object' ? data : {};
        let result = new RuntimeUserTaskTask();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["userDisplayName"] = this.userDisplayName;
        data["phoneNumber"] = this.phoneNumber;
        data["departmentName"] = this.departmentName;
        data["taskId"] = this.taskId;
        data["activityName"] = this.activityName;
        data["assigneeDatetime"] = this.assigneeDatetime;
        data["activityInstanceId"] = this.activityInstanceId;
        return data; 
    }
}

export interface IRuntimeUserTaskTask {
    userName?: string | undefined;
    userDisplayName?: string | undefined;
    phoneNumber?: string | undefined;
    departmentName?: string | undefined;
    taskId?: string | undefined;
    activityName?: string | undefined;
    assigneeDatetime?: string | undefined;
    activityInstanceId?: string | undefined;
}

export class RuntimeUserTaskTaskTCollection implements IRuntimeUserTaskTaskTCollection {
    value?: RuntimeUserTaskTask[] | undefined;

    constructor(data?: IRuntimeUserTaskTaskTCollection) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(RuntimeUserTaskTask.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RuntimeUserTaskTaskTCollection {
        data = typeof data === 'object' ? data : {};
        let result = new RuntimeUserTaskTaskTCollection();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IRuntimeUserTaskTaskTCollection {
    value?: RuntimeUserTaskTask[] | undefined;
}

export enum SecurityRuleSet {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class SendShortMessageViewModel implements ISendShortMessageViewModel {
    phoneNumbers?: string[] | undefined;
    message?: string | undefined;

    constructor(data?: ISendShortMessageViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["phoneNumbers"])) {
                this.phoneNumbers = [] as any;
                for (let item of _data["phoneNumbers"])
                    this.phoneNumbers!.push(item);
            }
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): SendShortMessageViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new SendShortMessageViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.phoneNumbers)) {
            data["phoneNumbers"] = [];
            for (let item of this.phoneNumbers)
                data["phoneNumbers"].push(item);
        }
        data["message"] = this.message;
        return data; 
    }
}

export interface ISendShortMessageViewModel {
    phoneNumbers?: string[] | undefined;
    message?: string | undefined;
}

export class StartProcessDefinitionResViewModel implements IStartProcessDefinitionResViewModel {
    taskId?: string | undefined;
    businessKey?: string | undefined;

    constructor(data?: IStartProcessDefinitionResViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.taskId = _data["taskId"];
            this.businessKey = _data["businessKey"];
        }
    }

    static fromJS(data: any): StartProcessDefinitionResViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new StartProcessDefinitionResViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taskId"] = this.taskId;
        data["businessKey"] = this.businessKey;
        return data; 
    }
}

export interface IStartProcessDefinitionResViewModel {
    taskId?: string | undefined;
    businessKey?: string | undefined;
}

/** 启动处理定义模型（Id和Key 二选一） */
export class StartProcessDefinitionViewModel implements IStartProcessDefinitionViewModel {
    processDefinitionId?: string | undefined;
    processDefinitionKey?: string | undefined;
    httpFileUris?: string[] | undefined;
    formFields?: FormField[] | undefined;
    isJustCreated?: boolean | undefined;

    constructor(data?: IStartProcessDefinitionViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.processDefinitionId = _data["processDefinitionId"];
            this.processDefinitionKey = _data["processDefinitionKey"];
            if (Array.isArray(_data["httpFileUris"])) {
                this.httpFileUris = [] as any;
                for (let item of _data["httpFileUris"])
                    this.httpFileUris!.push(item);
            }
            if (Array.isArray(_data["formFields"])) {
                this.formFields = [] as any;
                for (let item of _data["formFields"])
                    this.formFields!.push(FormField.fromJS(item));
            }
            this.isJustCreated = _data["isJustCreated"];
        }
    }

    static fromJS(data: any): StartProcessDefinitionViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new StartProcessDefinitionViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["processDefinitionId"] = this.processDefinitionId;
        data["processDefinitionKey"] = this.processDefinitionKey;
        if (Array.isArray(this.httpFileUris)) {
            data["httpFileUris"] = [];
            for (let item of this.httpFileUris)
                data["httpFileUris"].push(item);
        }
        if (Array.isArray(this.formFields)) {
            data["formFields"] = [];
            for (let item of this.formFields)
                data["formFields"].push(item.toJSON());
        }
        data["isJustCreated"] = this.isJustCreated;
        return data; 
    }
}

/** 启动处理定义模型（Id和Key 二选一） */
export interface IStartProcessDefinitionViewModel {
    processDefinitionId?: string | undefined;
    processDefinitionKey?: string | undefined;
    httpFileUris?: string[] | undefined;
    formFields?: FormField[] | undefined;
    isJustCreated?: boolean | undefined;
}

export class StorageItemModel implements IStorageItemModel {
    id?: string | undefined;
    payload?: any | undefined;

    constructor(data?: IStorageItemModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.payload = _data["payload"];
        }
    }

    static fromJS(data: any): StorageItemModel {
        data = typeof data === 'object' ? data : {};
        let result = new StorageItemModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["payload"] = this.payload;
        return data; 
    }
}

export interface IStorageItemModel {
    id?: string | undefined;
    payload?: any | undefined;
}

export class StringKeyValue implements IStringKeyValue {
    key?: string | undefined;
    value?: string | undefined;

    constructor(data?: IStringKeyValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): StringKeyValue {
        data = typeof data === 'object' ? data : {};
        let result = new StringKeyValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        return data; 
    }
}

export interface IStringKeyValue {
    key?: string | undefined;
    value?: string | undefined;
}

export class StructLayoutAttribute implements IStructLayoutAttribute {
    readonly typeId?: any;
    value?: LayoutKind;

    constructor(data?: IStructLayoutAttribute) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).typeId = _data["typeId"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): StructLayoutAttribute {
        data = typeof data === 'object' ? data : {};
        let result = new StructLayoutAttribute();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeId"] = this.typeId;
        data["value"] = this.value;
        return data; 
    }
}

export interface IStructLayoutAttribute {
    typeId?: any;
    value?: LayoutKind;
}

export class SuccessfulTokenResponse implements ISuccessfulTokenResponse {
    access_token?: string | undefined;
    token_type?: string | undefined;
    refresh_token?: string | undefined;
    expires_in?: number;
    id_token?: string | undefined;

    constructor(data?: ISuccessfulTokenResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.access_token = _data["access_token"];
            this.token_type = _data["token_type"];
            this.refresh_token = _data["refresh_token"];
            this.expires_in = _data["expires_in"];
            this.id_token = _data["id_token"];
        }
    }

    static fromJS(data: any): SuccessfulTokenResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SuccessfulTokenResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["access_token"] = this.access_token;
        data["token_type"] = this.token_type;
        data["refresh_token"] = this.refresh_token;
        data["expires_in"] = this.expires_in;
        data["id_token"] = this.id_token;
        return data; 
    }
}

export interface ISuccessfulTokenResponse {
    access_token?: string | undefined;
    token_type?: string | undefined;
    refresh_token?: string | undefined;
    expires_in?: number;
    id_token?: string | undefined;
}

export class TakebackActivityViewModel implements ITakebackActivityViewModel {
    takebackItems?: TakebackItem[] | undefined;
    reason?: string | undefined;

    constructor(data?: ITakebackActivityViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["takebackItems"])) {
                this.takebackItems = [] as any;
                for (let item of _data["takebackItems"])
                    this.takebackItems!.push(TakebackItem.fromJS(item));
            }
            this.reason = _data["reason"];
        }
    }

    static fromJS(data: any): TakebackActivityViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new TakebackActivityViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.takebackItems)) {
            data["takebackItems"] = [];
            for (let item of this.takebackItems)
                data["takebackItems"].push(item.toJSON());
        }
        data["reason"] = this.reason;
        return data; 
    }
}

export interface ITakebackActivityViewModel {
    takebackItems?: TakebackItem[] | undefined;
    reason?: string | undefined;
}

export class TakebackItem implements ITakebackItem {
    userName?: string | undefined;
    userDisplayName?: string | undefined;
    activityInstanceId?: string | undefined;

    constructor(data?: ITakebackItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.userDisplayName = _data["userDisplayName"];
            this.activityInstanceId = _data["activityInstanceId"];
        }
    }

    static fromJS(data: any): TakebackItem {
        data = typeof data === 'object' ? data : {};
        let result = new TakebackItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["userDisplayName"] = this.userDisplayName;
        data["activityInstanceId"] = this.activityInstanceId;
        return data; 
    }
}

export interface ITakebackItem {
    userName?: string | undefined;
    userDisplayName?: string | undefined;
    activityInstanceId?: string | undefined;
}

export class TaskDelegate implements ITaskDelegate {
    userName?: string | undefined;
    toUserName?: string | undefined;
    beginDateTime?: Date | undefined;
    endDateTime?: Date | undefined;

    constructor(data?: ITaskDelegate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.toUserName = _data["toUserName"];
            this.beginDateTime = _data["beginDateTime"] ? new Date(_data["beginDateTime"].toString()) : <any>undefined;
            this.endDateTime = _data["endDateTime"] ? new Date(_data["endDateTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TaskDelegate {
        data = typeof data === 'object' ? data : {};
        let result = new TaskDelegate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["toUserName"] = this.toUserName;
        data["beginDateTime"] = this.beginDateTime ? this.beginDateTime.toISOString() : <any>undefined;
        data["endDateTime"] = this.endDateTime ? this.endDateTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ITaskDelegate {
    userName?: string | undefined;
    toUserName?: string | undefined;
    beginDateTime?: Date | undefined;
    endDateTime?: Date | undefined;
}

export class TaskRedHatViewModel implements ITaskRedHatViewModel {
    fileName?: string | undefined;
    redHeatFileName?: string | undefined;

    constructor(data?: ITaskRedHatViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileName = _data["fileName"];
            this.redHeatFileName = _data["redHeatFileName"];
        }
    }

    static fromJS(data: any): TaskRedHatViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new TaskRedHatViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["redHeatFileName"] = this.redHeatFileName;
        return data; 
    }
}

export interface ITaskRedHatViewModel {
    fileName?: string | undefined;
    redHeatFileName?: string | undefined;
}

export class TempSaveTaskViewModel implements ITempSaveTaskViewModel {
    taskId?: string | undefined;
    opinion?: string | undefined;
    title?: string | undefined;
    maxEndDateTime?: string | undefined;
    formFields?: FormField[] | undefined;

    constructor(data?: ITempSaveTaskViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.taskId = _data["taskId"];
            this.opinion = _data["opinion"];
            this.title = _data["title"];
            this.maxEndDateTime = _data["maxEndDateTime"];
            if (Array.isArray(_data["formFields"])) {
                this.formFields = [] as any;
                for (let item of _data["formFields"])
                    this.formFields!.push(FormField.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TempSaveTaskViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new TempSaveTaskViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taskId"] = this.taskId;
        data["opinion"] = this.opinion;
        data["title"] = this.title;
        data["maxEndDateTime"] = this.maxEndDateTime;
        if (Array.isArray(this.formFields)) {
            data["formFields"] = [];
            for (let item of this.formFields)
                data["formFields"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITempSaveTaskViewModel {
    taskId?: string | undefined;
    opinion?: string | undefined;
    title?: string | undefined;
    maxEndDateTime?: string | undefined;
    formFields?: FormField[] | undefined;
}

export class TodoTaskByBusinessKey implements ITodoTaskByBusinessKey {
    userName?: string | undefined;
    name?: string | undefined;
    phoneNumber?: string | undefined;
    departmentName?: string | undefined;
    taskId?: string | undefined;
    activityName?: string | undefined;
    assigneeDatetime?: string | undefined;

    constructor(data?: ITodoTaskByBusinessKey) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.phoneNumber = _data["phoneNumber"];
            this.departmentName = _data["departmentName"];
            this.taskId = _data["taskId"];
            this.activityName = _data["activityName"];
            this.assigneeDatetime = _data["assigneeDatetime"];
        }
    }

    static fromJS(data: any): TodoTaskByBusinessKey {
        data = typeof data === 'object' ? data : {};
        let result = new TodoTaskByBusinessKey();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["phoneNumber"] = this.phoneNumber;
        data["departmentName"] = this.departmentName;
        data["taskId"] = this.taskId;
        data["activityName"] = this.activityName;
        data["assigneeDatetime"] = this.assigneeDatetime;
        return data; 
    }
}

export interface ITodoTaskByBusinessKey {
    userName?: string | undefined;
    name?: string | undefined;
    phoneNumber?: string | undefined;
    departmentName?: string | undefined;
    taskId?: string | undefined;
    activityName?: string | undefined;
    assigneeDatetime?: string | undefined;
}

export class TodoTaskViewModel implements ITodoTaskViewModel {
    taskId?: string | undefined;
    businessKey?: string | undefined;
    processInstanceId?: string | undefined;
    processDefineId?: string | undefined;
    processDefineKey?: string | undefined;
    processDefineName?: string | undefined;
    dateTime?: string | undefined;
    activityId?: string | undefined;
    flowStatus?: string | undefined;
    assignee?: UserReply;
    sender?: UserReply;
    isAssigneed?: boolean;
    /** 暂存意见 */
    tempSaveOpinion?: string | undefined;
    /** 是否是只读表单（不允许编辑） */
    isReadOnlyForm?: boolean;
    /** 整个流程已经结束？ */
    isFlowFinished?: boolean;
    form?: FormDto;

    constructor(data?: ITodoTaskViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.taskId = _data["taskId"];
            this.businessKey = _data["businessKey"];
            this.processInstanceId = _data["processInstanceId"];
            this.processDefineId = _data["processDefineId"];
            this.processDefineKey = _data["processDefineKey"];
            this.processDefineName = _data["processDefineName"];
            this.dateTime = _data["dateTime"];
            this.activityId = _data["activityId"];
            this.flowStatus = _data["flowStatus"];
            this.assignee = _data["assignee"] ? UserReply.fromJS(_data["assignee"]) : <any>undefined;
            this.sender = _data["sender"] ? UserReply.fromJS(_data["sender"]) : <any>undefined;
            this.isAssigneed = _data["isAssigneed"];
            this.tempSaveOpinion = _data["tempSaveOpinion"];
            this.isReadOnlyForm = _data["isReadOnlyForm"];
            this.isFlowFinished = _data["isFlowFinished"];
            this.form = _data["form"] ? FormDto.fromJS(_data["form"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TodoTaskViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new TodoTaskViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taskId"] = this.taskId;
        data["businessKey"] = this.businessKey;
        data["processInstanceId"] = this.processInstanceId;
        data["processDefineId"] = this.processDefineId;
        data["processDefineKey"] = this.processDefineKey;
        data["processDefineName"] = this.processDefineName;
        data["dateTime"] = this.dateTime;
        data["activityId"] = this.activityId;
        data["flowStatus"] = this.flowStatus;
        data["assignee"] = this.assignee ? this.assignee.toJSON() : <any>undefined;
        data["sender"] = this.sender ? this.sender.toJSON() : <any>undefined;
        data["isAssigneed"] = this.isAssigneed;
        data["tempSaveOpinion"] = this.tempSaveOpinion;
        data["isReadOnlyForm"] = this.isReadOnlyForm;
        data["isFlowFinished"] = this.isFlowFinished;
        data["form"] = this.form ? this.form.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ITodoTaskViewModel {
    taskId?: string | undefined;
    businessKey?: string | undefined;
    processInstanceId?: string | undefined;
    processDefineId?: string | undefined;
    processDefineKey?: string | undefined;
    processDefineName?: string | undefined;
    dateTime?: string | undefined;
    activityId?: string | undefined;
    flowStatus?: string | undefined;
    assignee?: UserReply;
    sender?: UserReply;
    isAssigneed?: boolean;
    /** 暂存意见 */
    tempSaveOpinion?: string | undefined;
    /** 是否是只读表单（不允许编辑） */
    isReadOnlyForm?: boolean;
    /** 整个流程已经结束？ */
    isFlowFinished?: boolean;
    form?: FormDto;
}

export class TodoTaskViewModelPaginationResult implements ITodoTaskViewModelPaginationResult {
    succeeded?: boolean;
    errorMessage?: string | undefined;
    rows?: TodoTaskViewModel[] | undefined;
    total?: number;
    pageSize?: number;

    constructor(data?: ITodoTaskViewModelPaginationResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.errorMessage = _data["errorMessage"];
            if (Array.isArray(_data["rows"])) {
                this.rows = [] as any;
                for (let item of _data["rows"])
                    this.rows!.push(TodoTaskViewModel.fromJS(item));
            }
            this.total = _data["total"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): TodoTaskViewModelPaginationResult {
        data = typeof data === 'object' ? data : {};
        let result = new TodoTaskViewModelPaginationResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["errorMessage"] = this.errorMessage;
        if (Array.isArray(this.rows)) {
            data["rows"] = [];
            for (let item of this.rows)
                data["rows"].push(item.toJSON());
        }
        data["total"] = this.total;
        data["pageSize"] = this.pageSize;
        return data; 
    }
}

export interface ITodoTaskViewModelPaginationResult {
    succeeded?: boolean;
    errorMessage?: string | undefined;
    rows?: TodoTaskViewModel[] | undefined;
    total?: number;
    pageSize?: number;
}

export class TokenErrorResponse implements ITokenErrorResponse {
    error?: string | undefined;

    constructor(data?: ITokenErrorResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): TokenErrorResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TokenErrorResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["error"] = this.error;
        return data; 
    }
}

export interface ITokenErrorResponse {
    error?: string | undefined;
}

export class Type implements IType {
    readonly name?: string;
    readonly customAttributes?: CustomAttributeData[];
    readonly isCollectible?: boolean;
    readonly metadataToken?: number;
    readonly isInterface?: boolean;
    memberType?: MemberTypes;
    readonly namespace?: string | undefined;
    readonly assemblyQualifiedName?: string | undefined;
    readonly fullName?: string | undefined;
    assembly?: Assembly;
    module?: Module;
    readonly isNested?: boolean;
    declaringType?: Type;
    declaringMethod?: MethodBase;
    reflectedType?: Type;
    underlyingSystemType?: Type;
    readonly isTypeDefinition?: boolean;
    readonly isArray?: boolean;
    readonly isByRef?: boolean;
    readonly isPointer?: boolean;
    readonly isConstructedGenericType?: boolean;
    readonly isGenericParameter?: boolean;
    readonly isGenericTypeParameter?: boolean;
    readonly isGenericMethodParameter?: boolean;
    readonly isGenericType?: boolean;
    readonly isGenericTypeDefinition?: boolean;
    readonly isSZArray?: boolean;
    readonly isVariableBoundArray?: boolean;
    readonly isByRefLike?: boolean;
    readonly hasElementType?: boolean;
    readonly genericTypeArguments?: Type[];
    readonly genericParameterPosition?: number;
    genericParameterAttributes?: GenericParameterAttributes;
    attributes?: TypeAttributes;
    readonly isAbstract?: boolean;
    readonly isImport?: boolean;
    readonly isSealed?: boolean;
    readonly isSpecialName?: boolean;
    readonly isClass?: boolean;
    readonly isNestedAssembly?: boolean;
    readonly isNestedFamANDAssem?: boolean;
    readonly isNestedFamily?: boolean;
    readonly isNestedFamORAssem?: boolean;
    readonly isNestedPrivate?: boolean;
    readonly isNestedPublic?: boolean;
    readonly isNotPublic?: boolean;
    readonly isPublic?: boolean;
    readonly isAutoLayout?: boolean;
    readonly isExplicitLayout?: boolean;
    readonly isLayoutSequential?: boolean;
    readonly isAnsiClass?: boolean;
    readonly isAutoClass?: boolean;
    readonly isUnicodeClass?: boolean;
    readonly isCOMObject?: boolean;
    readonly isContextful?: boolean;
    readonly isEnum?: boolean;
    readonly isMarshalByRef?: boolean;
    readonly isPrimitive?: boolean;
    readonly isValueType?: boolean;
    readonly isSignatureType?: boolean;
    readonly isSecurityCritical?: boolean;
    readonly isSecuritySafeCritical?: boolean;
    readonly isSecurityTransparent?: boolean;
    structLayoutAttribute?: StructLayoutAttribute;
    typeInitializer?: ConstructorInfo;
    typeHandle?: RuntimeTypeHandle;
    readonly guid?: string;
    baseType?: Type;
    readonly isSerializable?: boolean;
    readonly containsGenericParameters?: boolean;
    readonly isVisible?: boolean;

    constructor(data?: IType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["name"];
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
            (<any>this).isInterface = _data["isInterface"];
            this.memberType = _data["memberType"];
            (<any>this).namespace = _data["namespace"];
            (<any>this).assemblyQualifiedName = _data["assemblyQualifiedName"];
            (<any>this).fullName = _data["fullName"];
            this.assembly = _data["assembly"] ? Assembly.fromJS(_data["assembly"]) : <any>undefined;
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            (<any>this).isNested = _data["isNested"];
            this.declaringType = _data["declaringType"] ? Type.fromJS(_data["declaringType"]) : <any>undefined;
            this.declaringMethod = _data["declaringMethod"] ? MethodBase.fromJS(_data["declaringMethod"]) : <any>undefined;
            this.reflectedType = _data["reflectedType"] ? Type.fromJS(_data["reflectedType"]) : <any>undefined;
            this.underlyingSystemType = _data["underlyingSystemType"] ? Type.fromJS(_data["underlyingSystemType"]) : <any>undefined;
            (<any>this).isTypeDefinition = _data["isTypeDefinition"];
            (<any>this).isArray = _data["isArray"];
            (<any>this).isByRef = _data["isByRef"];
            (<any>this).isPointer = _data["isPointer"];
            (<any>this).isConstructedGenericType = _data["isConstructedGenericType"];
            (<any>this).isGenericParameter = _data["isGenericParameter"];
            (<any>this).isGenericTypeParameter = _data["isGenericTypeParameter"];
            (<any>this).isGenericMethodParameter = _data["isGenericMethodParameter"];
            (<any>this).isGenericType = _data["isGenericType"];
            (<any>this).isGenericTypeDefinition = _data["isGenericTypeDefinition"];
            (<any>this).isSZArray = _data["isSZArray"];
            (<any>this).isVariableBoundArray = _data["isVariableBoundArray"];
            (<any>this).isByRefLike = _data["isByRefLike"];
            (<any>this).hasElementType = _data["hasElementType"];
            if (Array.isArray(_data["genericTypeArguments"])) {
                (<any>this).genericTypeArguments = [] as any;
                for (let item of _data["genericTypeArguments"])
                    (<any>this).genericTypeArguments!.push(Type.fromJS(item));
            }
            (<any>this).genericParameterPosition = _data["genericParameterPosition"];
            this.genericParameterAttributes = _data["genericParameterAttributes"];
            this.attributes = _data["attributes"];
            (<any>this).isAbstract = _data["isAbstract"];
            (<any>this).isImport = _data["isImport"];
            (<any>this).isSealed = _data["isSealed"];
            (<any>this).isSpecialName = _data["isSpecialName"];
            (<any>this).isClass = _data["isClass"];
            (<any>this).isNestedAssembly = _data["isNestedAssembly"];
            (<any>this).isNestedFamANDAssem = _data["isNestedFamANDAssem"];
            (<any>this).isNestedFamily = _data["isNestedFamily"];
            (<any>this).isNestedFamORAssem = _data["isNestedFamORAssem"];
            (<any>this).isNestedPrivate = _data["isNestedPrivate"];
            (<any>this).isNestedPublic = _data["isNestedPublic"];
            (<any>this).isNotPublic = _data["isNotPublic"];
            (<any>this).isPublic = _data["isPublic"];
            (<any>this).isAutoLayout = _data["isAutoLayout"];
            (<any>this).isExplicitLayout = _data["isExplicitLayout"];
            (<any>this).isLayoutSequential = _data["isLayoutSequential"];
            (<any>this).isAnsiClass = _data["isAnsiClass"];
            (<any>this).isAutoClass = _data["isAutoClass"];
            (<any>this).isUnicodeClass = _data["isUnicodeClass"];
            (<any>this).isCOMObject = _data["isCOMObject"];
            (<any>this).isContextful = _data["isContextful"];
            (<any>this).isEnum = _data["isEnum"];
            (<any>this).isMarshalByRef = _data["isMarshalByRef"];
            (<any>this).isPrimitive = _data["isPrimitive"];
            (<any>this).isValueType = _data["isValueType"];
            (<any>this).isSignatureType = _data["isSignatureType"];
            (<any>this).isSecurityCritical = _data["isSecurityCritical"];
            (<any>this).isSecuritySafeCritical = _data["isSecuritySafeCritical"];
            (<any>this).isSecurityTransparent = _data["isSecurityTransparent"];
            this.structLayoutAttribute = _data["structLayoutAttribute"] ? StructLayoutAttribute.fromJS(_data["structLayoutAttribute"]) : <any>undefined;
            this.typeInitializer = _data["typeInitializer"] ? ConstructorInfo.fromJS(_data["typeInitializer"]) : <any>undefined;
            this.typeHandle = _data["typeHandle"] ? RuntimeTypeHandle.fromJS(_data["typeHandle"]) : <any>undefined;
            (<any>this).guid = _data["guid"];
            this.baseType = _data["baseType"] ? Type.fromJS(_data["baseType"]) : <any>undefined;
            (<any>this).isSerializable = _data["isSerializable"];
            (<any>this).containsGenericParameters = _data["containsGenericParameters"];
            (<any>this).isVisible = _data["isVisible"];
        }
    }

    static fromJS(data: any): Type {
        data = typeof data === 'object' ? data : {};
        let result = new Type();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        data["isInterface"] = this.isInterface;
        data["memberType"] = this.memberType;
        data["namespace"] = this.namespace;
        data["assemblyQualifiedName"] = this.assemblyQualifiedName;
        data["fullName"] = this.fullName;
        data["assembly"] = this.assembly ? this.assembly.toJSON() : <any>undefined;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        data["isNested"] = this.isNested;
        data["declaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["declaringMethod"] = this.declaringMethod ? this.declaringMethod.toJSON() : <any>undefined;
        data["reflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["underlyingSystemType"] = this.underlyingSystemType ? this.underlyingSystemType.toJSON() : <any>undefined;
        data["isTypeDefinition"] = this.isTypeDefinition;
        data["isArray"] = this.isArray;
        data["isByRef"] = this.isByRef;
        data["isPointer"] = this.isPointer;
        data["isConstructedGenericType"] = this.isConstructedGenericType;
        data["isGenericParameter"] = this.isGenericParameter;
        data["isGenericTypeParameter"] = this.isGenericTypeParameter;
        data["isGenericMethodParameter"] = this.isGenericMethodParameter;
        data["isGenericType"] = this.isGenericType;
        data["isGenericTypeDefinition"] = this.isGenericTypeDefinition;
        data["isSZArray"] = this.isSZArray;
        data["isVariableBoundArray"] = this.isVariableBoundArray;
        data["isByRefLike"] = this.isByRefLike;
        data["hasElementType"] = this.hasElementType;
        if (Array.isArray(this.genericTypeArguments)) {
            data["genericTypeArguments"] = [];
            for (let item of this.genericTypeArguments)
                data["genericTypeArguments"].push(item.toJSON());
        }
        data["genericParameterPosition"] = this.genericParameterPosition;
        data["genericParameterAttributes"] = this.genericParameterAttributes;
        data["attributes"] = this.attributes;
        data["isAbstract"] = this.isAbstract;
        data["isImport"] = this.isImport;
        data["isSealed"] = this.isSealed;
        data["isSpecialName"] = this.isSpecialName;
        data["isClass"] = this.isClass;
        data["isNestedAssembly"] = this.isNestedAssembly;
        data["isNestedFamANDAssem"] = this.isNestedFamANDAssem;
        data["isNestedFamily"] = this.isNestedFamily;
        data["isNestedFamORAssem"] = this.isNestedFamORAssem;
        data["isNestedPrivate"] = this.isNestedPrivate;
        data["isNestedPublic"] = this.isNestedPublic;
        data["isNotPublic"] = this.isNotPublic;
        data["isPublic"] = this.isPublic;
        data["isAutoLayout"] = this.isAutoLayout;
        data["isExplicitLayout"] = this.isExplicitLayout;
        data["isLayoutSequential"] = this.isLayoutSequential;
        data["isAnsiClass"] = this.isAnsiClass;
        data["isAutoClass"] = this.isAutoClass;
        data["isUnicodeClass"] = this.isUnicodeClass;
        data["isCOMObject"] = this.isCOMObject;
        data["isContextful"] = this.isContextful;
        data["isEnum"] = this.isEnum;
        data["isMarshalByRef"] = this.isMarshalByRef;
        data["isPrimitive"] = this.isPrimitive;
        data["isValueType"] = this.isValueType;
        data["isSignatureType"] = this.isSignatureType;
        data["isSecurityCritical"] = this.isSecurityCritical;
        data["isSecuritySafeCritical"] = this.isSecuritySafeCritical;
        data["isSecurityTransparent"] = this.isSecurityTransparent;
        data["structLayoutAttribute"] = this.structLayoutAttribute ? this.structLayoutAttribute.toJSON() : <any>undefined;
        data["typeInitializer"] = this.typeInitializer ? this.typeInitializer.toJSON() : <any>undefined;
        data["typeHandle"] = this.typeHandle ? this.typeHandle.toJSON() : <any>undefined;
        data["guid"] = this.guid;
        data["baseType"] = this.baseType ? this.baseType.toJSON() : <any>undefined;
        data["isSerializable"] = this.isSerializable;
        data["containsGenericParameters"] = this.containsGenericParameters;
        data["isVisible"] = this.isVisible;
        return data; 
    }
}

export interface IType {
    name?: string;
    customAttributes?: CustomAttributeData[];
    isCollectible?: boolean;
    metadataToken?: number;
    isInterface?: boolean;
    memberType?: MemberTypes;
    namespace?: string | undefined;
    assemblyQualifiedName?: string | undefined;
    fullName?: string | undefined;
    assembly?: Assembly;
    module?: Module;
    isNested?: boolean;
    declaringType?: Type;
    declaringMethod?: MethodBase;
    reflectedType?: Type;
    underlyingSystemType?: Type;
    isTypeDefinition?: boolean;
    isArray?: boolean;
    isByRef?: boolean;
    isPointer?: boolean;
    isConstructedGenericType?: boolean;
    isGenericParameter?: boolean;
    isGenericTypeParameter?: boolean;
    isGenericMethodParameter?: boolean;
    isGenericType?: boolean;
    isGenericTypeDefinition?: boolean;
    isSZArray?: boolean;
    isVariableBoundArray?: boolean;
    isByRefLike?: boolean;
    hasElementType?: boolean;
    genericTypeArguments?: Type[];
    genericParameterPosition?: number;
    genericParameterAttributes?: GenericParameterAttributes;
    attributes?: TypeAttributes;
    isAbstract?: boolean;
    isImport?: boolean;
    isSealed?: boolean;
    isSpecialName?: boolean;
    isClass?: boolean;
    isNestedAssembly?: boolean;
    isNestedFamANDAssem?: boolean;
    isNestedFamily?: boolean;
    isNestedFamORAssem?: boolean;
    isNestedPrivate?: boolean;
    isNestedPublic?: boolean;
    isNotPublic?: boolean;
    isPublic?: boolean;
    isAutoLayout?: boolean;
    isExplicitLayout?: boolean;
    isLayoutSequential?: boolean;
    isAnsiClass?: boolean;
    isAutoClass?: boolean;
    isUnicodeClass?: boolean;
    isCOMObject?: boolean;
    isContextful?: boolean;
    isEnum?: boolean;
    isMarshalByRef?: boolean;
    isPrimitive?: boolean;
    isValueType?: boolean;
    isSignatureType?: boolean;
    isSecurityCritical?: boolean;
    isSecuritySafeCritical?: boolean;
    isSecurityTransparent?: boolean;
    structLayoutAttribute?: StructLayoutAttribute;
    typeInitializer?: ConstructorInfo;
    typeHandle?: RuntimeTypeHandle;
    guid?: string;
    baseType?: Type;
    isSerializable?: boolean;
    containsGenericParameters?: boolean;
    isVisible?: boolean;
}

export enum TypeAttributes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _16 = 16,
    _24 = 24,
    _32 = 32,
    _128 = 128,
    _256 = 256,
    _1024 = 1024,
    _2048 = 2048,
    _4096 = 4096,
    _8192 = 8192,
    _16384 = 16384,
    _65536 = 65536,
    _131072 = 131072,
    _196608 = 196608,
    _262144 = 262144,
    _264192 = 264192,
    _1048576 = 1048576,
    _12582912 = 12582912,
}

export class TypeInfo implements ITypeInfo {
    readonly name?: string;
    readonly customAttributes?: CustomAttributeData[];
    readonly isCollectible?: boolean;
    readonly metadataToken?: number;
    readonly isInterface?: boolean;
    memberType?: MemberTypes;
    readonly namespace?: string | undefined;
    readonly assemblyQualifiedName?: string | undefined;
    readonly fullName?: string | undefined;
    assembly?: Assembly;
    module?: Module;
    readonly isNested?: boolean;
    declaringType?: Type;
    declaringMethod?: MethodBase;
    reflectedType?: Type;
    underlyingSystemType?: Type;
    readonly isTypeDefinition?: boolean;
    readonly isArray?: boolean;
    readonly isByRef?: boolean;
    readonly isPointer?: boolean;
    readonly isConstructedGenericType?: boolean;
    readonly isGenericParameter?: boolean;
    readonly isGenericTypeParameter?: boolean;
    readonly isGenericMethodParameter?: boolean;
    readonly isGenericType?: boolean;
    readonly isGenericTypeDefinition?: boolean;
    readonly isSZArray?: boolean;
    readonly isVariableBoundArray?: boolean;
    readonly isByRefLike?: boolean;
    readonly hasElementType?: boolean;
    readonly genericTypeArguments?: Type[];
    readonly genericParameterPosition?: number;
    genericParameterAttributes?: GenericParameterAttributes;
    attributes?: TypeAttributes;
    readonly isAbstract?: boolean;
    readonly isImport?: boolean;
    readonly isSealed?: boolean;
    readonly isSpecialName?: boolean;
    readonly isClass?: boolean;
    readonly isNestedAssembly?: boolean;
    readonly isNestedFamANDAssem?: boolean;
    readonly isNestedFamily?: boolean;
    readonly isNestedFamORAssem?: boolean;
    readonly isNestedPrivate?: boolean;
    readonly isNestedPublic?: boolean;
    readonly isNotPublic?: boolean;
    readonly isPublic?: boolean;
    readonly isAutoLayout?: boolean;
    readonly isExplicitLayout?: boolean;
    readonly isLayoutSequential?: boolean;
    readonly isAnsiClass?: boolean;
    readonly isAutoClass?: boolean;
    readonly isUnicodeClass?: boolean;
    readonly isCOMObject?: boolean;
    readonly isContextful?: boolean;
    readonly isEnum?: boolean;
    readonly isMarshalByRef?: boolean;
    readonly isPrimitive?: boolean;
    readonly isValueType?: boolean;
    readonly isSignatureType?: boolean;
    readonly isSecurityCritical?: boolean;
    readonly isSecuritySafeCritical?: boolean;
    readonly isSecurityTransparent?: boolean;
    structLayoutAttribute?: StructLayoutAttribute;
    typeInitializer?: ConstructorInfo;
    typeHandle?: RuntimeTypeHandle;
    readonly guid?: string;
    baseType?: Type;
    readonly isSerializable?: boolean;
    readonly containsGenericParameters?: boolean;
    readonly isVisible?: boolean;
    readonly genericTypeParameters?: Type[];
    readonly declaredConstructors?: ConstructorInfo[];
    readonly declaredEvents?: EventInfo[];
    readonly declaredFields?: FieldInfo[];
    readonly declaredMembers?: MemberInfo[];
    readonly declaredMethods?: MethodInfo[];
    readonly declaredNestedTypes?: TypeInfo[];
    readonly declaredProperties?: PropertyInfo[];
    readonly implementedInterfaces?: Type[];

    constructor(data?: ITypeInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["name"];
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
            (<any>this).isInterface = _data["isInterface"];
            this.memberType = _data["memberType"];
            (<any>this).namespace = _data["namespace"];
            (<any>this).assemblyQualifiedName = _data["assemblyQualifiedName"];
            (<any>this).fullName = _data["fullName"];
            this.assembly = _data["assembly"] ? Assembly.fromJS(_data["assembly"]) : <any>undefined;
            this.module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            (<any>this).isNested = _data["isNested"];
            this.declaringType = _data["declaringType"] ? Type.fromJS(_data["declaringType"]) : <any>undefined;
            this.declaringMethod = _data["declaringMethod"] ? MethodBase.fromJS(_data["declaringMethod"]) : <any>undefined;
            this.reflectedType = _data["reflectedType"] ? Type.fromJS(_data["reflectedType"]) : <any>undefined;
            this.underlyingSystemType = _data["underlyingSystemType"] ? Type.fromJS(_data["underlyingSystemType"]) : <any>undefined;
            (<any>this).isTypeDefinition = _data["isTypeDefinition"];
            (<any>this).isArray = _data["isArray"];
            (<any>this).isByRef = _data["isByRef"];
            (<any>this).isPointer = _data["isPointer"];
            (<any>this).isConstructedGenericType = _data["isConstructedGenericType"];
            (<any>this).isGenericParameter = _data["isGenericParameter"];
            (<any>this).isGenericTypeParameter = _data["isGenericTypeParameter"];
            (<any>this).isGenericMethodParameter = _data["isGenericMethodParameter"];
            (<any>this).isGenericType = _data["isGenericType"];
            (<any>this).isGenericTypeDefinition = _data["isGenericTypeDefinition"];
            (<any>this).isSZArray = _data["isSZArray"];
            (<any>this).isVariableBoundArray = _data["isVariableBoundArray"];
            (<any>this).isByRefLike = _data["isByRefLike"];
            (<any>this).hasElementType = _data["hasElementType"];
            if (Array.isArray(_data["genericTypeArguments"])) {
                (<any>this).genericTypeArguments = [] as any;
                for (let item of _data["genericTypeArguments"])
                    (<any>this).genericTypeArguments!.push(Type.fromJS(item));
            }
            (<any>this).genericParameterPosition = _data["genericParameterPosition"];
            this.genericParameterAttributes = _data["genericParameterAttributes"];
            this.attributes = _data["attributes"];
            (<any>this).isAbstract = _data["isAbstract"];
            (<any>this).isImport = _data["isImport"];
            (<any>this).isSealed = _data["isSealed"];
            (<any>this).isSpecialName = _data["isSpecialName"];
            (<any>this).isClass = _data["isClass"];
            (<any>this).isNestedAssembly = _data["isNestedAssembly"];
            (<any>this).isNestedFamANDAssem = _data["isNestedFamANDAssem"];
            (<any>this).isNestedFamily = _data["isNestedFamily"];
            (<any>this).isNestedFamORAssem = _data["isNestedFamORAssem"];
            (<any>this).isNestedPrivate = _data["isNestedPrivate"];
            (<any>this).isNestedPublic = _data["isNestedPublic"];
            (<any>this).isNotPublic = _data["isNotPublic"];
            (<any>this).isPublic = _data["isPublic"];
            (<any>this).isAutoLayout = _data["isAutoLayout"];
            (<any>this).isExplicitLayout = _data["isExplicitLayout"];
            (<any>this).isLayoutSequential = _data["isLayoutSequential"];
            (<any>this).isAnsiClass = _data["isAnsiClass"];
            (<any>this).isAutoClass = _data["isAutoClass"];
            (<any>this).isUnicodeClass = _data["isUnicodeClass"];
            (<any>this).isCOMObject = _data["isCOMObject"];
            (<any>this).isContextful = _data["isContextful"];
            (<any>this).isEnum = _data["isEnum"];
            (<any>this).isMarshalByRef = _data["isMarshalByRef"];
            (<any>this).isPrimitive = _data["isPrimitive"];
            (<any>this).isValueType = _data["isValueType"];
            (<any>this).isSignatureType = _data["isSignatureType"];
            (<any>this).isSecurityCritical = _data["isSecurityCritical"];
            (<any>this).isSecuritySafeCritical = _data["isSecuritySafeCritical"];
            (<any>this).isSecurityTransparent = _data["isSecurityTransparent"];
            this.structLayoutAttribute = _data["structLayoutAttribute"] ? StructLayoutAttribute.fromJS(_data["structLayoutAttribute"]) : <any>undefined;
            this.typeInitializer = _data["typeInitializer"] ? ConstructorInfo.fromJS(_data["typeInitializer"]) : <any>undefined;
            this.typeHandle = _data["typeHandle"] ? RuntimeTypeHandle.fromJS(_data["typeHandle"]) : <any>undefined;
            (<any>this).guid = _data["guid"];
            this.baseType = _data["baseType"] ? Type.fromJS(_data["baseType"]) : <any>undefined;
            (<any>this).isSerializable = _data["isSerializable"];
            (<any>this).containsGenericParameters = _data["containsGenericParameters"];
            (<any>this).isVisible = _data["isVisible"];
            if (Array.isArray(_data["genericTypeParameters"])) {
                (<any>this).genericTypeParameters = [] as any;
                for (let item of _data["genericTypeParameters"])
                    (<any>this).genericTypeParameters!.push(Type.fromJS(item));
            }
            if (Array.isArray(_data["declaredConstructors"])) {
                (<any>this).declaredConstructors = [] as any;
                for (let item of _data["declaredConstructors"])
                    (<any>this).declaredConstructors!.push(ConstructorInfo.fromJS(item));
            }
            if (Array.isArray(_data["declaredEvents"])) {
                (<any>this).declaredEvents = [] as any;
                for (let item of _data["declaredEvents"])
                    (<any>this).declaredEvents!.push(EventInfo.fromJS(item));
            }
            if (Array.isArray(_data["declaredFields"])) {
                (<any>this).declaredFields = [] as any;
                for (let item of _data["declaredFields"])
                    (<any>this).declaredFields!.push(FieldInfo.fromJS(item));
            }
            if (Array.isArray(_data["declaredMembers"])) {
                (<any>this).declaredMembers = [] as any;
                for (let item of _data["declaredMembers"])
                    (<any>this).declaredMembers!.push(MemberInfo.fromJS(item));
            }
            if (Array.isArray(_data["declaredMethods"])) {
                (<any>this).declaredMethods = [] as any;
                for (let item of _data["declaredMethods"])
                    (<any>this).declaredMethods!.push(MethodInfo.fromJS(item));
            }
            if (Array.isArray(_data["declaredNestedTypes"])) {
                (<any>this).declaredNestedTypes = [] as any;
                for (let item of _data["declaredNestedTypes"])
                    (<any>this).declaredNestedTypes!.push(TypeInfo.fromJS(item));
            }
            if (Array.isArray(_data["declaredProperties"])) {
                (<any>this).declaredProperties = [] as any;
                for (let item of _data["declaredProperties"])
                    (<any>this).declaredProperties!.push(PropertyInfo.fromJS(item));
            }
            if (Array.isArray(_data["implementedInterfaces"])) {
                (<any>this).implementedInterfaces = [] as any;
                for (let item of _data["implementedInterfaces"])
                    (<any>this).implementedInterfaces!.push(Type.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TypeInfo {
        data = typeof data === 'object' ? data : {};
        let result = new TypeInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        data["isInterface"] = this.isInterface;
        data["memberType"] = this.memberType;
        data["namespace"] = this.namespace;
        data["assemblyQualifiedName"] = this.assemblyQualifiedName;
        data["fullName"] = this.fullName;
        data["assembly"] = this.assembly ? this.assembly.toJSON() : <any>undefined;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        data["isNested"] = this.isNested;
        data["declaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["declaringMethod"] = this.declaringMethod ? this.declaringMethod.toJSON() : <any>undefined;
        data["reflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["underlyingSystemType"] = this.underlyingSystemType ? this.underlyingSystemType.toJSON() : <any>undefined;
        data["isTypeDefinition"] = this.isTypeDefinition;
        data["isArray"] = this.isArray;
        data["isByRef"] = this.isByRef;
        data["isPointer"] = this.isPointer;
        data["isConstructedGenericType"] = this.isConstructedGenericType;
        data["isGenericParameter"] = this.isGenericParameter;
        data["isGenericTypeParameter"] = this.isGenericTypeParameter;
        data["isGenericMethodParameter"] = this.isGenericMethodParameter;
        data["isGenericType"] = this.isGenericType;
        data["isGenericTypeDefinition"] = this.isGenericTypeDefinition;
        data["isSZArray"] = this.isSZArray;
        data["isVariableBoundArray"] = this.isVariableBoundArray;
        data["isByRefLike"] = this.isByRefLike;
        data["hasElementType"] = this.hasElementType;
        if (Array.isArray(this.genericTypeArguments)) {
            data["genericTypeArguments"] = [];
            for (let item of this.genericTypeArguments)
                data["genericTypeArguments"].push(item.toJSON());
        }
        data["genericParameterPosition"] = this.genericParameterPosition;
        data["genericParameterAttributes"] = this.genericParameterAttributes;
        data["attributes"] = this.attributes;
        data["isAbstract"] = this.isAbstract;
        data["isImport"] = this.isImport;
        data["isSealed"] = this.isSealed;
        data["isSpecialName"] = this.isSpecialName;
        data["isClass"] = this.isClass;
        data["isNestedAssembly"] = this.isNestedAssembly;
        data["isNestedFamANDAssem"] = this.isNestedFamANDAssem;
        data["isNestedFamily"] = this.isNestedFamily;
        data["isNestedFamORAssem"] = this.isNestedFamORAssem;
        data["isNestedPrivate"] = this.isNestedPrivate;
        data["isNestedPublic"] = this.isNestedPublic;
        data["isNotPublic"] = this.isNotPublic;
        data["isPublic"] = this.isPublic;
        data["isAutoLayout"] = this.isAutoLayout;
        data["isExplicitLayout"] = this.isExplicitLayout;
        data["isLayoutSequential"] = this.isLayoutSequential;
        data["isAnsiClass"] = this.isAnsiClass;
        data["isAutoClass"] = this.isAutoClass;
        data["isUnicodeClass"] = this.isUnicodeClass;
        data["isCOMObject"] = this.isCOMObject;
        data["isContextful"] = this.isContextful;
        data["isEnum"] = this.isEnum;
        data["isMarshalByRef"] = this.isMarshalByRef;
        data["isPrimitive"] = this.isPrimitive;
        data["isValueType"] = this.isValueType;
        data["isSignatureType"] = this.isSignatureType;
        data["isSecurityCritical"] = this.isSecurityCritical;
        data["isSecuritySafeCritical"] = this.isSecuritySafeCritical;
        data["isSecurityTransparent"] = this.isSecurityTransparent;
        data["structLayoutAttribute"] = this.structLayoutAttribute ? this.structLayoutAttribute.toJSON() : <any>undefined;
        data["typeInitializer"] = this.typeInitializer ? this.typeInitializer.toJSON() : <any>undefined;
        data["typeHandle"] = this.typeHandle ? this.typeHandle.toJSON() : <any>undefined;
        data["guid"] = this.guid;
        data["baseType"] = this.baseType ? this.baseType.toJSON() : <any>undefined;
        data["isSerializable"] = this.isSerializable;
        data["containsGenericParameters"] = this.containsGenericParameters;
        data["isVisible"] = this.isVisible;
        if (Array.isArray(this.genericTypeParameters)) {
            data["genericTypeParameters"] = [];
            for (let item of this.genericTypeParameters)
                data["genericTypeParameters"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredConstructors)) {
            data["declaredConstructors"] = [];
            for (let item of this.declaredConstructors)
                data["declaredConstructors"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredEvents)) {
            data["declaredEvents"] = [];
            for (let item of this.declaredEvents)
                data["declaredEvents"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredFields)) {
            data["declaredFields"] = [];
            for (let item of this.declaredFields)
                data["declaredFields"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredMembers)) {
            data["declaredMembers"] = [];
            for (let item of this.declaredMembers)
                data["declaredMembers"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredMethods)) {
            data["declaredMethods"] = [];
            for (let item of this.declaredMethods)
                data["declaredMethods"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredNestedTypes)) {
            data["declaredNestedTypes"] = [];
            for (let item of this.declaredNestedTypes)
                data["declaredNestedTypes"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredProperties)) {
            data["declaredProperties"] = [];
            for (let item of this.declaredProperties)
                data["declaredProperties"].push(item.toJSON());
        }
        if (Array.isArray(this.implementedInterfaces)) {
            data["implementedInterfaces"] = [];
            for (let item of this.implementedInterfaces)
                data["implementedInterfaces"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITypeInfo {
    name?: string;
    customAttributes?: CustomAttributeData[];
    isCollectible?: boolean;
    metadataToken?: number;
    isInterface?: boolean;
    memberType?: MemberTypes;
    namespace?: string | undefined;
    assemblyQualifiedName?: string | undefined;
    fullName?: string | undefined;
    assembly?: Assembly;
    module?: Module;
    isNested?: boolean;
    declaringType?: Type;
    declaringMethod?: MethodBase;
    reflectedType?: Type;
    underlyingSystemType?: Type;
    isTypeDefinition?: boolean;
    isArray?: boolean;
    isByRef?: boolean;
    isPointer?: boolean;
    isConstructedGenericType?: boolean;
    isGenericParameter?: boolean;
    isGenericTypeParameter?: boolean;
    isGenericMethodParameter?: boolean;
    isGenericType?: boolean;
    isGenericTypeDefinition?: boolean;
    isSZArray?: boolean;
    isVariableBoundArray?: boolean;
    isByRefLike?: boolean;
    hasElementType?: boolean;
    genericTypeArguments?: Type[];
    genericParameterPosition?: number;
    genericParameterAttributes?: GenericParameterAttributes;
    attributes?: TypeAttributes;
    isAbstract?: boolean;
    isImport?: boolean;
    isSealed?: boolean;
    isSpecialName?: boolean;
    isClass?: boolean;
    isNestedAssembly?: boolean;
    isNestedFamANDAssem?: boolean;
    isNestedFamily?: boolean;
    isNestedFamORAssem?: boolean;
    isNestedPrivate?: boolean;
    isNestedPublic?: boolean;
    isNotPublic?: boolean;
    isPublic?: boolean;
    isAutoLayout?: boolean;
    isExplicitLayout?: boolean;
    isLayoutSequential?: boolean;
    isAnsiClass?: boolean;
    isAutoClass?: boolean;
    isUnicodeClass?: boolean;
    isCOMObject?: boolean;
    isContextful?: boolean;
    isEnum?: boolean;
    isMarshalByRef?: boolean;
    isPrimitive?: boolean;
    isValueType?: boolean;
    isSignatureType?: boolean;
    isSecurityCritical?: boolean;
    isSecuritySafeCritical?: boolean;
    isSecurityTransparent?: boolean;
    structLayoutAttribute?: StructLayoutAttribute;
    typeInitializer?: ConstructorInfo;
    typeHandle?: RuntimeTypeHandle;
    guid?: string;
    baseType?: Type;
    isSerializable?: boolean;
    containsGenericParameters?: boolean;
    isVisible?: boolean;
    genericTypeParameters?: Type[];
    declaredConstructors?: ConstructorInfo[];
    declaredEvents?: EventInfo[];
    declaredFields?: FieldInfo[];
    declaredMembers?: MemberInfo[];
    declaredMethods?: MethodInfo[];
    declaredNestedTypes?: TypeInfo[];
    declaredProperties?: PropertyInfo[];
    implementedInterfaces?: Type[];
}

export class UnReadCountViewModel implements IUnReadCountViewModel {
    userName?: string | undefined;
    password?: string | undefined;

    constructor(data?: IUnReadCountViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): UnReadCountViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new UnReadCountViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        return data; 
    }
}

export interface IUnReadCountViewModel {
    userName?: string | undefined;
    password?: string | undefined;
}

export class UpdateFormOpinionViewModel implements IUpdateFormOpinionViewModel {
    id?: string | undefined;
    text?: string | undefined;

    constructor(data?: IUpdateFormOpinionViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.text = _data["text"];
        }
    }

    static fromJS(data: any): UpdateFormOpinionViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFormOpinionViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["text"] = this.text;
        return data; 
    }
}

export interface IUpdateFormOpinionViewModel {
    id?: string | undefined;
    text?: string | undefined;
}

export class UpdateUserOpinionViewModel implements IUpdateUserOpinionViewModel {
    userName?: string | undefined;
    newOpinionText?: string | undefined;
    remark?: string | undefined;

    constructor(data?: IUpdateUserOpinionViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.newOpinionText = _data["newOpinionText"];
            this.remark = _data["remark"];
        }
    }

    static fromJS(data: any): UpdateUserOpinionViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserOpinionViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["newOpinionText"] = this.newOpinionText;
        data["remark"] = this.remark;
        return data; 
    }
}

export interface IUpdateUserOpinionViewModel {
    userName?: string | undefined;
    newOpinionText?: string | undefined;
    remark?: string | undefined;
}

export class UpdateUserOrderInDepartmentViewModel implements IUpdateUserOrderInDepartmentViewModel {
    order?: number | undefined;
    isLeader?: boolean | undefined;

    constructor(data?: IUpdateUserOrderInDepartmentViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.order = _data["order"];
            this.isLeader = _data["isLeader"];
        }
    }

    static fromJS(data: any): UpdateUserOrderInDepartmentViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserOrderInDepartmentViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["order"] = this.order;
        data["isLeader"] = this.isLeader;
        return data; 
    }
}

export interface IUpdateUserOrderInDepartmentViewModel {
    order?: number | undefined;
    isLeader?: boolean | undefined;
}

export class UpdateUserTaskViewModel implements IUpdateUserTaskViewModel {
    processDefKey?: string | undefined;
    processDefName?: string | undefined;
    activityId?: string | undefined;
    activityName?: string | undefined;
    queryMode?: QueryMode;
    assigneeUsers?: AssigneeUser[] | undefined;
    /** 能上传附件或者编辑附件 */
    canUploadOrUpdateFiles?: boolean;
    /** 能够编辑表单 */
    canEditForm?: boolean;

    constructor(data?: IUpdateUserTaskViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.processDefKey = _data["processDefKey"];
            this.processDefName = _data["processDefName"];
            this.activityId = _data["activityId"];
            this.activityName = _data["activityName"];
            this.queryMode = _data["queryMode"];
            if (Array.isArray(_data["assigneeUsers"])) {
                this.assigneeUsers = [] as any;
                for (let item of _data["assigneeUsers"])
                    this.assigneeUsers!.push(AssigneeUser.fromJS(item));
            }
            this.canUploadOrUpdateFiles = _data["canUploadOrUpdateFiles"];
            this.canEditForm = _data["canEditForm"];
        }
    }

    static fromJS(data: any): UpdateUserTaskViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserTaskViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["processDefKey"] = this.processDefKey;
        data["processDefName"] = this.processDefName;
        data["activityId"] = this.activityId;
        data["activityName"] = this.activityName;
        data["queryMode"] = this.queryMode;
        if (Array.isArray(this.assigneeUsers)) {
            data["assigneeUsers"] = [];
            for (let item of this.assigneeUsers)
                data["assigneeUsers"].push(item.toJSON());
        }
        data["canUploadOrUpdateFiles"] = this.canUploadOrUpdateFiles;
        data["canEditForm"] = this.canEditForm;
        return data; 
    }
}

export interface IUpdateUserTaskViewModel {
    processDefKey?: string | undefined;
    processDefName?: string | undefined;
    activityId?: string | undefined;
    activityName?: string | undefined;
    queryMode?: QueryMode;
    assigneeUsers?: AssigneeUser[] | undefined;
    /** 能上传附件或者编辑附件 */
    canUploadOrUpdateFiles?: boolean;
    /** 能够编辑表单 */
    canEditForm?: boolean;
}

export class UserCustomOpinion implements IUserCustomOpinion {
    id?: number;
    userName?: string | undefined;
    text?: string | undefined;
    dateTime?: Date;

    constructor(data?: IUserCustomOpinion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.text = _data["text"];
            this.dateTime = _data["dateTime"] ? new Date(_data["dateTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserCustomOpinion {
        data = typeof data === 'object' ? data : {};
        let result = new UserCustomOpinion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["text"] = this.text;
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IUserCustomOpinion {
    id?: number;
    userName?: string | undefined;
    text?: string | undefined;
    dateTime?: Date;
}

export class UserCustomOpinionViewModel implements IUserCustomOpinionViewModel {
    id?: number;
    userName?: string | undefined;
    text?: string | undefined;
    dateTime?: Date;
    stringId?: string | undefined;

    constructor(data?: IUserCustomOpinionViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.text = _data["text"];
            this.dateTime = _data["dateTime"] ? new Date(_data["dateTime"].toString()) : <any>undefined;
            this.stringId = _data["stringId"];
        }
    }

    static fromJS(data: any): UserCustomOpinionViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserCustomOpinionViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["text"] = this.text;
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
        data["stringId"] = this.stringId;
        return data; 
    }
}

export interface IUserCustomOpinionViewModel {
    id?: number;
    userName?: string | undefined;
    text?: string | undefined;
    dateTime?: Date;
    stringId?: string | undefined;
}

export class UserDto implements IUserDto {
    user?: ApplicationUser;
    roles?: ApplicationRole[] | undefined;
    departments?: Department[] | undefined;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user = _data["user"] ? ApplicationUser.fromJS(_data["user"]) : <any>undefined;
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(ApplicationRole.fromJS(item));
            }
            if (Array.isArray(_data["departments"])) {
                this.departments = [] as any;
                for (let item of _data["departments"])
                    this.departments!.push(Department.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        if (Array.isArray(this.departments)) {
            data["departments"] = [];
            for (let item of this.departments)
                data["departments"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUserDto {
    user?: ApplicationUser;
    roles?: ApplicationRole[] | undefined;
    departments?: Department[] | undefined;
}

export class UserDtoPaginationResult implements IUserDtoPaginationResult {
    succeeded?: boolean;
    errorMessage?: string | undefined;
    rows?: UserDto[] | undefined;
    total?: number;
    pageSize?: number;

    constructor(data?: IUserDtoPaginationResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.errorMessage = _data["errorMessage"];
            if (Array.isArray(_data["rows"])) {
                this.rows = [] as any;
                for (let item of _data["rows"])
                    this.rows!.push(UserDto.fromJS(item));
            }
            this.total = _data["total"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): UserDtoPaginationResult {
        data = typeof data === 'object' ? data : {};
        let result = new UserDtoPaginationResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["errorMessage"] = this.errorMessage;
        if (Array.isArray(this.rows)) {
            data["rows"] = [];
            for (let item of this.rows)
                data["rows"].push(item.toJSON());
        }
        data["total"] = this.total;
        data["pageSize"] = this.pageSize;
        return data; 
    }
}

export interface IUserDtoPaginationResult {
    succeeded?: boolean;
    errorMessage?: string | undefined;
    rows?: UserDto[] | undefined;
    total?: number;
    pageSize?: number;
}

export class UserGroup implements IUserGroup {
    id?: number;
    name?: string | undefined;
    desc?: string | undefined;
    order?: number;
    createDateTime?: Date;

    constructor(data?: IUserGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.desc = _data["desc"];
            this.order = _data["order"];
            this.createDateTime = _data["createDateTime"] ? new Date(_data["createDateTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserGroup {
        data = typeof data === 'object' ? data : {};
        let result = new UserGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["desc"] = this.desc;
        data["order"] = this.order;
        data["createDateTime"] = this.createDateTime ? this.createDateTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IUserGroup {
    id?: number;
    name?: string | undefined;
    desc?: string | undefined;
    order?: number;
    createDateTime?: Date;
}

export class UserIdAndDepartmentId implements IUserIdAndDepartmentId {
    userId?: string | undefined;
    departmentId?: string | undefined;

    constructor(data?: IUserIdAndDepartmentId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.departmentId = _data["departmentId"];
        }
    }

    static fromJS(data: any): UserIdAndDepartmentId {
        data = typeof data === 'object' ? data : {};
        let result = new UserIdAndDepartmentId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["departmentId"] = this.departmentId;
        return data; 
    }
}

export interface IUserIdAndDepartmentId {
    userId?: string | undefined;
    departmentId?: string | undefined;
}

export class UserReply implements IUserReply {
    id?: string | undefined;
    userName?: string | undefined;
    normalizedUserName?: string | undefined;
    email?: string | undefined;
    normalizedEmail?: string | undefined;
    emailConfirmed?: boolean;
    passwordHash?: string | undefined;
    securityStamp?: string | undefined;
    concurrencyStamp?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
    twoFactorEnabled?: boolean;
    lockoutEnd?: Date | undefined;
    lockoutEnabled?: boolean;
    accessFailedCount?: number;
    photo?: string | undefined;
    sex?: number;
    desc?: string | undefined;
    startWorkDate?: Date | undefined;
    name?: string | undefined;
    order?: number;
    mainDepatment?: string | undefined;
    departments?: string[] | undefined;
    departmentJob?: string | undefined;
    startWorkDateFormat?: string | undefined;
    isLeader?: boolean;

    constructor(data?: IUserReply) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.normalizedUserName = _data["normalizedUserName"];
            this.email = _data["email"];
            this.normalizedEmail = _data["normalizedEmail"];
            this.emailConfirmed = _data["emailConfirmed"];
            this.passwordHash = _data["passwordHash"];
            this.securityStamp = _data["securityStamp"];
            this.concurrencyStamp = _data["concurrencyStamp"];
            this.phoneNumber = _data["phoneNumber"];
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"];
            this.twoFactorEnabled = _data["twoFactorEnabled"];
            this.lockoutEnd = _data["lockoutEnd"] ? new Date(_data["lockoutEnd"].toString()) : <any>undefined;
            this.lockoutEnabled = _data["lockoutEnabled"];
            this.accessFailedCount = _data["accessFailedCount"];
            this.photo = _data["photo"];
            this.sex = _data["sex"];
            this.desc = _data["desc"];
            this.startWorkDate = _data["startWorkDate"] ? new Date(_data["startWorkDate"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.order = _data["order"];
            this.mainDepatment = _data["mainDepatment"];
            if (Array.isArray(_data["departments"])) {
                this.departments = [] as any;
                for (let item of _data["departments"])
                    this.departments!.push(item);
            }
            this.departmentJob = _data["departmentJob"];
            this.startWorkDateFormat = _data["startWorkDateFormat"];
            this.isLeader = _data["isLeader"];
        }
    }

    static fromJS(data: any): UserReply {
        data = typeof data === 'object' ? data : {};
        let result = new UserReply();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["normalizedUserName"] = this.normalizedUserName;
        data["email"] = this.email;
        data["normalizedEmail"] = this.normalizedEmail;
        data["emailConfirmed"] = this.emailConfirmed;
        data["passwordHash"] = this.passwordHash;
        data["securityStamp"] = this.securityStamp;
        data["concurrencyStamp"] = this.concurrencyStamp;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
        data["twoFactorEnabled"] = this.twoFactorEnabled;
        data["lockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>undefined;
        data["lockoutEnabled"] = this.lockoutEnabled;
        data["accessFailedCount"] = this.accessFailedCount;
        data["photo"] = this.photo;
        data["sex"] = this.sex;
        data["desc"] = this.desc;
        data["startWorkDate"] = this.startWorkDate ? this.startWorkDate.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["order"] = this.order;
        data["mainDepatment"] = this.mainDepatment;
        if (Array.isArray(this.departments)) {
            data["departments"] = [];
            for (let item of this.departments)
                data["departments"].push(item);
        }
        data["departmentJob"] = this.departmentJob;
        data["startWorkDateFormat"] = this.startWorkDateFormat;
        data["isLeader"] = this.isLeader;
        return data; 
    }
}

export interface IUserReply {
    id?: string | undefined;
    userName?: string | undefined;
    normalizedUserName?: string | undefined;
    email?: string | undefined;
    normalizedEmail?: string | undefined;
    emailConfirmed?: boolean;
    passwordHash?: string | undefined;
    securityStamp?: string | undefined;
    concurrencyStamp?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
    twoFactorEnabled?: boolean;
    lockoutEnd?: Date | undefined;
    lockoutEnabled?: boolean;
    accessFailedCount?: number;
    photo?: string | undefined;
    sex?: number;
    desc?: string | undefined;
    startWorkDate?: Date | undefined;
    name?: string | undefined;
    order?: number;
    mainDepatment?: string | undefined;
    departments?: string[] | undefined;
    departmentJob?: string | undefined;
    startWorkDateFormat?: string | undefined;
    isLeader?: boolean;
}

export class UsersOfDepartmentDto implements IUsersOfDepartmentDto {
    id?: number;
    user?: ApplicationUser;
    departmentJob?: string | undefined;
    isLeader?: boolean;
    orderInDepartment?: number | undefined;

    constructor(data?: IUsersOfDepartmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.user = _data["user"] ? ApplicationUser.fromJS(_data["user"]) : <any>undefined;
            this.departmentJob = _data["departmentJob"];
            this.isLeader = _data["isLeader"];
            this.orderInDepartment = _data["orderInDepartment"];
        }
    }

    static fromJS(data: any): UsersOfDepartmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new UsersOfDepartmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["departmentJob"] = this.departmentJob;
        data["isLeader"] = this.isLeader;
        data["orderInDepartment"] = this.orderInDepartment;
        return data; 
    }
}

export interface IUsersOfDepartmentDto {
    id?: number;
    user?: ApplicationUser;
    departmentJob?: string | undefined;
    isLeader?: boolean;
    orderInDepartment?: number | undefined;
}

export class UsersOfUserGroupDto implements IUsersOfUserGroupDto {
    user?: ApplicationUser;
    department?: Department;
    departmentJob?: string | undefined;
    order?: number;

    constructor(data?: IUsersOfUserGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user = _data["user"] ? ApplicationUser.fromJS(_data["user"]) : <any>undefined;
            this.department = _data["department"] ? Department.fromJS(_data["department"]) : <any>undefined;
            this.departmentJob = _data["departmentJob"];
            this.order = _data["order"];
        }
    }

    static fromJS(data: any): UsersOfUserGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new UsersOfUserGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["department"] = this.department ? this.department.toJSON() : <any>undefined;
        data["departmentJob"] = this.departmentJob;
        data["order"] = this.order;
        return data; 
    }
}

export interface IUsersOfUserGroupDto {
    user?: ApplicationUser;
    department?: Department;
    departmentJob?: string | undefined;
    order?: number;
}

export class UserTaskDelegateViewModel implements IUserTaskDelegateViewModel {
    id?: string | undefined;
    toUserDisplayName?: string | undefined;
    startDateTimeFormat?: string | undefined;
    endDateTimeFormat?: string | undefined;

    constructor(data?: IUserTaskDelegateViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.toUserDisplayName = _data["toUserDisplayName"];
            this.startDateTimeFormat = _data["startDateTimeFormat"];
            this.endDateTimeFormat = _data["endDateTimeFormat"];
        }
    }

    static fromJS(data: any): UserTaskDelegateViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserTaskDelegateViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["toUserDisplayName"] = this.toUserDisplayName;
        data["startDateTimeFormat"] = this.startDateTimeFormat;
        data["endDateTimeFormat"] = this.endDateTimeFormat;
        return data; 
    }
}

export interface IUserTaskDelegateViewModel {
    id?: string | undefined;
    toUserDisplayName?: string | undefined;
    startDateTimeFormat?: string | undefined;
    endDateTimeFormat?: string | undefined;
}

export class UserTaskDelegateViewModelTCollection implements IUserTaskDelegateViewModelTCollection {
    value?: UserTaskDelegateViewModel[] | undefined;

    constructor(data?: IUserTaskDelegateViewModelTCollection) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(UserTaskDelegateViewModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserTaskDelegateViewModelTCollection {
        data = typeof data === 'object' ? data : {};
        let result = new UserTaskDelegateViewModelTCollection();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUserTaskDelegateViewModelTCollection {
    value?: UserTaskDelegateViewModel[] | undefined;
}

export class UserTaskItem implements IUserTaskItem {
    userTaskItemType?: UserTaskItemType;
    key!: string;
    title?: string | undefined;
    queryMode?: QueryMode;
    children?: UserTaskItem[] | undefined;
    parent?: UserTaskItem;
    assigneeUsers?: AssigneeUser[] | undefined;
    /** 能上传附件或者编辑附件 */
    canUploadOrUpdateFiles?: boolean;
    /** 能够编辑表单 */
    canEditForm?: boolean;
    readonly scopedSlots?: any | undefined;

    constructor(data?: IUserTaskItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userTaskItemType = _data["userTaskItemType"];
            this.key = _data["key"];
            this.title = _data["title"];
            this.queryMode = _data["queryMode"];
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(UserTaskItem.fromJS(item));
            }
            this.parent = _data["parent"] ? UserTaskItem.fromJS(_data["parent"]) : <any>undefined;
            if (Array.isArray(_data["assigneeUsers"])) {
                this.assigneeUsers = [] as any;
                for (let item of _data["assigneeUsers"])
                    this.assigneeUsers!.push(AssigneeUser.fromJS(item));
            }
            this.canUploadOrUpdateFiles = _data["canUploadOrUpdateFiles"];
            this.canEditForm = _data["canEditForm"];
            (<any>this).scopedSlots = _data["scopedSlots"];
        }
    }

    static fromJS(data: any): UserTaskItem {
        data = typeof data === 'object' ? data : {};
        let result = new UserTaskItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userTaskItemType"] = this.userTaskItemType;
        data["key"] = this.key;
        data["title"] = this.title;
        data["queryMode"] = this.queryMode;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        if (Array.isArray(this.assigneeUsers)) {
            data["assigneeUsers"] = [];
            for (let item of this.assigneeUsers)
                data["assigneeUsers"].push(item.toJSON());
        }
        data["canUploadOrUpdateFiles"] = this.canUploadOrUpdateFiles;
        data["canEditForm"] = this.canEditForm;
        data["scopedSlots"] = this.scopedSlots;
        return data; 
    }
}

export interface IUserTaskItem {
    userTaskItemType?: UserTaskItemType;
    key: string;
    title?: string | undefined;
    queryMode?: QueryMode;
    children?: UserTaskItem[] | undefined;
    parent?: UserTaskItem;
    assigneeUsers?: AssigneeUser[] | undefined;
    /** 能上传附件或者编辑附件 */
    canUploadOrUpdateFiles?: boolean;
    /** 能够编辑表单 */
    canEditForm?: boolean;
    scopedSlots?: any | undefined;
}

export enum UserTaskItemType {
    _0 = 0,
    _1 = 1,
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}